[{"categories":["笔记"],"content":"34道MySql练习题 ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:0","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"前言 在web中最基础的部分就是写sql语句，大部分都是增删改查。但是水平实在是一言难尽，故此重新复习一遍。 ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:1","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"难度星级之攻略 都是自己亲身体验过的，随便打几颗星星玩（可能不太准确，笑）。有些知识点不熟悉所有显得有点难。还有一些题目不算难但是过程很绕或者是表述很绕，为了出题而出题，题目看懂了就还好。 PS：第13题是面试题，有单独的SQL文件。与其余的33道题的sql没有关联。 难度系数 题目序号 ★☆☆☆（有手就行） 18、21、23、27、30 ★★☆☆（基础部分） 1、2、9、10、11、17、23、25、29 ★★★☆（还可以吧） 3、4、5、6、8、12、14、15、16、25、 ★★★★（阅读理解） 7、13、19、20、22、24、26、28、33 ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:2","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"SQL文件及描述 DROPTABLEIFEXISTSEMP;DROPTABLEIFEXISTSDEPT;DROPTABLEIFEXISTSSALGRADE;CREATETABLEDEPT(DEPTNOint(2)notnull,DNAMEVARCHAR(14),LOCVARCHAR(13),primarykey(DEPTNO));CREATETABLEEMP(EMPNOint(4)notnull,ENAMEVARCHAR(10),JOBVARCHAR(9),MGRINT(4),HIREDATEDATEDEFAULTNULL,SALDOUBLE(7,2),COMMDOUBLE(7,2),primarykey(EMPNO),DEPTNOINT(2));CREATETABLESALGRADE(GRADEINT,LOSALINT,HISALINT);INSERTINTODEPT(DEPTNO,DNAME,LOC)VALUES(10,'ACCOUNTING','NEW YORK');INSERTINTODEPT(DEPTNO,DNAME,LOC)VALUES(20,'RESEARCH','DALLAS');INSERTINTODEPT(DEPTNO,DNAME,LOC)VALUES(30,'SALES','CHICAGO');INSERTINTODEPT(DEPTNO,DNAME,LOC)VALUES(40,'OPERATIONS','BOSTON');commit;INSERTINTOEMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)VALUES(7369,'SMITH','CLERK',7902,'1980-12-17',800,NULL,20);INSERTINTOEMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)VALUES(7499,'ALLEN','SALESMAN',7698,'1981-02-20',1600,300,30);INSERTINTOEMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)VALUES(7521,'WARD','SALESMAN',7698,'1981-02-22',1250,500,30);INSERTINTOEMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)VALUES(7566,'JONES','MANAGER',7839,'1981-04-02',2975,NULL,20);INSERTINTOEMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)VALUES(7654,'MARTIN','SALESMAN',7698,'1981-09-28',1250,1400,30);INSERTINTOEMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)VALUES(7698,'BLAKE','MANAGER',7839,'1981-05-01',2850,NULL,30);INSERTINTOEMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)VALUES(7782,'CLARK','MANAGER',7839,'1981-06-09',2450,NULL,10);INSERTINTOEMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)VALUES(7788,'SCOTT','ANALYST',7566,'1987-04-19',3000,NULL,20);INSERTINTOEMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)VALUES(7839,'KING','PRESIDENT',NULL,'1981-11-17',5000,NULL,10);INSERTINTOEMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)VALUES(7844,'TURNER','SALESMAN',7698,'1981-09-08',1500,0,30);INSERTINTOEMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)VALUES(7876,'ADAMS','CLERK',7788,'1987-05-23',1100,NULL,20);INSERTINTOEMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)VALUES(7900,'JAMES','CLERK',7698,'1981-12-03',950,NULL,30);INSERTINTOEMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)VALUES(7902,'FORD','ANALYST',7566,'1981-12-03',3000,NULL,20);INSERTINTOEMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)VALUES(7934,'MILLER','CLERK',7782,'1982-01-23',1300,NULL,10);commit;INSERTINTOSALGRADE(GRADE,LOSAL,HISAL)VALUES(1,700,1200);INSERTINTOSALGRADE(GRADE,LOSAL,HISAL)VALUES(2,1201,1400);INSERTINTOSALGRADE(GRADE,LOSAL,HISAL)VALUES(3,1401,2000);INSERTINTOSALGRADE(GRADE,LOSAL,HISAL)VALUES(4,2001,3000);INSERTINTOSALGRADE(GRADE,LOSAL,HISAL)VALUES(5,3001,9999);commit; ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:3","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"1、取得每个部门最高薪水的人员名称 思路： 取得每个部门最高薪水（按部门编号分组，找出每一组最大值） selectdeptno,max(sal)asmaxsalfromempgroupbydeptno;+--------+---------+ |deptno|maxsal|+--------+---------+ |10|5000.00||20|3000.00||30|2850.00|+--------+---------+ 将以上的表作为一张临时表t，t和emp表连接，条件是t.deptno=e.deptno and t.maxsal=e.sal 完整SQL： selecte.ename,t.*fromempejoin(selectdeptno,max(sal)asmaxsalfromempgroupbydeptno)tont.deptno=e.deptnoandt.maxsal=e.sal;+-------+--------+---------+ |ename|deptno|maxsal|+-------+--------+---------+ |BLAKE|30|2850.00||SCOTT|20|3000.00||KING|10|5000.00||FORD|20|3000.00|+-------+--------+---------+ ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:4","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"2、哪些人的薪水在平均薪水之上 思路： 求出每个部门的平均薪水 selectdeptno,AVG(sal)asavgsalfromempgroupbydeptno;+--------+-------------+ |deptno|avgsal|+--------+-------------+ |10|2916.666667||20|2175.000000||30|1566.666667|+--------+-------------+ 将上面的查询结果当做t表，t和emp表连接，条件部门编号相同，t.avgsal \u003c e.SAL 完整SQL： SELECTe.ename,e.SALFROMempeJOIN(SELECTdeptno,AVG(sal)ASavgsalFROMempGROUPBYdeptno)tONt.avgsal\u003ce.SALANDt.deptno=e.deptno;+-------+---------+ |ename|SAL|+-------+---------+ |ALLEN|1600.00||JONES|2975.00||BLAKE|2850.00||SCOTT|3000.00||KING|5000.00||FORD|3000.00|+-------+---------+ ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:5","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"3、取得部门中（所有人的）平均的薪水等级 区别： 平均的薪水等级：先计算每个薪水的等级，然后找出薪水等级的平均值。 平均薪水的等级：先计算平均薪水，再找出每个平均薪水的等级。 思路： 根据部门找出每个人的薪水等级 epm e和salgrade s表连接 连接条件：e.sal between s.losal and s.hisal 我们可以在后面加上 order by e.deptno排序一下 selecte.ename,e.sal,e.deptno,s.gradeassgradefromempejoinsalgradesone.salbetweens.losalands.hisal;+--------+---------+--------+--------+ |ename|sal|deptno|sgrade|+--------+---------+--------+--------+ |MILLER|1300.00|10|2||CLARK|2450.00|10|4||KING|5000.00|10|5||SCOTT|3000.00|20|4||SMITH|800.00|20|1||ADAMS|1100.00|20|1||JONES|2975.00|20|4||FORD|3000.00|20|4||BLAKE|2850.00|30|4||ALLEN|1600.00|30|3||TURNER|1500.00|30|3||WARD|1250.00|30|2||JAMES|950.00|30|1||MARTIN|1250.00|30|2|+--------+---------+--------+--------+ 我们需要求的平均的薪水等级，就把每个相同部门的人的等级相加，然后就平均值即可。 2. 基于上面的表按照deptno分组， selecte.deptno,avg(s.grade)asavggradefromempejoinsalgradesone.salbetweens.losalands.hisalgroupbye.deptno;+--------+----------+ |deptno|avggrade|+--------+----------+ |10|3.6667||20|2.8000||30|2.5000|+--------+----------+ 我们会发现，上面的那个表并不需要成为一张临时表，我们仅仅通过deptno把上面的表做一次分组就好了。但是分组之后出现了一个问题，如果在select语句中仍然存在e.ename,那么会报错，这是什么原因呢。使用group by 分组聚合，那么就把原先的相同的部门聚合成了一组，这个时候，他们相同的字段只有部门编号，而名字在聚合中是不同的，我们提取不了不同的值。 ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:6","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"4、不准用组函数（Max），取得最高薪水（给出两种解决方案） 第一种：使用order by sal,通过sal进行排序，desc降序，再使用limit分页，取第一条数据即可。【升序(ASC)或降序(DESC)】 selectename,salfromemporderbysaldesclimit1;+-------+---------+ |ename|sal|+-------+---------+ |KING|5000.00|+-------+---------+ 第二种：（不讲规矩）直接使用max，最简单的方法。 selectmax(sal)fromemp; 第三种：表的自连接+去重+not in 把同一个emp表做两份，进行自连接，判断条件a表的sal与b表的sal的大小比较。 去重，通过比较，留不下的是5000，因为5000最大，条件不成立。 把上面的表当做一个临时表，使用where进行条件判断，查出不在临时表中数据。 selectsalfromempwheresalnotin(selectdistincta.salfromempajoinempbona.sal\u003cb.sal);+---------+ |sal|+---------+ |5000.00|+---------+ ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:7","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"5、取得平均薪水最高的部门的部门编号（至少给出两种解决方案） 第一种：使用排序，limit1 第一步： 找出每个部门的平均薪水 selecte.deptno,avg(e.sal)fromempegroupbydeptno;+--------+-------------+ |deptno|avg(e.sal)|+--------+-------------+ |10|2916.666667||20|2175.000000||30|1566.666667|+--------+-------------+ 第二步：根据平均薪水进行降序排序，取第一个数值 selecte.deptno,avg(e.sal)asavgsalfromempegroupbydeptnoorderbyavgsaldesclimit1;+--------+-------------+ |deptno|avgsal|+--------+-------------+ |10|2916.666667|+--------+-------------+ 第二种：使用max 第一步同上， selecte.deptno,avg(e.sal)asavgsalfromempegroupbydeptno; 第二步使用max，不能直接在上面套一个max,max(avg(e.sal))写法是错误的， selectmax(t.avgsal)fromt; 拿到最大值： selectmax(t.avgsal)from(selecte.deptno,avg(e.sal)asavgsalfromempegroupbydeptno)t+---------------+ |max(t.avgsal)|+---------------+ |2916.666667|+---------------+ 第三步使用having与第一步的表进行连接 selecte.deptno,avg(e.sal)asavgsalfromempegroupbydeptnohavingavgsal=(selectmax(t.avgsal)from(selecte.deptno,avg(e.sal)asavgsalfromempegroupbydeptno)t);+--------+-------------+ |deptno|avgsal|+--------+-------------+ |10|2916.666667|+--------+-------------+ 附上自己错误的用法： Tips: Having的用法： having字句可以让我们筛选成组后的各种数据，where字句在聚合前先筛选记录，也就是说作用在group by和having字句前。而 having子句在聚合后对组记录进行筛选。 HAVING 只能与 SELECT 语句一起使用。 HAVING 通常在 GROUP BY 子句中使用。 如果不使用 GROUP BY 子句，则 HAVING 的行为与 WHERE 子句一样。 https://bbs.csdn.net/topics/390162668 使用max的第二种思路，与dept表连接（这是视频里一个同学的写法，但是看弹幕里mysql8.0以后好像会报错） selectd.dname,d.deptnofrom(selecte.deptno,avg(e.sal)avgsalfromempegroupbydeptno)tjoindeptdont.deptno=d.deptnohavingmax(avgsal); ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:8","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"6、取得平均薪水最高的部门的部门名称 按deptno分组，排序，limit1只选最大值。再与dept表按t.deptno = d.deptno连接 ---------------第一种写法-------------- selectt.*,d.dnamefrom(selectdeptno,avg(sal)asavgsalfromempgroupbydeptnoorderbyavgsaldesclimit1)tjoindeptdont.deptno=d.deptno;+--------+-------------+------------+ |deptno|avgsal|dname|+--------+-------------+------------+ |10|2916.666667|ACCOUNTING|+--------+-------------+------------+ ---------------第二种写法-------------- selectd.dname,avg(e.sal)asavgsalfromempejoindeptdone.deptno=d.deptnogroupbyd.dnameorderbyavgsaldesclimit1;+------------+-------------+ |dname|avgsal|+------------+-------------+ |ACCOUNTING|2916.666667|+------------+-------------+ 这里的第二种写法通过d表的dname进行分组聚合，那么在select中就可以直接使用d.dname字段了。算是一种讨巧的方法。 ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:9","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"7、求平均薪水的等级最低的部门的部门名称 我的思路：先求部门的平均薪水等级，（正好前面第三题与这个类似）再连表升序选第一个搞定。 selectd.dnamefrom(selecte.deptnoasdeptno,avg(s.grade)asavgsalfromempejoinsalgradesone.salbetweens.losalands.hisalgroupbydeptno)tjoindeptdond.deptno=t.deptnoorderbyt.avgsalasclimit1;+-------+ |dname|+-------+ |SALES|+-------+ 我们上面的思路实际上是求平均的薪水等级按照grade求平均数。 而题目让求的是平均薪水的等级使用sal求平均数。 但是这样看似得到了答案，但是却不严谨。我们来思考两个问题。 平均薪水最低，那么薪水等级一定是最低。 平均薪水不是最低，但也有可能是等级最低。 打个比方，薪资在1000-1500,的属于薪资等级1，1500-2000的属于薪资等级2。那么有三个员工，工资分别是1100,1300,1800。毫无疑问，工资最低的1100,薪水等级也是最低的1。而工资不是最低的1300，薪资等级却也是1。 因此上面的sql语句是错误的，而且不够严谨。正确思路如下， 思路： 第一步：找出每个部门的平均薪水(按照部门分组求平均值) selectdeptno,avg(sal)asavgsalfromempgroupbydeptno;+--------+-------------+ |deptno|avgsal|+--------+-------------+ |10|2916.666667||20|2175.000000||30|1566.666667|+--------+-------------+ 第二步：找出每个部门的平均薪水等级。以上t表和salgrade表连接，条件是t.avgsal between s.losal and s.hisal，查出此表之后，我们还缺一个该如何查出最低的等级。 selectt.*,s.gradefrom(selectdeptno,avg(sal)asavgsalfromempgroupbydeptno)tjoinsalgradesont.avgsalbetweens.losalands.hisal;+--------+-------------+-------+ |deptno|avgsal|grade|+--------+-------------+-------+ |10|2916.666667|4||20|2175.000000|4||30|1566.666667|3|+--------+-------------+-------+ 我们可以想到，求最低等级 ==\u003e 平均薪水最低的等级一定是最低的，因此我们做的是通过最低的平均薪水来查出最低的薪水等级。这样做很严谨，因为等级是一个区间，就算有两个相同的最低等级也能查的出来，而不是使用limit1只能查出来一个。 步骤一：查到最低的平均薪水。 selectavg(sal)asavgsalfromempgroupbydeptnoorderbyavgsalasclimit1;+-------------+ |avgsal|+-------------+ |1566.666667|+-------------+ 步骤二： 将上表加入salgrade，通过最低的平均薪水查到最低的薪水等级。 条件是 avgsal between losal and hisal selectgradefromsalgradeswhere(1566.666667)betweens.losalands.hisal+-------+ |grade|+-------+ |3|+-------+ 我们把数值替换成sql语句 selectgradefromsalgradeswhere(selectavg(sal)asavgsalfromempgroupbydeptnoorderbyavgsalasclimit1)betweens.losalands.hisal;+-------+ |grade|+-------+ |3|+-------+ 步骤三：将上面大致思路的第二步中再加入一个where条件即加入上面这张表 selectt.*,s.gradefrom(selectdeptno,avg(sal)asavgsalfromempgroupbydeptno)tjoinsalgradesont.avgsalbetweens.losalands.hisalwheres.grade=(selectgradefromsalgradeswhere(selectavg(sal)asavgsalfromempgroupbydeptnoorderbyavgsalasclimit1)betweens.losalands.hisal);+--------+-------------+-------+ |deptno|avgsal|grade|+--------+-------------+-------+ |30|1566.666667|3|+--------+-------------+-------+ 至此，我们基本已经完成了。但是想要查询的字段不是部门编号，而是名称。只需要在这行中连接一下dept表。from (select deptno,avg(sal) as avgsal from emp group by deptno ) t selectt.*,s.gradefrom(selectd.dname,avg(e.sal)asavgsalfromempejoindeptdone.deptno=d.deptnogroupbyd.dname)tjoinsalgradesont.avgsalbetweens.losalands.hisalwheres.grade=(selectgradefromsalgradeswhere(selectavg(sal)asavgsalfromempgroupbydeptnoorderbyavgsalasclimit1)betweens.losalands.hisal);+-------+-------------+-------+ |dname|avgsal|grade|+-------+-------------+-------+ |SALES|1566.666667|3|+-------+-------------+-------+ ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:10","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"8、取得比普通员工(员工代码没有在mgr字段上出现的)的最高薪水还要高的领导人姓名 selectdistinctmgrfromemp;+------+ |mgr|+------+ |7902||7698||7839||7566||NULL||7788||7782|+------+ 员工编号没有在以上范围内的都是普通员工。 思路： 步骤一： 找出普通员工的最高薪水。 selectmax(sal)fromempwhere普通员工 selectmax(sal)fromempwhereempnonotin(selectdistinctmgrfromemp) 会发现查出来的是NULL。Tips: not in在使用的时候，后面的小括号记得排除NULL。 selectmax(sal)fromempwhereempnonotin(selectdistinctmgrfromempwheremgrisnotnull)+----------+ |max(sal)|+----------+ |1600.00|+----------+ 步骤二：找出高于1600的 selecte.ename,e.salfromempewheree.sal\u003e(selectmax(sal)fromempwhereempnonotin(selectdistinctmgrfromempwheremgrisnotnull));+-------+---------+ |ename|sal|+-------+---------+ |JONES|2975.00||BLAKE|2850.00||CLARK|2450.00||SCOTT|3000.00||KING|5000.00||FORD|3000.00|+-------+---------+ ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:11","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"9、取得薪水最高的前五名员工 selectename,salfromemporderbysaldesclimit5;+-------+---------+ |ename|sal|+-------+---------+ |KING|5000.00||FORD|3000.00||SCOTT|3000.00||JONES|2975.00||BLAKE|2850.00|+-------+---------+ ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:12","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"10、取得薪水最高的第六到第十名员工 selectename,salfromemporderbysaldesclimit5,5;+--------+---------+ |ename|sal|+--------+---------+ |CLARK|2450.00||ALLEN|1600.00||TURNER|1500.00||MILLER|1300.00||WARD|1250.00|+--------+---------+ ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:13","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"11、取得最后入职的5名员工 日期降序排列。。。。从最近的日期到最远的日期。 selectename,hiredatefromemporderbyhiredatedesclimit5;+--------+------------+ |ename|hiredate|+--------+------------+ |ADAMS|1987-05-23||SCOTT|1987-04-19||MILLER|1982-01-23||JAMES|1981-12-03||FORD|1981-12-03|+--------+------------+ ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:14","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"12、取得每个薪水等级有多少员工 第一步：找出每个员工的薪水等级 selecte.ename,e.sal,s.gradefromempejoinsalgradesone.salbetweens.losalands.hisal;+--------+---------+-------+ |ename|sal|grade|+--------+---------+-------+ |SMITH|800.00|1||ALLEN|1600.00|3||WARD|1250.00|2||JONES|2975.00|4||MARTIN|1250.00|2||BLAKE|2850.00|4||CLARK|2450.00|4||SCOTT|3000.00|4||KING|5000.00|5||TURNER|1500.00|3||ADAMS|1100.00|1||JAMES|950.00|1||FORD|3000.00|4||MILLER|1300.00|2|+--------+---------+-------+ 第二步：继续分组统计数量 selects.grade,count(*)fromempejoinsalgradesone.salbetweens.losalands.hisalgroupbys.grade;+-------+----------+ |grade|count(*)|+-------+----------+ |1|3||2|3||3|2||4|5||5|1|+-------+----------+ 小Tips: 如果存在分组函数，比如这里group by s.grade那么在select 中只能写分组的字段和分组函数。 ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:15","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"13、面试题 SQL 文件 CREATETABLESC(SNOVARCHAR(200),CNOVARCHAR(200),SCGRADEVARCHAR(200));CREATETABLES(SNOVARCHAR(200),SNAMEVARCHAR(200));CREATETABLEC(CNOVARCHAR(200),CNAMEVARCHAR(200),CTEACHERVARCHAR(200));INSERTINTOC(CNO,CNAME,CTEACHER)VALUES('1','语文','张');INSERTINTOC(CNO,CNAME,CTEACHER)VALUES('2','政治','王');INSERTINTOC(CNO,CNAME,CTEACHER)VALUES('3','英语','李');INSERTINTOC(CNO,CNAME,CTEACHER)VALUES('4','数学','赵');INSERTINTOC(CNO,CNAME,CTEACHER)VALUES('5','物理','黎明');commit;INSERTINTOS(SNO,SNAME)VALUES('1','学生1');INSERTINTOS(SNO,SNAME)VALUES('2','学生2');INSERTINTOS(SNO,SNAME)VaLUES('3','学生3');INSERTINTOS(SNO,SNAME)VALUES('4','学生4');commit;INSERTINTOSC(SNO,CNO,SCGRADE)VALUES('1','1','40');INSERTINTOSC(SNO,CNO,SCGRADE)VALUES('1','2','30');INSERTINTOSC(SNO,CNO,SCGRADE)VALUES('1','3','20');INSERTINTOSC(SNO,CNO,SCGRADE)VALUES('1','4','80');INSERTINTOSC(SNO,CNO,SCGRADE)VALUES('1','5','60');INSERTINTOSC(SNO,CNO,SCGRADE)VALUES('2','1','60');INSERTINTOSC(SNO,CNO,SCGRADE)VALUES('2','2','60');INSERTINTOSC(SNO,CNO,SCGRADE)VALUES('2','3','60');INSERTINTOSC(SNO,CNO,SCGRADE)VALUES('2','4','60');INSERTINTOSC(SNO,CNO,SCGRADE)VALUES('2','5','40');INSERTINTOSC(SNO,CNO,SCGRADE)VALUES('3','1','60');INSERTINTOSC(SNO,CNO,SCGRADE)VALUES('3','3','80');commit; 描述 有3个表S(学生表)，C（课程表），SC（学生选课表） S（SNO，SNAME）代表（学号，姓名） C（CNO，CNAME，CTEACHER）代表（课号，课名，教师） SC（SNO，CNO，SCGRADE）代表（学号，课号，成绩） 问题1：找出没选过“黎明”老师的所有学生姓名。 selectsnamefromSwheresnamenotin(selects.snamefromSCscjoinCconsc.cno=c.cnojoinSsonsc.sno=s.snowherec.cteacher='黎明');+-------+ |sname|+-------+ |学生3||学生4|+-------+ 问题2：列出2门以上（含2门）不及格学生姓名及平均成绩。 -- 查询2门及以上的未及格的学生 selectsc.sno,count(sc.sno)ascountfromSCscjoinSsonsc.sno=s.snowheresc.scgrade\u003c60groupbysc.snohavingcount\u003e=2;+------+-------+ |sno|count|+------+-------+ |1|3|+------+-------+ -- 与S表,SC表连接，条件t.sno = s.sno selects.sname,avg(sc.scgrade)fromSsjoinSCscons.sno=sc.snojoin()tont.sno=s.snogroupbys.sname;-- 填入 selects.sname,avg(sc.scgrade)fromSsjoinSCscons.sno=sc.snojoin(selectsc.sno,count(sc.sno)ascountfromSCscjoinSsonsc.sno=s.snowheresc.scgrade\u003c60groupbysc.snohavingcount\u003e=2)tont.sno=s.snogroupbys.sname;+-------+-----------------+ |sname|avg(sc.scgrade)|+-------+-----------------+ |学生1|46|+-------+-----------------+ 问题3：即学过1号课程又学过2号课所有学生的姓名。 -- 同时学过1,2号课程的 selectsnofromscwherecno=1andsnoin(selectsnofromscwherecno=2);+------+ |sno|+------+ |1||2|+------+ -- 与sc表连接 t.sno = s.sno selects.snamefromSsjoin(selectsnofromscwherecno=1andsnoin(selectsnofromscwherecno=2))tont.sno=s.sno;+-------+ |sname|+-------+ |学生1||学生2|+-------+ ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:16","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"14、列出所有员工及其领导的姓名 selecta.enameas'员工',b.enameas'领导'fromempaleftjoinempbona.mgr=b.empno;+--------+-------+ |员工|领导|+--------+-------+ |SMITH|FORD||ALLEN|BLAKE||WARD|BLAKE||JONES|KING||MARTIN|BLAKE||BLAKE|KING||CLARK|KING||SCOTT|JONES||KING|NULL||TURNER|BLAKE||ADAMS|SCOTT||JAMES|BLAKE||FORD|JONES||MILLER|CLARK|+--------+-------+ 小Tips: left join（左联接）：返回左表中的所有记录以及和右表中的联接字段相等的记录。 right join（右联接）：返回右表中的所有记录以及和左表中的联接字段相等的记录。 inner join（等值联接，join）：只返回两个表中联接字段相等的记录。 相关文章：https://segmentfault.com/a/1190000017369618 ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:17","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"15、列出受雇日期早于其直接上级的所有员工的编号,姓名,部门名称 思路： emp a 员工表 emp b 领导表 受雇日期早于领导 ==\u003e a.mgr = b.empno and a.hiredate\u003cb.hiredate selecta.empnoasempno,a.enameasename,d.dnamefromempajoindeptdona.deptno=d.deptnojoinempbona.mgr=b.empnowherea.hiredate\u003cb.hiredate; 小Tips：多表连接，多次使用join连接 ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:18","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"16、列出部门名称和这些部门的员工信息,同时列出那些没有员工的部门 selectd.dname,e.*fromemperightjoindeptdone.deptno=d.deptnoorderbye.deptno;+------------+-------+--------+-----------+------+------------+---------+---------+--------+ |dname|EMPNO|ENAME|JOB|MGR|HIREDATE|SAL|COMM|DEPTNO|+------------+-------+--------+-----------+------+------------+---------+---------+--------+ |OPERATIONS|NULL|NULL|NULL|NULL|NULL|NULL|NULL|NULL||ACCOUNTING|7839|KING|PRESIDENT|NULL|1981-11-17|5000.00|NULL|10||ACCOUNTING|7934|MILLER|CLERK|7782|1982-01-23|1300.00|NULL|10||ACCOUNTING|7782|CLARK|MANAGER|7839|1981-06-09|2450.00|NULL|10||RESEARCH|7788|SCOTT|ANALYST|7566|1987-04-19|3000.00|NULL|20||RESEARCH|7369|SMITH|CLERK|7902|1980-12-17|800.00|NULL|20||RESEARCH|7902|FORD|ANALYST|7566|1981-12-03|3000.00|NULL|20||RESEARCH|7876|ADAMS|CLERK|7788|1987-05-23|1100.00|NULL|20||RESEARCH|7566|JONES|MANAGER|7839|1981-04-02|2975.00|NULL|20||SALES|7900|JAMES|CLERK|7698|1981-12-03|950.00|NULL|30||SALES|7654|MARTIN|SALESMAN|7698|1981-09-28|1250.00|1400.00|30||SALES|7499|ALLEN|SALESMAN|7698|1981-02-20|1600.00|300.00|30||SALES|7698|BLAKE|MANAGER|7839|1981-05-01|2850.00|NULL|30||SALES|7844|TURNER|SALESMAN|7698|1981-09-08|1500.00|0.00|30||SALES|7521|WARD|SALESMAN|7698|1981-02-22|1250.00|500.00|30|+------------+-------+--------+-----------+------+------------+---------+---------+--------+ 小Tips：使用右外连接，right join ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:19","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"17、列出至少有5个员工的所有部门 selectd.dname,count(*)fromempejoindeptdone.deptno=d.deptnogroupbyd.dnamehavingcount(*)\u003e=5;+----------+----------+ |dname|count(*)|+----------+----------+ |RESEARCH|5||SALES|6|+----------+----------+ ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:20","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"18、列出薪金比\"SMITH\"多的所有员工信息 selecte.*fromempewheree.sal\u003e(selectsalfromempwhereename=\"SMITH\");+-------+--------+-----------+------+------------+---------+---------+--------+ |EMPNO|ENAME|JOB|MGR|HIREDATE|SAL|COMM|DEPTNO|+-------+--------+-----------+------+------------+---------+---------+--------+ |7499|ALLEN|SALESMAN|7698|1981-02-20|1600.00|300.00|30||7521|WARD|SALESMAN|7698|1981-02-22|1250.00|500.00|30||7566|JONES|MANAGER|7839|1981-04-02|2975.00|NULL|20||7654|MARTIN|SALESMAN|7698|1981-09-28|1250.00|1400.00|30||7698|BLAKE|MANAGER|7839|1981-05-01|2850.00|NULL|30||7782|CLARK|MANAGER|7839|1981-06-09|2450.00|NULL|10||7788|SCOTT|ANALYST|7566|1987-04-19|3000.00|NULL|20||7839|KING|PRESIDENT|NULL|1981-11-17|5000.00|NULL|10||7844|TURNER|SALESMAN|7698|1981-09-08|1500.00|0.00|30||7876|ADAMS|CLERK|7788|1987-05-23|1100.00|NULL|20||7900|JAMES|CLERK|7698|1981-12-03|950.00|NULL|30||7902|FORD|ANALYST|7566|1981-12-03|3000.00|NULL|20||7934|MILLER|CLERK|7782|1982-01-23|1300.00|NULL|10|+-------+--------+-----------+------+------------+---------+---------+--------+ ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:21","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"19、列出所有\"CLERK\"(办事员)的姓名及其部门名称,部门的人数 selecte.ename,d.dnamefromempejoindeptdone.deptno=d.deptnowheree.job=\"CLERK\";+--------+------------+ |ename|dname|+--------+------------+ |SMITH|RESEARCH||ADAMS|RESEARCH||JAMES|SALES||MILLER|ACCOUNTING|+--------+------------+ 到这一步很容易，那么后面的问题来了，怎么把部门的人数连上？ 如果直接在使用group by d.dname分组，那么select中就无法使用e.name字段，还是查不出来。因此还是老老实实想办法用临时表吧。 在上表中再加一个字段，d.deptno。这样在对emp表通过deptno做分组得出数量的同时有了deptno字段。既然有了相同的字段，那么就可以愉快的使用连表进行join了。 -- 第一步： selecte.ename,d.dname,e.deptnoasdeptnofromempejoindeptdone.deptno=d.deptnowheree.job=\"CLERK\";+--------+------------+--------+ |ename|dname|deptno|+--------+------------+--------+ |SMITH|RESEARCH|20||ADAMS|RESEARCH|20||JAMES|SALES|30||MILLER|ACCOUNTING|10|+--------+------------+--------+ -- 第二步： 对emp单独做分组，查询数量 selectdeptno,count(*)asdeptcountfromempgroupbydeptno;+--------+-----------+ |deptno|deptcount|+--------+-----------+ |10|3||20|5||30|6|+--------+-----------+ -- 第三步：好了，现在直接通过deptno 进行连表操作。 selectt.*,tt.deptcountfrom()tjoin()ttont.deptno=tt.deptno;-- 第四步：填入上面的两个语句。 selectt.*,tt.deptcountfrom(selecte.ename,d.dname,e.deptnoasdeptnofromempejoindeptdone.deptno=d.deptnowheree.job=\"CLERK\")tjoin(selectdeptno,count(*)asdeptcountfromempgroupbydeptno)ttont.deptno=tt.deptno;+--------+------------+--------+-----------+ |ename|dname|deptno|deptcount|+--------+------------+--------+-----------+ |SMITH|RESEARCH|20|5||ADAMS|RESEARCH|20|5||JAMES|SALES|30|6||MILLER|ACCOUNTING|10|3|+--------+------------+--------+-----------+ ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:22","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"20、列出最低薪金大于1500的各种工作及从事此工作的全部雇员人数 selecte.job,count(*)fromempegroupbye.jobhavingmin(sal)\u003e1500;+-----------+----------+ |job|count(*)|+-----------+----------+ |ANALYST|2||MANAGER|3||PRESIDENT|1|+-----------+----------+ ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:23","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"21、列出在部门\"SALES\"\u003c销售部\u003e工作的员工的姓名,假定不知道销售部的部门编号 。。。。想复杂了，以为是没有deptno字段，那样就没法做到连表了。 selectenamefromempwheredeptno=(selectdeptnofromdeptwheredname=\"SALES\");+--------+ |ename|+--------+ |ALLEN||WARD||MARTIN||BLAKE||TURNER||JAMES|+--------+ ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:24","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"22、列出薪金高于公司平均薪金的所有员工,所在部门,上级领导,雇员的工资等级 selecte.enameas'员工',d.dnameas'部门',l.enameas'领导',s.gradeas'等级'fromempejoindeptdone.deptno=d.deptnoleftjoinemplone.mgr=l.empnojoinsalgradesone.salbetweens.losalands.hisalwheree.sal\u003e(selectavg(sal)fromemp);+-------+------------+-------+-------+ |员工|部门|领导|grade|+-------+------------+-------+-------+ |JONES|RESEARCH|KING|4||BLAKE|SALES|KING|4||CLARK|ACCOUNTING|KING|4||SCOTT|RESEARCH|JONES|4||KING|ACCOUNTING|NULL|5||FORD|RESEARCH|JONES|4|+-------+------------+-------+-------+ ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:25","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"23、列出与\"SCOTT\"从事相同工作的所有员工及部门名称 selecte.job,e.ename,d.dnamefromempejoindeptdone.deptno=d.deptnowheree.job=(selectjobfromempwhereename=\"SCOTT\")ande.ename\u003c\u003e'SCOTT';+---------+-------+----------+ |job|ename|dname|+---------+-------+----------+ |ANALYST|FORD|RESEARCH|+---------+-------+----------+ 小Tips：要排除SCOTT自己，所以需要加上一个and条件 ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:26","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"24、列出薪金等于部门30中员工的薪金的其他员工的姓名和薪金 -- 去重求出部门为30的所有薪金 selectdistinctsalfromempwheredeptno='30';-- 筛选薪金是上表中的人 selectename,salfromempwheresalin()-- 放进去,且不是这个部门的人 selectename,salfromempwheresalin(selectdistinctsalfromempwheredeptno='30')anddeptno\u003c\u003e'30';空白表！Emptyset(0.00sec) ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:27","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"25、列出薪金高于在部门30工作的所有员工的薪金的员工姓名和薪金.部门名称 -- 求出部门30员工的最高薪资 selectmax(sal)fromempgroupbydeptnohavingdeptno=\"30\";+----------+ |max(sal)|+----------+ |2850.00|+----------+ -- 大于最高薪资就好了 selecte.ename,e.sal,d.dnamefromempejoindeptdond.deptno=e.deptnowhered.deptno\u003c\u003e'30'ande.sal\u003e(selectmax(sal)fromempgroupbydeptnohavingdeptno=\"30\");+-------+---------+------------+ |ename|sal|dname|+-------+---------+------------+ |JONES|2975.00|RESEARCH||SCOTT|3000.00|RESEARCH||KING|5000.00|ACCOUNTING||FORD|3000.00|RESEARCH|+-------+---------+------------+ 小Tips: 不等于可以写成 \u003c\u003e ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:28","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"26、列出在每个部门工作的员工数量,平均工资和平均服务期限 selectd.*,count(e.ename),avg(e.sal)fromemperightjoindeptdone.deptno=d.deptnogroupbyd.deptno,d.dname,d.loc;+--------+------------+----------+----------------+-------------+ |DEPTNO|DNAME|LOC|count(e.ename)|avg(e.sal)|+--------+------------+----------+----------------+-------------+ |10|ACCOUNTING|NEWYORK|3|2916.666667||20|RESEARCH|DALLAS|5|2175.000000||30|SALES|CHICAGO|6|1566.666667||40|OPERATIONS|BOSTON|0|NULL|+--------+------------+----------+----------------+-------------+ -- 为了不输出NULL,改一下 selectd.*,count(e.ename),ifnull(avg(e.sal),0)fromemperightjoindeptdone.deptno=d.deptnogroupbyd.deptno,d.dname,d.loc;+--------+------------+----------+----------------+----------------------+ |DEPTNO|DNAME|LOC|count(e.ename)|ifnull(avg(e.sal),0)|+--------+------------+----------+----------------+----------------------+ |10|ACCOUNTING|NEWYORK|3|2916.666667||20|RESEARCH|DALLAS|5|2175.000000||30|SALES|CHICAGO|6|1566.666667||40|OPERATIONS|BOSTON|0|0.000000|+--------+------------+----------+----------------+----------------------+ -- 服务期限 selectd.*,count(e.ename),ifnull(avg(e.sal),0),avg(timestampdiff(YEAR,hiredate,now()))asavgyearfromemperightjoindeptdone.deptno=d.deptnogroupbyd.deptno,d.dname,d.loc;+--------+------------+----------+----------------+----------------------+---------+ |DEPTNO|DNAME|LOC|count(e.ename)|ifnull(avg(e.sal),0)|avgyear|+--------+------------+----------+----------------+----------------------+---------+ |10|ACCOUNTING|NEWYORK|3|2916.666667|39.3333||20|RESEARCH|DALLAS|5|2175.000000|37.4000||30|SALES|CHICAGO|6|1566.666667|39.8333||40|OPERATIONS|BOSTON|0|0.000000|NULL|+--------+------------+----------+----------------+----------------------+---------+ 小Tips: 分组函数group，可以有多个字段共同分组。这样在select中就可以查询多个字段 ifnull(,)这个函数可以把空值替换成想要的值。 TimeStampDiff(间隔类型，前一个日期，后一个日期) ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:29","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"27、列出所有员工的姓名、部门名称和工资 selecte.ename,d.dname,e.salfromempejoindeptdone.deptno=d.deptnoorderbyd.dname;+--------+------------+---------+ |ename|dname|sal|+--------+------------+---------+ |CLARK|ACCOUNTING|2450.00||MILLER|ACCOUNTING|1300.00||KING|ACCOUNTING|5000.00||FORD|RESEARCH|3000.00||SMITH|RESEARCH|800.00||SCOTT|RESEARCH|3000.00||JONES|RESEARCH|2975.00||ADAMS|RESEARCH|1100.00||BLAKE|SALES|2850.00||ALLEN|SALES|1600.00||WARD|SALES|1250.00||TURNER|SALES|1500.00||MARTIN|SALES|1250.00||JAMES|SALES|950.00|+--------+------------+---------+ ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:30","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"28、列出所有部门的详细信息和人数 selectd.deptno,d.dname,d.loc,count(e.ename)fromdeptdleftjoinempeone.deptno=d.deptnogroupbyd.deptno,d.dname,d.loc;+--------+------------+----------+----------------+ |deptno|dname|loc|count(e.ename)|+--------+------------+----------+----------------+ |10|ACCOUNTING|NEWYORK|3||20|RESEARCH|DALLAS|5||30|SALES|CHICAGO|6||40|OPERATIONS|BOSTON|0|+--------+------------+----------+----------------+ 小Tips: 在查询部门的数量的时候，一定要使用left join。因为只有dept表中使用了编号为40的部门，而emp表中没有。如果使用join是内连接（交集），就会丢失一个deptno=40的值。这里使用左外连接，leftjoin,取dept表的全集。 ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:31","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"29、列出各种工作的最低工资及从事此工作的雇员姓名 -- 求出工作的最低工资 selectjob,min(sal)asminsalfromempgroupbyjob;+-----------+---------+ |job|minsal|+-----------+---------+ |ANALYST|3000.00||CLERK|800.00||MANAGER|2450.00||PRESIDENT|5000.00||SALESMAN|1250.00|+-----------+---------+ -- emp与上表连接 selecte.ename,t.*fromempejoin(selectjob,min(sal)asminsalfromempgroupbyjob)tone.job=t.jobande.sal=t.minsal;+--------+-----------+---------+ |ename|job|minsal|+--------+-----------+---------+ |SMITH|CLERK|800.00||WARD|SALESMAN|1250.00||MARTIN|SALESMAN|1250.00||CLARK|MANAGER|2450.00||SCOTT|ANALYST|3000.00||KING|PRESIDENT|5000.00||FORD|ANALYST|3000.00|+--------+-----------+---------+ ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:32","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"30、列出各个部门的MANAGER(领导)的最低薪金 真坑啊，这里的MANAGER指的是工作岗位。。。 selectdeptno,min(sal)fromempwherejob='MANAGER'groupbydeptno;+--------+----------+ |deptno|min(sal)|+--------+----------+ |10|2450.00||20|2975.00||30|2850.00|+--------+----------+ ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:33","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"31、列出所有员工的年工资,按年薪从低到高排序 selectename,(sal+ifnull(comm,0))*12asyearsalfromemporderbyyearsalasc;+--------+----------+ |ename|yearsal|+--------+----------+ |SMITH|9600.00||JAMES|11400.00||ADAMS|13200.00||MILLER|15600.00||TURNER|18000.00||WARD|21000.00||ALLEN|22800.00||CLARK|29400.00||MARTIN|31800.00||BLAKE|34200.00||JONES|35700.00||SCOTT|36000.00||FORD|36000.00||KING|60000.00|+--------+----------+ ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:34","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"32、求出员工领导的薪水超过3000的员工名称与领导名称 selecta.enameas'ename',b.enameas'boss'fromempajoinempbona.mgr=b.empnowhereb.sal\u003e3000;+-------+------+ |ename|boss|+-------+------+ |JONES|KING||BLAKE|KING||CLARK|KING|+-------+------+ ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:35","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"33、求出部门名称中,带’S’字符的部门员工的工资合计、部门人数 selectd.deptno,d.ename,d.loc,count(e.ename),ifnull(sum(e.sal),0)fromemperightjoindeptdone.deptno=d.deptnowhered.dnamelike'%S%'groupbyd.deptno,d.dname,d.loc;+--------+------------+---------+----------------+----------------------+ |deptno|dname|loc|count(e.ename)|ifnull(sum(e.sal),0)|+--------+------------+---------+----------------+----------------------+ |20|RESEARCH|DALLAS|5|10875.00||30|SALES|CHICAGO|6|9400.00||40|OPERATIONS|BOSTON|0|0.00|+--------+------------+---------+----------------+----------------------+ ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:36","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["笔记"],"content":"34、给任职日期超过30年的员工加薪10% updateempsetsal=sal*1.1wheretimestampdiff(YEAR,hiredate,now()); Rows matched: 14 Changed: 14 Warnings: 0 ","date":"2021-10-17","objectID":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/:1:37","tags":["mysql"],"title":"34道MySql练习题","uri":"/34%E9%81%93mysql%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["Java"],"content":"Spring 5 ","date":"2021-09-26","objectID":"/%E4%BA%8C%E5%88%B7spring%E7%AC%94%E8%AE%B0/:1:0","tags":["java","note","Spring"],"title":"二刷Spring","uri":"/%E4%BA%8C%E5%88%B7spring%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"框架概述 Spring 是轻量级的开源的 JavaEE 框架 Spring 可以解决企业应用开发的复杂性 特点 方便解耦，简化开发 方便解耦，简化开发 方便程序测试 方便和其他框架进行整合 方便进行事务操作 降低 API 开发难度 核心：IOC，AOP IOC：控制反转，把创建对象过程交给 Spring 进行管理 Aop：面向切面，不修改源代码进行功能增强 ","date":"2021-09-26","objectID":"/%E4%BA%8C%E5%88%B7spring%E7%AC%94%E8%AE%B0/:1:1","tags":["java","note","Spring"],"title":"二刷Spring","uri":"/%E4%BA%8C%E5%88%B7spring%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"IOC概念和原理 什么是IOC 控制反转，把对象创建和对象之间的调用过程，交给 Spring 进行管理. 使用 IOC 目的：为了耦合度降低 IOC 底层原理 xml 解析、工厂模式、反射 IOC原理案例场景 我们现在试想一个场景，有两个类，分别是UserService,UserDao。 如今我们想在UserService中调用UserDao中的add方法，该怎么做呢。 原始方法 使用new关键字新建一个对象实例，这样实例中就可以使用add方法了。但耦合度太高。 工厂模式 使用工厂模式，把UserService,UserDao做到了解耦，但是却和UserFactory有了耦合度。 实际上，我们会发现不管怎么设计，都会存在一定的耦合度。因此，我们需要做的就是怎么把耦合度降到最低。 IOC模式（使用xml文件解析+反射） 第一步：创建xml配置文件，配置创建的对象 \u003cbean id=\"dao\" class=\"com.lone.UserDao\"\u003e\u003c/bean\u003e 第二步：有service类和dao类，创建工厂类，以下是用伪代码实现的过程 public class UserFactory { public static UserDao getDao(){ // 1.xml解析,得到class属性值即全路径+类名 String classvalue = class属性值; // 2.通过反射，newInstance方法创建对象 Class clazz = Class.forName(classvalue); return (UserDao) clazz.newInstance(); } } 我们会发现，这时候我们想要更改路径，只需要更改xml文件即可，对比前2种方法，进一步降低了耦合度。 IOC的一些接口 IOC 思想基于 IOC 容器完成，IOC 容器底层就是对象工厂。 Spring 提供 IOC 容器实现的两种方式： BeanFactory IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用。 加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象 ApplicationContext 是BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人 员进行使用。没错，这个就是我们经常在写测试类的时候使用的的那个接口。加载配置文件时候就会把在配置文件对象进行创建 ApplicationContext 接口的实现类 第一个是系统中的绝对路径读取bean.xml，第二个是相对路径（src下的路径） ","date":"2021-09-26","objectID":"/%E4%BA%8C%E5%88%B7spring%E7%AC%94%E8%AE%B0/:1:2","tags":["java","note","Spring"],"title":"二刷Spring","uri":"/%E4%BA%8C%E5%88%B7spring%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"IOC操作Bean管理 什么是Bean 管理？Bean 管理是指两个操作： Spring 创建对象（xml文件） Spirng 注入属性 Bean 管理操作 - 基于 xml 配置文件方式实现 基于 xml 方式创建对象 \u003c!--1 配置User对象创建--\u003e \u003cbean id=\"user\" class=\"com.lone.User\"\u003e\u003c/bean\u003e 在 spring 配置文件中，使用 bean 标签，标签里面添加对应属性，就可以实现对象创建 在 bean 标签有很多属性，介绍常用的属性 id 属性：唯一标识 class 属性：类全路径（包类路径） 创建对象时候，默认也是执行无参数构造方法完成对象创建 基于 xml 方式注入属性 DI：依赖注入，就是注入属性 第一种注入方式：使用 set 方法进行注入 创建类，定义属性和对应的 set 方法 /** * 演示使用set方法进行注入属性 */ public class Book { //创建属性 private String bname; private String bauthor; //创建属性对应的set方法 public void setBname(String bname) { this.bname = bname; } public void setBauthor(String bauthor) { this.bauthor = bauthor; } } 在 spring 配置文件配置对象创建，配置属性注入 \u003c!--2 set方法注入属性--\u003e \u003cbean id=\"book\" class=\"com.lone.Book\"\u003e \u003c!--使用property完成属性注入 name：类里面属性名称 value：向属性注入的值 --\u003e \u003cproperty name=\"bname\" value=\"Java\"\u003e\u003c/property\u003e \u003cproperty name=\"bauthor\" value=\"Vue\"\u003e\u003c/property\u003e \u003c/bean\u003e 第二种注入方式：使用有参数构造进行注入 创建类，定义属性，创建属性对应有参数构造方法 /** * 使用有参数构造注入 */ public class Orders { //属性 private String oname=\"\"; private String address; //有参数构造 public Orders(String oname,String address) { this.oname = oname; this.address = address; } public void ordersTest() { System.out.println(oname+\"::\"+address); } } 在 spring 配置文件中进行配置 \u003c!--3 有参数构造注入属性--\u003e \u003cbean id=\"orders\" class=\"com.lone.Orders\"\u003e \u003cconstructor-arg name=\"oname\" value=\"电脑\"\u003e\u003c/constructor-arg\u003e \u003cconstructor-arg name=\"address\" value=\"China\"\u003e\u003c/constructor-arg\u003e \u003c/bean\u003e 第三种注入方式：p 名称空间注入 使用 p 名称空间注入，可以简化基于 xml 配置方式 添加 p 名称空间在配置文件中 \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c/beans\u003e 进行属性注入，在 bean 标签里面进行操作 \u003cbean id=\"book\" class=\"com.lone.Book\" p:bname=\"Java\" p:bauthor=\"Lone\"\u003e\u003c/bean\u003e xml注入其他类型属性 字面量 \u003c!--null 值--\u003e \u003cproperty name=\"address\"\u003e \u003cnull/\u003e \u003c/property\u003e 属性值包含特殊符号 \u003c!--属性值包含特殊符号 1 把\u003c\u003e进行转义 \u0026lt; \u0026gt; 2 把带特殊符号内容写到 CDATA --\u003e \u003cproperty name=\"address\"\u003e \u003cvalue\u003e\u003c![CDATA[\u003c\u003c南京\u003e\u003e]]\u003e\u003c/value\u003e \u003c/property\u003e 注入属性 - 外部 bean 创建两个类 service 类和 dao 类 在 service 调用 dao 里面的方法 在 spring 配置文件中进行配置 == 代码部分 == UserService： public class UserService { //创建UserDao类型属性，生成set方法 private UserDao userDao; public void setUserDao(UserDao userDao) { this.userDao = userDao; } public void add() { System.out.println(\"service add...............\"); userDao.update(); } } UserDao: public interface UserDao { public void update(); } UserDaoImpl： public class UserDaoImpl implements UserDao { @Override public void update() { System.out.println(\"dao update...........\"); } } bean.xml: \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c!--1 service和dao对象创建--\u003e \u003cbean id=\"userService\" class=\"com.lone.service.UserService\"\u003e \u003c!--注入userDao对象 name属性：类里面属性名称 ref属性：创建userDao对象bean标签id值 --\u003e \u003cproperty name=\"userDao\" ref=\"userDaoImpl\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003cbean id=\"userDaoImpl\" class=\"com.lone.dao.UserDaoImpl\"\u003e\u003c/bean\u003e \u003c/beans\u003e 注入属性-内部 bean（举例） 一对多关系：部门和员工 一个部门有多个员工，一个员工属于一个部门，部门是一，员工是多 在实体类之间表示一对多关系，员工表示所属部门，使用对象类型属性进行表示 Dept.java //部门类 public class Dept { private String dname; public void setDname(String dname) { this.dname = dname; } @Override public String toString() { return \"Dept{\" + \"dname='\" + dname + '\\'' + '}'; } } Emp.java //员工类 public class Emp { private String ename; private String gender; //员工属于某一个部门，使用对象形式表示 private Dept dept; public void setDept(Dept dept) { this.dept = dept; } public void setEname(String ename) { this.ename = ename; } public void setGender(String gender) { this.gender = gender; } public void add() { System.out.println(ename+\"::\"+gender+\"::\"+dept); } } bean.xml（内部Bean） \u003c!--内部 bean--\u003e \u003cbean id=\"emp\" class=\"com.lone.bean.Emp\"\u003e \u003c!--设置两个普通属性--\u003e \u003cproperty name=\"ena","date":"2021-09-26","objectID":"/%E4%BA%8C%E5%88%B7spring%E7%AC%94%E8%AE%B0/:1:3","tags":["java","note","Spring"],"title":"二刷Spring","uri":"/%E4%BA%8C%E5%88%B7spring%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"SSM-框架整合全记录 此篇文章主要为了记录 SSM 框架的学习过程，方便以后查阅复习 ","date":"2021-07-26","objectID":"/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%85%A8%E8%AE%B0%E5%BD%95/:0:0","tags":["Java","SSM"],"title":"SSM-框架整合全记录","uri":"/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%85%A8%E8%AE%B0%E5%BD%95/"},{"categories":["Java"],"content":"关于SSM 顾名思义，Spring + SpringMVC +Mybatis 整合在一起就是SSM了。说到整合，那么不可避免的就是把他们三个框架综合在一起，使用 Spring 来管理所有的bean。下面我们通过一个小项目来详细记录过程。 ","date":"2021-07-26","objectID":"/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%85%A8%E8%AE%B0%E5%BD%95/:1:0","tags":["Java","SSM"],"title":"SSM-框架整合全记录","uri":"/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%85%A8%E8%AE%B0%E5%BD%95/"},{"categories":["Java"],"content":"数据库环境 使用MySQL： CREATEDATABASE`ssmbuild`;USE`ssmbuild`;DROPTABLEIFEXISTS`books`;CREATETABLE`books`(`bookID`INT(10)NOTNULLAUTO_INCREMENTCOMMENT'书id',`bookName`VARCHAR(100)NOTNULLCOMMENT'书名',`bookCounts`INT(11)NOTNULLCOMMENT'数量',`detail`VARCHAR(200)NOTNULLCOMMENT'描述',KEY`bookID`(`bookID`))ENGINE=INNODBDEFAULTCHARSET=utf8INSERTINTO`books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES(1,'Java',1,'从入门到放弃'),(2,'MySQL',10,'从删库到跑路'),(3,'Linux',5,'从进门到进牢'); ","date":"2021-07-26","objectID":"/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%85%A8%E8%AE%B0%E5%BD%95/:2:0","tags":["Java","SSM"],"title":"SSM-框架整合全记录","uri":"/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%85%A8%E8%AE%B0%E5%BD%95/"},{"categories":["Java"],"content":"基本环境搭建 ","date":"2021-07-26","objectID":"/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%85%A8%E8%AE%B0%E5%BD%95/:3:0","tags":["Java","SSM"],"title":"SSM-框架整合全记录","uri":"/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%85%A8%E8%AE%B0%E5%BD%95/"},{"categories":["Java"],"content":"一、新建一个Maven项目，并添加Web项目支持 ","date":"2021-07-26","objectID":"/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%85%A8%E8%AE%B0%E5%BD%95/:3:1","tags":["Java","SSM"],"title":"SSM-框架整合全记录","uri":"/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%85%A8%E8%AE%B0%E5%BD%95/"},{"categories":["Java"],"content":"二、导入相关的pom依赖 安装依赖包： \u003cdependencies\u003e \u003c!--Junit--\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003c/dependency\u003e \u003c!--数据库驱动--\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.47\u003c/version\u003e \u003c/dependency\u003e \u003c!-- 数据库连接池 --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.mchange\u003c/groupId\u003e \u003cartifactId\u003ec3p0\u003c/artifactId\u003e \u003cversion\u003e0.9.5.3\u003c/version\u003e \u003c/dependency\u003e \u003c!--Servlet - JSP --\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet\u003c/groupId\u003e \u003cartifactId\u003eservlet-api\u003c/artifactId\u003e \u003cversion\u003e2.5\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet.jsp\u003c/groupId\u003e \u003cartifactId\u003ejsp-api\u003c/artifactId\u003e \u003cversion\u003e2.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet\u003c/groupId\u003e \u003cartifactId\u003ejstl\u003c/artifactId\u003e \u003cversion\u003e1.2\u003c/version\u003e \u003c/dependency\u003e \u003c!--Mybatis--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring\u003c/artifactId\u003e \u003cversion\u003e2.0.2\u003c/version\u003e \u003c/dependency\u003e \u003c!--Spring--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.1.9.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.1.9.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003c!--AOP支持,后来没有用上--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.8.13\u003c/version\u003e \u003c/dependency\u003e \u003c!--偷懒，使用lombok--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.16.10\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 设置资源过滤器：很重要！ \u003c!--资源过滤器--\u003e \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resources\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e ","date":"2021-07-26","objectID":"/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%85%A8%E8%AE%B0%E5%BD%95/:3:2","tags":["Java","SSM"],"title":"SSM-框架整合全记录","uri":"/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%85%A8%E8%AE%B0%E5%BD%95/"},{"categories":["Java"],"content":"三、建立基本结构和配置框架 1、建立四层结构 把这四个包创建好，里面先不急着写东西 com.lone.pojo pojo层是对应的数据库表的实体类。 com.lone.dao Dao层主要是做数据持久层的工作，负责与数据库进行联络的一些任务都封装在此。Dao层的设计首先是设计Dao的接口，然后在Spring的配置文件中定义此接口的实现类，然后就可在模块中调用此接口来进行数据业务的处理，而不用关心此接口的具体实现类是哪个类，显得结构非常清晰，Dao层的数据源配置，以及有关数据库连接的参数都在Spring的配置文件中进行配置。 com.lone.service Service层主要负责业务模块的逻辑应用设计。同样是首先设计接口，再设计其实现的类，接着再Spring的配置文件中配置其实现的关联。这样我们就可以在应用中调用Service接口来进行业务处理。Service层的业务实现，具体要调用到已定义的Dao层的接口，封装Service层的业务逻辑有利于通用的业务逻辑的独立性和重复利用性，程序显得非常简洁。 com.lone.controller Controller层负责具体的业务模块流程的控制，在此层里面要调用Service层的接口来控制业务流程，控制的配置也同样是在Spring的配置文件里面进行，针对具体的业务流程，会有不同的控制器，我们具体的设计过程中可以将流程进行抽象归纳，设计出可以重复利用的子单元流程模块，这样不仅使程序结构变得清晰，也大大减少了代码量。 2、写配置文件 创建好mybatis和spring的配置文件，把基础内容写上 mybatis-config.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003c/configuration\u003e applicationContext.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c/beans\u003e 好，到目前为止，我们基本上算是完成了一个空白项目的雏形。 ","date":"2021-07-26","objectID":"/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%85%A8%E8%AE%B0%E5%BD%95/:3:3","tags":["Java","SSM"],"title":"SSM-框架整合全记录","uri":"/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%85%A8%E8%AE%B0%E5%BD%95/"},{"categories":["Java"],"content":"四、Mybatis层 1、创建数据库配置文件 database.properties jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=true\u0026useUnicode=true\u0026characterEncoding=utf8 jdbc.username=root jdbc.password=123456 在后面，我们会读取这个文件里数据库的连接配置 2、使用IDEA关联数据库 3、编写MyBatis的核心配置文件 mybatis-config.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003c!-- 配置数据源，交给Spring去做 --\u003e \u003ctypeAliases\u003e \u003cpackage name=\"com.lone.pojo\"/\u003e \u003c/typeAliases\u003e \u003c/configuration\u003e typeAliases : 类型别名。\u003ctypeAliases\u003e扫描实体类的包，它的默认别名就为这个类的 类名，首字母小写。 4、编写数据库对应的实体类 com.lone.pojo.Books： 使用lombok插件，简化实体类的有参无参构造等 package com.lone.pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @AllArgsConstructor @NoArgsConstructor public class Books { private int bookID; private String bookName; private int bookCounts; private String detail; } @AllArgsConstructor ：有参构造 @NoArgsConstructor : 无参构造 5、编写Dao层的接口（接口名一般为xxxMapper） 我们要实现增删改查功能，需要使用接口来实现这些方法，这样后面的类就可以重写这些方法，实现复用。接口不需要返回值 package com.lone.dao; import com.lone.pojo.Books; import org.apache.ibatis.annotations.Param; import java.util.List; public interface BookMapper { /* 这里实现的是一个BookMapper接口，里面定义了5个方法，传递的是不同类型的参数 由于增，删，更新数据库返回的是受影响的行数 所以可以使用int类型 查询一本书，返回的是对象，这个对象是books实体类，可见在写Mapper之前就要把实体类创建好 查询全部的书，使用的是列表，\u003cBooks\u003e代表泛型,意味着只有Books对象才能放入列表 */ //增加一本书 int addBook(Books books); //删除一本书,这里使用@Param注解，告诉BookMapper.xml传递一个参数，中SQL语句#{}直接使用 int deleteBookById(@Param(\"bookID\") int id); //更新一本书 int updateBook(Books books); //查询一本书 Books queryBookById(@Param(\"bookID\") int id); //查询全部的书 List\u003cBooks\u003e queryAllBook(); } 这里实现的是一个BookMapper接口，里面定义了5个方法。 传递的是不同类型的参数， 由于增，删，更新数据库返回的是受影响的行数 所以可以使用int类型 查询一本书，返回的是对象，这个对象是books实体类，（可见在写Mapper之前就要把实体类创建好） 查询全部的书，使用的是列表，\u003cBooks\u003e代表泛型,意味着只有Books对象才能放入列表 使用@Param注解，就能告诉BookMapper.xml传递的参数是谁，在参数多于一个的时候，必须要加上。 6、编写与接口对应的 Mapper.xml 文件 需要导入MyBatis的包 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003c!-- 一个mapper对应一个接口，所以每个mapper都需要一个namespace --\u003e \u003cmapper namespace=\"com.lone.dao.BookMapper\"\u003e \u003c!-- 每一个标签，对照接口里面的方法名，id为方法名，parameterType是传入的参数类型 最好写的时候，对照着接口写 --\u003e \u003cinsert id=\"addBook\" parameterType=\"Books\"\u003e /*这里不用添加主键，主键设置了自增，bookID会自己添加*/ insert into ssmbuild.books(bookName, bookCounts, detail) /*这个对应实体类中的字段*/ values (#{bookName},#{bookCounts},#{detail}); \u003c/insert\u003e \u003cdelete id=\"deleteBookById\" parameterType=\"int\"\u003e delete from ssmbuild.books where bookID = #{bookID} \u003c/delete\u003e \u003cupdate id=\"updateBook\" parameterType=\"Books\"\u003e update ssmbuild.books set bookName = #{bookName}, bookCounts = #{bookCounts}, detail = #{detail} where bookID = #{bookID} ; \u003c/update\u003e \u003cselect id=\"queryBookById\" resultType=\"Books\"\u003e select * from ssmbuild.books where bookID = #{bookID}; \u003c/select\u003e \u003cselect id=\"queryAllBook\" resultType=\"Books\"\u003e select * from ssmbuild.books; \u003c/select\u003e \u003c!--在这些写完之后，赶紧把mapper绑定到mybatis-config.xml配置文件中,称之为 注册 --\u003e \u003c/mapper\u003e 由于Mapper接口与这里.xml是一一对应的关系，所以写xml的时候，最好这两个对照着写。 mapper namespace=\"com.lone.dao.BookMapper\"进行绑定。 每一个标签，对照接口里面的方法名，id为方法名，parameterType是传入的参数类型。 在查询方法中，最常用的是resultType,其余则是parameterType。 SQL语句写完了，赶紧把这里的.xml文件绑定到资源目录下的mybatis-config.xml，于是配置文件就成了这个样子 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003c!-- 配置数据源，交给Spring去做 --\u003e \u003ctypeAliases\u003e \u003cpackage name=\"com.lone.pojo\"/\u003e \u003c/typeAliases\u003e \u003c!--两个名字一样，就使用class,不一样的使用resource--\u003e \u003cmappers\u003e \u003cmapper class=\"com.lone.dao.BookMapper\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e mappers：映射器，对我们刚在dao层写好的.xml文件进行绑定 有两种绑定方式： 【方式一】 \u003cmappers\u003e \u003cmapper resource=\"com/lone/dao/BookMapper.xml\"/\u003e \u003c/mappers\u003e 【方式二】 \u003cmappers\u003e \u003cmapper class=\"com.lone.dao.BookMapper\"/\u003e \u003c/mappers\u003e 使用方式一idea没有代码提示，使用方式二在接口和xml文件同名的情况下很方便。 7、编写Service层的接口和实现类 接口：与dao.BookMapper里的一样 package com.lone.service; import com.lone.pojo.Books; import org.apache.ib","date":"2021-07-26","objectID":"/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%85%A8%E8%AE%B0%E5%BD%95/:3:4","tags":["Java","SSM"],"title":"SSM-框架整合全记录","uri":"/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%85%A8%E8%AE%B0%E5%BD%95/"},{"categories":["Java"],"content":"五、Spring层 1、配置Spring整合MyBatis 我们这里数据源使用c3p0连接池 2、编写Spring整合Mybatis的相关的配置文件 spring-dao.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003c!-- 1、关联数据库配置文件 --\u003e \u003ccontext:property-placeholder location=\"classpath:database.properties\"/\u003e \u003c!-- 2、连接池 --\u003e \u003cbean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"\u003e \u003cproperty name=\"driverClass\" value=\"${jdbc.driver}\"/\u003e \u003cproperty name=\"jdbcUrl\" value=\"${jdbc.url}\"/\u003e \u003cproperty name=\"user\" value=\"${jdbc.username}\"/\u003e \u003cproperty name=\"password\" value=\"${jdbc.password}\"/\u003e \u003c!-- c3p0连接池的私有属性 --\u003e \u003cproperty name=\"maxPoolSize\" value=\"30\"/\u003e \u003cproperty name=\"minPoolSize\" value=\"10\"/\u003e \u003c!-- 关闭连接后不自动commit --\u003e \u003cproperty name=\"autoCommitOnClose\" value=\"false\"/\u003e \u003c!-- 获取连接超时时间 --\u003e \u003cproperty name=\"checkoutTimeout\" value=\"10000\"/\u003e \u003c!-- 当获取连接失败重试次数 --\u003e \u003cproperty name=\"acquireRetryAttempts\" value=\"2\"/\u003e \u003c/bean\u003e \u003c!-- 3、SQLSessionFactory --\u003e \u003cbean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003cproperty name=\"dataSource\" ref=\"dataSource\"/\u003e \u003cproperty name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/\u003e \u003c/bean\u003e \u003c!-- 4.配置dao接口的扫描包，动态的实现了Dao接口可以注入到Spring容器中 --\u003e \u003cbean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"\u003e \u003c!--注入 sqlSessionFactory --\u003e \u003cproperty name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/\u003e \u003c!--扫描Dao包--\u003e \u003cproperty name=\"basePackage\" value=\"com.lone.dao\"/\u003e \u003c/bean\u003e \u003c/beans\u003e 在spring-dao.xml文件中，关联数据库文件 =\u003e 连接池连接数据库配置 =\u003e SQLSessionFactory =\u003e 配置dao接口的扫描包，实现动态注入。 3、 Spring整合service层 4、编写Spring整合Mybatis的相关的配置文件 spring-service.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"\u003e \u003c!-- 1、扫描service下包里面的注解 --\u003e \u003ccontext:component-scan base-package=\"com.lone.service\"/\u003e \u003c!-- 2、将我们所有的业务类，注入到Spring，可以配置或者注解实现 --\u003e \u003cbean id=\"bookServiceImpl\" class=\"com.lone.service.BookServiceImpl\"\u003e \u003c!--[1]看底部注释--\u003e \u003cproperty name=\"bookMapper\" ref=\"bookMapper\"/\u003e \u003c/bean\u003e \u003c!--3、声明式事务配置--\u003e \u003cbean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"\u003e \u003c!--注入数据源--\u003e \u003cproperty name=\"dataSource\" ref=\"dataSource\"/\u003e \u003c/bean\u003e \u003c/beans\u003e 【注】 这里能使用ref=\"bookMapper\"引用是因为在spring-dao.xml中,配置了dao接口扫描包，会将dao下的接口自动注入到spring容器，并且引用名称默认是接口的首字母小写 但是前提是必须把applicationContext.xml，spring-dao.xml，spring-service.xml放在同一个ApplicationContext下，即idea自动帮你把几个spring的配置整合了，否则会爆红,还有几种方法则是使用import导入前面的配置文件： 【方法一】在此文件前面加上\u003cimport resource=\"classpath:spring-dao.xml\"/\u003e 【方法二】整合到applicationContext.xml 【方法三】使用注解@Service,@Autowired @Service public class BookServiceImpl implements BookService{ private BookMapper bookMapper; @Autowired public void setBookMapper(BookMapper bookMapper) { this.bookMapper = bookMapper; } 5、整合几个Spring配置到一个applicationContext.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/sc","date":"2021-07-26","objectID":"/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%85%A8%E8%AE%B0%E5%BD%95/:3:5","tags":["Java","SSM"],"title":"SSM-框架整合全记录","uri":"/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%85%A8%E8%AE%B0%E5%BD%95/"},{"categories":["Vue笔记"],"content":"Vue学习笔记 没有一蹴而就的辉煌，只有默不作声的努力。 ","date":"2021-07-20","objectID":"/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["Vue"],"title":"Vue学习笔记","uri":"/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Vue笔记"],"content":"使用 Vue CLI 安装Vue CLI 官网地址 ：https://cli.vuejs.org/zh/ 命令行安装(-g代表全局模式) npm install -g @vue/cli 使用命令行不加版本号的话表示使用的最新版（目前最新的就是4.5.13） 新建项目 有两种方式： 也支持 CLI2 的创建 vue init webpack my-project 从 CLI3 开始，提供了一种可视化的部署方式，操作很简单，不详细介绍。 vue ui 使用命令行 vue create hello-world 这样可以创建一个空白的项目文件，后面需要用到的可以随时添加。 目录结构大概就长这个样子，很清晰，main.js是入口文件，components是自定义的组件，App.vue是项目的主组件，package.json依赖的包环境，public为静态资源。 ","date":"2021-07-20","objectID":"/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":["Vue"],"title":"Vue学习笔记","uri":"/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Vue笔记"],"content":"关于App.vue的一些理解 App.vue可以当做网站的首页，是一个vue项目的主组件，页面的入口文件，所有的页面都是在App.vue下进行切换的。是整个项目的关键，app.vue负责构建定义及页面组件归集。 App.vue作为主组件在main.js中被使用 import Vue from 'Vue' import App from './App.vue' Vue.config.productionTip = false new Vue({ render: h =\u003e h(App) }).$mount('#app') 如果把箭头函数和mount按原来的写法是这样的 new Vue({ el: '#app' render: function(h){ return h(App) } }) //.$mount('#app')的作用等同于el: '#app' 这两者的效果等同。 在VueCLI 2.x版本中，使用的一般都是runtime-compiler，而3.x 以后使用的都是untime-only。这两者是有区别的，后者相对更加轻巧，因为省略了templated到ast的步骤，直接使用render到virdom到UI。随着技术的迭代，后者使用的也更多。上面的例子都是后者的写法，下面示例一个前者的写法： new Vue({ el: '#app', template: '\u003cApp/\u003e', components: {APP} }) 主组件app.vue中调用其他组件，构建页面 \u003ctemplate\u003e \u003cdiv id=\"app\"\u003e \u003cMyTest/\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e //导入其他组件 import MyTest from './components/MyTest.vue' export default { name: 'App', components: { MyTest } } \u003c/script\u003e \u003cstyle\u003e \u003c/style\u003e ","date":"2021-07-20","objectID":"/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:2","tags":["Vue"],"title":"Vue学习笔记","uri":"/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Vue笔记"],"content":"vue-router的配置 前提：如何实现前端路由： URL的hash：更改hash值，在不刷新页面的情况下改变url。（location.hash） HTML5的history模式：pushState。（使用的是栈结构，先进后出）即压栈操作，栈顶显示的永远是最新的url。 back()弹栈一层。go()可弹栈多层。 history.back() \u003c==\u003e history.go(-1) history.forward \u003c==\u003e history.go(1) HTML5的replace模式：replaceState。没有回退记录，直接进行替换 1、安装vue-router 插件 npm install vue-router --save 导入路由对象，并且调用Vue.use(VueRouter) 在router/index.js中： import VueRouter from \"vue-router\"; //1、通过Vue.use(插件)，安装插件【使用任何的插件的时候，都需要使用Vue.use】 Vue.use(VueRouter) Tips:对于所有的插件安装，都必须使用 Vue.use() 来注册 2、创建路由实例，并且传入路由映射配置 在router/index.js中： //2、创建路由(VueRouter)对象,一个映射就是一个对象 const routes = [ { path: '/home', //路径 component: Home //组件 这些东西不能是null ,需要组件，但是组件获取不到，需要import导入 }, { path: '/about', component: About }, ] const router = new VueRouter({ // 配置路由和组件之间的应用关系 // routes: [] 我们可以把这数组写到前面，通过引用取值(es6写法)。 routes }) 3、在Vue实例中挂载创建的路由实例 在router/index.js中：我们首先要把router导出 export default router 然后在main.js中，导入router import router from './router' 在main.js中，挂载到Vue实例中 new Vue({ router, //把router对象传入Vue实例，但是拿不到，所以在index文件里面需要导出，在main.js中导入 render: function (h) { return h(App) } }).$mount('#app') 4、总结vue-router 的配置方式 就是router/index.js与main.js之间的导入导出与使用。 完整代码： router/index.js： import VueRouter from \"vue-router\"; import Vue from \"vue\"; import Home from '../components/Home'; import About from '../components/About'; //1、通过Vue.use(插件)，安装插件【使用任何的插件的时候，都需要使用Vue.use】 Vue.use(VueRouter) //2、创建路由(VueRouter)对象,一个映射就是一个对象 const routes = [ { path: '/home', //路径 component: Home //组件 这些东西不能是null ,需要组件，但是组件获取不到，需要import导入 }, { path: '/about', component: About }, ] const router = new VueRouter({ // 配置路由和组件之间的应用关系 // routes: [] 我们可以把这数组写到前面，通过引用取值(es6写法)。 routes }) //3、将router对象传入Vue实例，放入main.js中【导出】 export default router main.js import Vue from 'vue' import App from './App.vue' import router from './router' // 如果导入的文件在一个目录中，且里面只有一个index文件，那么可以不用跟后面的东西，省略 Vue.config.productionTip = false new Vue({ router, //把router对象传入Vue实例，但是拿不到，所以在index文件里面需要导出，在main.js中导入 render: function (h) { return h(App) } }).$mount('#app') ","date":"2021-07-20","objectID":"/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:3","tags":["Vue"],"title":"Vue学习笔记","uri":"/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Vue笔记"],"content":"使用vue-router 创建路由组件 首先把App.vue里面不要的删除，把components目录下的组件也删除。弄一个空白的项目文件。 在components目录下创建几个组件。 配置路由映射，组件和路径的映射关系 在router/index.js中： 使用路由，通过\u003crouter-link\u003e和\u003crouter-view\u003e 组件在App.vue中使用 \u003crouter-link\u003e会被渲染成\u003ca\u003e标签 \u003crouter-view\u003e会根据当前的路径，动态渲染不同的组件 在路由切换时，切换的是\u003crouter-view\u003e挂载的组件，其他内容不会发生变化 小细节：设置路由的默认路径 小细节：修改为history模式 只需要在router/index.js中，创建路由的地方，添加一个mode属性。 router-link的其他属性 使用代码方式实现路由跳转 this.$router.push('/home') //栈跳转，可以进退 this.$router.replace('/home')//不可进退 ","date":"2021-07-20","objectID":"/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:4","tags":["Vue"],"title":"Vue学习笔记","uri":"/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["随笔"],"content":" 2021\u00267月 每一段旅途都会有终点。 ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:1:0","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 7.2 \r","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:1:1","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 7.3 仰望天空的时候，你也会想起我吗？ 放假前在学校拍的最后一次夕阳 ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:1:2","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 7.18 打工人的第一个周末。有些事情，只要你想，就能！ ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:1:3","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 7.26 微风舒适，雨后微凉 ….. 骑车在路上，晚霞真漂亮（没来得及拍下来，有点可惜） ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:1:4","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 2021\u00268月 爱意随风起，风止意难平 ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:2:0","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 8.6 我们都被生活所迫，我们都不想被生活所迫。 即使距离遥远，时光平淡，还是会有些人，有些话，给你带来莫名的力量。 与君共勉，加油！ 途中... ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:2:1","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 8.10 刚下过雨，地面湿润，空气里弥漫着淡淡的雾气，远处灯火摇曳渐渐模糊，恍惚中似乎又进入龙族的那个世界 ……… 路明非又蹲在某个报亭的角落里避着雨偷看文学杂志，楚子航打着伞，面无表情的站在路口等待着红绿灯，诺诺开着一辆火红的法拉利从马路上飞驰，溅起大量的水花……同样的一个南方小城，雨夜，高楼CBD，公路，似乎都能与他们在人潮中来一场跨越时空的偶遇。 ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:2:2","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 8.14 七月初七 · 天气阴  昨天晚上阿超贼兮兮的问，“明天准备怎么过啊”  “跟我有关系吗？真的是…. 你不也一样… ”，打着伞走在路上，我抬脚迈过水坑，漫不经心地说着。  电话那头沉默了一下，我们都很明智的没再在这个话题上继续。  想来有点好笑，大学校园里，20出头的年纪总是张扬肆意，什么都不懂却又仿佛焦虑丛生。  可能是聚餐喝了一点酒的缘故，某天晚上回宿舍后几个人趴在阳台上吹风，盯着极远处明暗不定的灯火，不知道在想些什么。  黑暗里不知道是谁发出了一声感叹，”小T，有过遗憾吗 ”  “嗯…” ，见我没有说下去的打算，都没继续追问，几个人只是看着我，一时间都不知道该怎么宽慰。  ”哎，其实咱宿舍只有我一个菜鸡啊，你们都是有故事的人“，大龙看看四周，努力缓解着难名的情绪。小白拍了拍我的肩，“如果还是放不下的话，就再试一次吧。”，“大多数时候，心里其实已经有打算了，只是缺少一个让外界说服自己的理由而已”。“是啊是啊…..”  在他们的怂恿下，我忐忑着给她发送了一条信息，一条时隔半年的信息。  他们凑到我的手机跟前，一起期待着什么，很久以后，表情明显的失落。  就突然明白，她的世界已经不需要我了。  这是预料之中的结果，谈不上有多难受，也似乎没有多少涟漪。却莫名的鼻子一酸，抬头，难得有那么多的星星，真亮。  “喝酒喝酒，别想那些没用的….”，阿鹏看不下去了，骂骂咧咧的回屋里拆出几罐啤酒，拉开拉环，递给我们。  我烦躁的点亮手机，杂乱滑动着屏幕，他们的声音渐渐离我远去，回忆像潮水一样快速涌出。  何时闯入我心里的呢？大概是从大一学生会一次活动结束，那个憨憨在QQ上小心翼翼的开始，“能问你一个事情吗” ，“嗯”，“那个…那个…你有女朋友或者喜欢的人嘛” ，我错愕着不知道该怎么回答，见我半天没用反应，她忍不住，“啊，我帮我一个朋友问的”…… 大概是在之后几天的一个晚上，室友突然一脸八卦的给我看学校的QQ表白墙上，赫然有这样一句话，“xxx，我喜欢你，我一定会追到你的”，下面的评论一堆凑热闹的朋友@我。  平凡度过的18年的人生里，第一次有人大张旗鼓的宣布着我的名字。我傻了，彻夜难眠，激动，紧张，兴奋纷至沓来。于是一个多月以后，2018年11月23日，沦陷到了爱情的长河。  有次很严重的争吵，她生气了不说话，半天也哄不好。在我不知所措的时候，她转过身狠狠在我胸口锤了几拳，我慌乱的一把抱住，挣扎片刻，她的眼泪崩不住了，带着哭腔，委屈，靠在我身上恨恨的看着我，“你还惹不惹我生气了”。“乖~不哭了哈，我错了嘛”，我摸着她的脑袋轻轻说。她红红的眼睛盯着我，见我态度陈恳，气消了一半，像一只黏人的小猫咪一样，哼哼唧唧着把脸上不争气的泪痕往我衣服上面蹭，见我故意嫌弃的眼神，还不解气，使劲的掐着我的腰。我紧紧的搂着她，心疼又窃喜。  终不抵岁月漫长，2020年9月28日。结束了675天的恋情。没有小说电影里的那些离奇的狗血剧情，更不是其它奇奇怪怪的原因。不同于以往的吵架，互删之后再也没有联系过，也没通过谁联系过谁。后来在校园里某个角落，彼此视线交错过一瞬，就擦肩而过，那一瞬间依旧惊艳动人。  别纠缠，不回头，不联系，是她曾经对我说过的，对待爱情的态度。如今，她确实做到了。  抱歉，我还是没能忍住。  或许是酒精的缘故，话夹子被打开，那天晚上我们在宿舍里破天荒的聊到了夜里2点多，关于自己，关于未来。  似乎在某些话题上，每个人都有着自己的故事。  我们自己饱含热泪的收场，在却别人的故事里得到慰藉。  互删，拉黑，狠心断联，或许这才是一段感情里最好的落幕。  落幕，亦或不是一种开始？最严重的时候，一旦闲下来，就会想起那个身影，遗憾与思念交织的痛苦让我神经质的去各个软件寻找她零散的动态，哪怕只有几个字的信息。去K歌主页查看她新发布的歌曲和几句话的简介，开始给自己洗脑歌曲的含义，寻找可能和好的蛛丝马迹。晚上躺在床上，听着旋律的静静流淌，熟悉而又陌生的声线，忽然就懂了\"初闻不识曲中意，再听已是曲中人\"的滋味，心里涌起的巨大悲伤仿佛潮水一样把我淹没，压得喘不过气，想大哭一场，可内心的抑郁像一堵墙，堵死了末路，怎么都流不出一滴眼泪。  她一直是一个敢爱敢恨的女孩子。可以肯定的是，她的难过不会比我的更少。只是我已经没办法再去接近她的生活了…..  时隔320天，又是一年七夕到了。  不知为何这几天的梦里总会有她的身影。  不愿被人看贬。舍不得思绪，断不了情愁。  我对得起我曾经对你的爱，你也对的起你曾经对我的爱。  既然这样，不去打扰，  才是最后的骄傲。 ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:2:3","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 8.20 阴-雷阵雨，周五。 在大学校园里浑浑噩噩的日子太久了，不懂的地方太多，实习的感觉很痛苦，每天大量的bug和需求充斥着我的脑海，依旧做不来。 似乎只有每天的下班途中，才是我一天里最放松的时刻，我可以什么都不用想，骑着单车慢悠悠的驾向地铁站，轻易的在错过高峰时刻的车厢里找到一个座位。 发呆时想象自己是一个初来这方世界的看客，在车水马龙的人潮中，观察着每个人的匆匆形色….突然想到以前很羡慕住在高层的人们，每当晚时，坐看远方灯火阑珊，人间的烟火与气息似乎就尽在眼底了 某天拍的一朵云 ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:2:4","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 2021\u00269月 缅怀一段过去，活在一段故事里….. ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:3:0","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 9.5 4号下午到的学校，今天是在学校的第二天。还有2个多月就要实习，大学生活即将成为过去。加油！ ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:3:1","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 9.9 农历初三，星期四，天气晴。 中午遇见了她。都没有说话，或许有那么一瞬间的对视？然后继续静静的走过 … 时间果然是一个残酷的东西，它能把一段美好淡忘，也能让人再也无法激起那种波澜。 我们都会有一个美好的未来，不必勉强，也不必遗憾。 ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:3:2","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 9.10 今天是教师节。这是我人生中第一次送花，从未到是给辅导员的。其实我一直不太会欣赏这些东西，感觉不就一束花嘛，又没啥用，放不了几天就枯了。那种眼神掩饰不了流露出来的感动和惊喜让我猛然意识到，似乎女孩子都是喜欢花的。我以前一直未曾考虑过这些问题，是我太傻了吧，跟前女友谈恋爱的时候从未给她送过花，因为是会觉得站在楼下等着，那么多人，傻傻的，好尴尬啊。 今天路上走着，突然有种明悟，恋爱中的两个人，送花并不仅仅是花本身，而是它所承载的情感和意义。即使我在汹涌的人潮里逆行，也怀有坚定爱你的决心，与你在一起一往无前的勇气。站在人潮中捧着一束花的等待，是最极致的浪漫。 这些细节中流露的情感，才是女孩子所谓的安全感，与信任吧。 所以，如果以后你有一个喜欢的女孩子，而她也喜欢你。那么就请你足够珍惜，足够相信，且足够坚定。 ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:3:3","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 9.13 晚风依旧很温柔 ❤️ 夕阳下中的图书馆广场 落日真好看，就是手机像素太拉了 ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:3:4","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 9.24 盯着来来回回改了好久的告别信息发出，最后得到几句冰冷的回复和不屑的嘲讽。 仅仅想跟你好好的道个别。 并没有多难过，呵呵。真TM掉价啊，土的掉渣。就这样吧，再也别见。 没有必要，也不想再说什么气话与狠话，后来想想对你也生不起来气，跟好朋友聊天聊到前任的时候嘴角还是会微微上扬。就这样吧，挺好。 ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:3:5","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 2021\u002610月 不念过往，不惧将来 ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:4:0","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 10.7 从中秋放假之后开始，丝毫提不起任何的兴趣和动力，每天浑浑噩噩，学不进任何东西。国庆期间只在家呆了三天就急着回学校了，继续放纵自己的肆意和懒惰，又回归到了自己以前最讨厌的日子。我知道这种状态很不对，但是似乎就是没有动力去改变它，今天下午终于逼迫着自己专注着学习，去努力做一件事。越看越感觉到焦虑和迷茫….. 最后感谢韩顺平老师的那句话 “ 我亦无他，唯手熟尔 ”，不知道为什么突然就有点热泪盈眶。谢谢鼓励。 ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:4:1","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 10.11 昨天刷知乎，无意间看到一篇讲星座的文章。鬼使神差的点进去了，之后大受震撼，感觉自己就像被别从上到下从里到外的剖析了一遍。啧啧称奇，最离谱的是还很准，甚至有些是我自己以前不知道该怎么描述的感受。再看下前女友的，绝了….. 怪不得女孩子那么喜欢研究这玩意。想想以前好像有个一起兼职的女孩子听她聊过星座，还说巨蟹不太招女孩子喜欢什么什么的，因为本身不信嘛所以也就没在意。今天继续看知乎，发现这是一个很悲催的星座，评论里的女孩子起码10个里面9个半都是来黑的。哎，不听不听王八念经，始终坚信，我等的人终究会来。 ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:4:2","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 10.20 一直知道自己的文笔并不好，但有的时候仍然想写点东西。什么都行，不在乎与表达了什么，只是想要通过词不达意的文字来发泄一下情绪。这些点滴文章就像是一个个隐藏在互联网角落里的树洞，安安静静的躲在那里，不起眼，也不与谁较劲。在这个快节奏也临近最后的尾声的校园时代，写写日记似乎成为一种难得的奢侈，看看别人的文字就像翻开了一本未知的书，我认为它很有趣，就会想了解它的作者，它的事迹。同在红尘，却在另一方世界。就像某天在知乎上看到的\"我不曾经历过这些，所以我希望你能代替我去感受那个世界\"。 ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:4:3","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 10.22 开启心流模式，我就能无敌！ 从17号开始做的mysql复习题终于完成，完结撒花！ ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:4:4","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 10.31 时间过得真快啊，都到10月的最后一天了。这个月总感觉活在梦里，发生了好多的事。 准备好久的信息学竞赛的视频与程序落选。 上学期花了近一个多月的小论文没有通过。 补助在最后一关被刷。 国庆放假回来除了我以外的室友全部脱单。 有的时候听着喜欢的音乐，看着B站的视频，会突然的失落，烦躁，失眠 …. 看上了好久的卫衣买回来贼丑，后来退了。 加了一个java的学习群，里面人少，但都在共同进步。 开始对程序有那么点感觉了，不再是那么枯燥。 跟室友一起在一个午后去了学校后面大堰湖，沿着湖边骑车兜风看日落，拍了很多照片。 晚上八个人一起去吃饭的地方恰恰是我们大一一起去的那个包间， 聊到当时搞我，在电话里还差点把刚谈的女朋友吓哭的情景。 真时隔三年，再次来到这里，那一幅幅画面依旧历历在目，感觉真奇妙… 月底，室友的跟对象莫名其妙的一个个都接近凉了的边缘 … 然后发现夜聊最多的话题就是情伤，现在我们每个人都有自己的故事了… 似乎我们都不曾后悔过在最好的年华遇到的那个她。 2021年还有最后两个月了，一切加油，万事皆顺，家人朋友身体健康！ 对了，今天是万圣节，节日快乐！ ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:4:5","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 2021\u002611月 ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:5:0","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 11.8 星期一 · 晴 下午5点37分的落霞与夜色 -- 金星合月 ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:5:1","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 11.10 跟室友一起拍的毕业照，还有两个不是一个专业的，所以没有一起拍。 一起拍的毕业照，毕业啦~ 时间过得真快，转眼就过去了好多年。 前程似锦，一帆风顺！ ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:5:2","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 11.20 星期六 · 阴转小雨 晚上跟室友还有小白对象一起去外面干饭，聊到以前大一军训时候的相互拍的几张丑照与糗事，哈哈大笑。发现初入校园的我们好稚嫩啊，当时我连胡子都还没有刮，甚至理了一个被室友笑了四年的\"黑豹\"发型 ….. 从小学到高中我一直没有住过宿舍，那些宿舍里的奇闻趣事，都是在电影抖音里的道听途说。幸运的是，进入大学的校门，就能遇到这些有趣的灵魂，各有各的特色，也都各有各的故事，不矫情，也不复杂。遇见他们，真好！ 晚上吃完饭回来之后，没事可做，随手翻开了相册，放上几张以前感觉拍的不错的照片： 10.11 - 18:28 10.12 - 17:52 ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:5:3","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["随笔"],"content":" 11.21 星期日 · 小雨转阴 今天气温骤降，添了一件加绒的卫衣，暖和多了… 下午做了一件很愚蠢的事情。要去实习，所以把一些常用衣物寄回家，结果过了几个小时之后才发现收货地址填成学校了。。。离谱的是竟然还发货了。 晚上写写程序，发现程序之间有好多的共通之处，感觉程序这个东西也挺有意思，有好多好玩的事情想要去做，去学。准备单独弄个页面，记录一下回去之后的学习状态。 ","date":"2021-07-08","objectID":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/:5:4","tags":["essay"],"title":"碎碎念","uri":"/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"categories":["微信小程序"],"content":"微信小程序解包+反编译方法 ","date":"2021-07-07","objectID":"/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%A7%A3%E5%8C%85-%E5%8F%8D%E7%BC%96%E8%AF%91%E6%96%B9%E6%B3%95/:0:0","tags":["微信小程序"],"title":"微信小程序解包+反编译方法","uri":"/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%A7%A3%E5%8C%85-%E5%8F%8D%E7%BC%96%E8%AF%91%E6%96%B9%E6%B3%95/"},{"categories":["微信小程序"],"content":"微信小程序解包+反编译方法 ","date":"2021-07-07","objectID":"/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%A7%A3%E5%8C%85-%E5%8F%8D%E7%BC%96%E8%AF%91%E6%96%B9%E6%B3%95/:1:0","tags":["微信小程序"],"title":"微信小程序解包+反编译方法","uri":"/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%A7%A3%E5%8C%85-%E5%8F%8D%E7%BC%96%E8%AF%91%E6%96%B9%E6%B3%95/"},{"categories":["微信小程序"],"content":"准备工作 1、微信电脑版（建议最新版） 2、Node.js环境 3、小程序程序包解密工具 4、反编译脚本 小程序程序包解密工具+反编译脚本： 工具来源于吾爱破解论坛 1、安装Node.js环境 Node.js下载：https://nodejs.org/zh-cn/ 2、登录微信电脑版，运行你想要反编译的小程序，每个页面都点一下，确保所有页面的加载。完成后，找到你的微信文件储存目录。 找到Applet这个目录，里面找到你刚才打开的小程序的appid就是对应的加密程序包了 3、解密。打开解密工具，选择刚才找到的加密包目录，导入解密工具进行解密，解密后就得到wxapkg程序包了 4、将wxapkg程序包复制到反编译脚本目录wxappUnpacker-master里面，用cmd工具cd到wxappUnpacker-master目录，依次安装以下依赖 npm install esprima npm install css-tree npm install cssbeautify npm install vm2 npm install uglify-es npm install js-beautify 所有依赖安装完，即可开始反编译。 5、反编译。运行反编译命令，即 node wuWxapkg.js 解密程序包 node wuWxapkg.js wxe1577ebe280af504.wxapkg 6、反编译成功就会在同一目录下生成当前反编译的小程序appid的目录 反编译后的wxml、wxss、json基本都是跟之前你写的一模一样，但是js会有少量地方被其他字符串替代了，例如true用!1，false用!0等替代了，基本可以自己手动改改就可以，不改也不影响。 ","date":"2021-07-07","objectID":"/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%A7%A3%E5%8C%85-%E5%8F%8D%E7%BC%96%E8%AF%91%E6%96%B9%E6%B3%95/:1:1","tags":["微信小程序"],"title":"微信小程序解包+反编译方法","uri":"/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%A7%A3%E5%8C%85-%E5%8F%8D%E7%BC%96%E8%AF%91%E6%96%B9%E6%B3%95/"},{"categories":["python笔记"],"content":"json库的使用 ","date":"2021-07-06","objectID":"/json%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/:0:0","tags":["python"],"title":"json库的使用","uri":"/json%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["python笔记"],"content":"JSON与字典的转换 dumps( )方法 ==\u003e 将字典转化为 json字符串 loads( )方法 ==\u003e 将json字符串转为字典 json与python中的字典颇为相似。 但是底层的序列化格式不同。 json打印出来的类型是字符串\u003cclass 'str'\u003e类型 而字典类型则是\u003cclass 'dict'\u003e。 且通过jumps方法把字典转换为字符串之后，进行了unicode转码。 使用loads方法时，属性名必须使用双引号。 使用dumps方法时,属性名是否是双引号不影响 import json # 这是一个字符串 loads() ==\u003e 将字符串转化为字典 data = '{\"data\":\"张三\",\"age\":18}' d1 = json.loads(data) print(d1) # {'data': '张三', 'age': 18} # 这也是一个字符串 loads() ==\u003e 将字符串转化为字典 # 想要转换为字典，那么属性名必须是双引号 data2 = \"{'data': '张三', 'age': 18}\" d2 = json.loads(data2) print(d2) # 报错：Expecting property name enclosed in double quotes: line 1 column 2 (char 1)原因是没有用双引号 # dumps() ==\u003e 将字典类型转换为json,属性名是否是双引号不影响 data3 = {\"data\": \"张三\", \"age\": 18} # type(data3)结果是\u003cclass 'dict'\u003e，字典类型 d2 = json.dumps(data3) print(type(d2)) # \u003cclass 'str'\u003e 结果是json格式 打印结果为：{\"data\": \"\\u5f20\\u4e09\", \"age\": 18} ","date":"2021-07-06","objectID":"/json%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/:0:1","tags":["python"],"title":"json库的使用","uri":"/json%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["python笔记"],"content":"JSON文件读写 dump( )方法 ==\u003e 写入json load( )方法 ==\u003e 读取json import json data = {'name':'张三','age':18} with open(\"write.json\",\"w\",encoding=\"utf-8\")as f: json.dump(data,f,ensure_ascii=False) # {\"name\": \"张三\", \"age\": 18} with open (\"write.json\",\"r\",encoding=\"utf-8\")as f: data = json.load(f) print(data) # {'name': '张三', 'age': 18} ","date":"2021-07-06","objectID":"/json%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/:0:2","tags":["python"],"title":"json库的使用","uri":"/json%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["录·序章"],"content":" 仿佛从来没有这么热的夏天。  只是在房间里静静地坐着，都能感觉到从四周不断涌来的热浪，电风扇在不知疲倦地转着，却仍然没有带来一点凉意。  而这个时候，往往需要从冰箱里拿出一罐冰啤酒。拉开拉环，随着噗嗤的一声，回忆便会在脑海中快速涌现出来。  我问杰，为什么好多的回忆都是停留在过去的某个夏天。他往烟灰缸里弹了弹烟灰，似乎是真的在认真思考一样，然后回了我：“物理老师说过，温度越高，分子运动越激烈。”说罢便哈哈大笑起来，冷笑话也不能给才到六月的该死的天气降降温。  我认真想过这个问题。即使非常寒冷，我住的城市也从不下雪，每年冬天经历过的事，道过的别，都像是被放进了冰箱冷冻起来，你可能很少去看，但是拉开柜子的时候它依然在那，一点也没变。相反的是，夏天往往会带给我无数的烙印，它炙热但是不属于温暖，即使遮遮掩掩，也总会在某个时候看见它。  像是村上春树写的那样，整个夏天喝掉的啤酒可以灌满一整个游泳池。每年夏天我都会找杰或者鼠喝酒，不是为了逃避什么，也不是为了刻意去维持关系，只是纯粹的把它看作是一种活动。我在杰的朋友圈放出大话，说他还欠我一箱啤酒，而每次聚在一起喝酒的时候都是我最先投降。那些在酒杯里冒着白色泡沫的啤酒，在喧闹得听不见小声说话的火锅店，在我们红着脸笑容满面地看着对方的时候，一杯接一杯消失殆尽。偶尔我们也会换场，吃完火锅去唱歌，在KTV里一边喝一边唱，深夜回家的路上再去买一点烧烤喝啤酒，回到家里再接着喝。  庆幸的是我们都没那么矫情，从来没有人在喝多了之后给谁打电话，只是坐在阳台静静地吹着晚风。不像大学毕业那年，凌晨四点的时候，槟哥哥、小马和我挤在一个小小的床上，开着17度的空调。槟哥哥想给她打电话，我和小马怂恿他，然后他真的拨通了。 “初恋”最开始有点不耐烦，但是也没挂电话，槟哥哥跟她聊了很多，他好像有些委屈地说：“你不管我了么，以前都是你帮我做决定的。你帮我选了这个专业，我读完了。”在伸手不见五指的夜色里，我们静静听着，也不知道槟哥哥那时候有没有悄悄抹眼泪。  那个时候，我想保持对这个世界的太多热爱和向往，可是那些虚幻的东西伴随着每一次的脱离，变成泥潭，拽着我一点点往下掉，我绝望地挣扎，没有人救我，我也救不了自己。  回想起经历过的好几次毕业，从初中到高中，到大学，到今年第一年看着他们毕业。每一次毕业都没能好好去和他们告别，就像那年站在火锅店外面的楼梯上，我说，让我抱抱你吧。最终想说的什么也没说出来。今年也是一样，我曾很多次设想到时候我会说些什么，做些什么，但越是真诚的想要表达些什么的时候，越是会词不达意，所以最后只得仓促地在黑板上写下“不念过往，不畏将来”。  这是我很多年前看到过的一句话，但是我第一次写出来。杰问我有没有什么遗憾，我说我唯一的遗憾就是当时没多留一点时间，把这几个字认认真真地写一遍。  这就是今年的夏天，才刚刚开始就仿佛已是盛夏。在凌晨两点半的时候我仍然睡不着觉，趴在阳台的栏杆上，外面没有一点风，远处的灯光像是凝固了一样，四周也没有一点声响。  鼠把T恤脱掉，露出光滑的大肚皮，他问我，为什么不开空调呢？  可能这就是我们喜欢做的事，在冬天开烤火器，在夏天开空调，却很少真正去享受我们本来拥有的年华。 本文非原创，原作者 W4J1e 大佬，看过之后很受触动，特此转载！ ","date":"2021-06-30","objectID":"/%E4%B8%8D%E5%BF%B5%E8%BF%87%E5%BE%80%E4%B8%8D%E7%95%8F%E5%B0%86%E6%9D%A5/:0:0","tags":["转载"],"title":"不念过往，不畏将来 (转载)","uri":"/%E4%B8%8D%E5%BF%B5%E8%BF%87%E5%BE%80%E4%B8%8D%E7%95%8F%E5%B0%86%E6%9D%A5/"},{"categories":["Hugo-LoveIt"],"content":"写在前面 注意\r\r本文章转载于 八荒山人的博客 。本博客采用的 Twikoo 评论系统的 Hugo 兼容方案也源自于大佬的文章。 以及Hugo编译不了的问题解决方案。下载 Hugo-extend 成功解决！非常感谢！\r\r ","date":"2021-06-27","objectID":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/:1:0","tags":["Hugo-LoveIt"],"title":"Hugo+Loveit优化记(转载)","uri":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/"},{"categories":["Hugo-LoveIt"],"content":"本地调试时加载评论系统 使用 hugo server ,会得到终端的提示： Current environment is \"development\". The \"comment system\", \"CDN\" and \"fingerprint\" will be disabled. 当前运行环境是 \"development\". \"评论系统\", \"CDN\" 和 \"fingerprint\" 不会启用. 解决方法\r\r使用 hugo server -e production 命令即可运行生产环境进行调试，就能加载评论系统了。\r\r ","date":"2021-06-27","objectID":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/:2:0","tags":["Hugo-LoveIt"],"title":"Hugo+Loveit优化记(转载)","uri":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/"},{"categories":["Hugo-LoveIt"],"content":"Console报错找不到 site.webmanifest 一定要处理\r\r如果不处理的话，会影响网站的打开速度。\r\r 参考LoveIt主题作者的 方法 ,到 Favicon Generator 处理自己的网站图标，最后会下载一个压缩包，包括生成的图标和 browserconfig.xml 、 site.webmanifest 等文件，将这些文件放到 blog\\themes\\LoveIt\\static 中即可。 顺嘴一提\r\rblog\\themes\\LoveIt\\static 这个目录里的文件，最后会出现在网站根目录中。\r\r ","date":"2021-06-27","objectID":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/:3:0","tags":["Hugo-LoveIt"],"title":"Hugo+Loveit优化记(转载)","uri":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/"},{"categories":["Hugo-LoveIt"],"content":"LoveIt扩展Shortcodes 更多扩展Shortcodes的应用方法请查看LoveIt主题作者写的 使用说明 。 ","date":"2021-06-27","objectID":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/:4:0","tags":["Hugo-LoveIt"],"title":"Hugo+Loveit优化记(转载)","uri":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/"},{"categories":["Hugo-LoveIt"],"content":"admonition admonition比较常用，有12个样式，但是主题作者并没说明每种样式对应的 type 是什么。我从源码中找到了它们的对应关系，在此记录一下。 用法 {{\u003c admonition type=tip title=\"This is a tip\" open=true \u003e}} 一个\"技巧\"横幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" true \u003e}} 一个\"技巧\"横幅 {{\u003c /admonition \u003e}} 示例 注意\r\rtype=note\r\r 摘要\r\rtype=abstract\r\r 信息\r\rtype=info\r\r 技巧\r\rtype=tip\r\r 成功\r\rtype=success\r\r 问题\r\rtype=question\r\r 警告\r\rtype=warning\r\r 失败\r\rtype=failure\r\r 危险\r\rtype=danger\r\r Bug\r\rtype=Bug\r\r 示例\r\rtype=example\r\r 引用\r\rtype=quote\r\r ","date":"2021-06-27","objectID":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/:4:1","tags":["Hugo-LoveIt"],"title":"Hugo+Loveit优化记(转载)","uri":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/"},{"categories":["Hugo-LoveIt"],"content":"keywords不生效 参考自 雨临Lewis 的这篇文章。 前提配置\r\r在站点配置文件 config.toml 中填好网站关键词： # 网站关键词 keywords = \"keyword1,keyword2\" \r\r 虽然已经设置了 keywords ，但是F12查看网站源码后发现缺少 keywords 这个 meta 标签，而且在 站长工具 里查询站点时发现页面TDK信息里的关键词 KeyWords 为空。 debug\r\r检查模板文件后发现是LoveIt主题没有引入该标签，需要修改模板。\r\r ","date":"2021-06-27","objectID":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/:5:0","tags":["Hugo-LoveIt"],"title":"Hugo+Loveit优化记(转载)","uri":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/"},{"categories":["Hugo-LoveIt"],"content":"解决方法 将 blog\\themes\\LoveIt\\layouts\\partials\\head\\meta.html 复制到 blog\\layouts\\partials\\head\\meta.html ，打开该文件并在 \u003cmeta name=\"Description\" content=\"{{ $params.description | default .Site.Params.description }}\"\u003e 的上方添加如下代码： \u003cmeta name=\"keywords\" content=\"{{ $params.keywords | default .Site.Params.keywords }}\"\u003e ","date":"2021-06-27","objectID":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/:5:1","tags":["Hugo-LoveIt"],"title":"Hugo+Loveit优化记(转载)","uri":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/"},{"categories":["Hugo-LoveIt"],"content":"参考链接 更多踩坑记录请参考雨临Lewis的 这篇文章 。 更多优化美化指南请参考雨临Lewis的 这篇文章 。 注意\r\r上面雨临Lewis的两篇文章中有许多地方对于 LoveIt_v0.2.10 是不必要的。\r\r ","date":"2021-06-27","objectID":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/:5:2","tags":["Hugo-LoveIt"],"title":"Hugo+Loveit优化记(转载)","uri":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/"},{"categories":["Hugo-LoveIt"],"content":"换用twikoo评论系统 最开始用的评论系统是 valine ，后来换用了带有后台的 waline ，再之后发现 twikoo 后台配置很方便，界面也很好看，于是决定换一波。 但有个问题，twikoo只适配了Hexo的部分主题，而没有适配Hugo主题。 ","date":"2021-06-27","objectID":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/:6:0","tags":["Hugo-LoveIt"],"title":"Hugo+Loveit优化记(转载)","uri":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/"},{"categories":["Hugo-LoveIt"],"content":"解决方法 可以修改评论系统模板文件 blog\\themes\\LoveIt\\layouts\\partials\\comment.html 来手动添加对twikoo的支持，在 \u003cdiv id=\"comments\"\u003e\u003c/div\u003e 中添加以下代码： {{- /* twikoo Comment System */ -}} {{- $twikoo := $comment.twikoo}} {{- if $twikoo.enable -}} \u003cdiv id=\"tcomment\"\u003e\u003c/div\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/twikoo@1.3.1/dist/twikoo.all.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e twikoo.init({ envId: '', // 此处填写您的环境id el: '#tcomment', // region: 'ap-guangzhou', // 环境地域，默认为 ap-shanghai，如果您的环境地域不是上海，需传此参数 // path: 'window.location.pathname', // 用于区分不同文章的自定义 js 路径，如果您的文章路径不是 location.pathname，需传此参数 }) \u003c/script\u003e {{- end }} 然后在博客配置文件 blog\\config.toml 中的 # 评论系统设置 [params.page.comment] enable = true 下面添加 # twikoo评论系统 [params.page.comment.twikoo] enable = true 更多twikoo配置\r\r云部署及版本更新等信息，请到twikoo 官网 查看。\r\r ","date":"2021-06-27","objectID":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/:6:1","tags":["Hugo-LoveIt"],"title":"Hugo+Loveit优化记(转载)","uri":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/"},{"categories":["Hugo-LoveIt"],"content":"部署方式 ","date":"2021-06-27","objectID":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/:7:0","tags":["Hugo-LoveIt"],"title":"Hugo+Loveit优化记(转载)","uri":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/"},{"categories":["Hugo-LoveIt"],"content":"几种选择 GitHub Actions CircleCI 、Netlify 、Travis CI 、Vercel 等第三方服务 最后还是选了GitHub Actions，因为不用到另外的网站上再配置一通，使用 actions-hugo 和 actions-gh-pages 这两个Action，每次写完博客，push一下，GitHub Actions就会自动构建和部署博客。 ","date":"2021-06-27","objectID":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/:7:1","tags":["Hugo-LoveIt"],"title":"Hugo+Loveit优化记(转载)","uri":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/"},{"categories":["Hugo-LoveIt"],"content":"GitHub Actions自动部署Hugo 参考 actions-hugo 和 actions-gh-pages 创建一个私有仓库用来存放博客源码。 创建一个公有仓库用来发布博客。 创建一个个人 token ，名字可以叫做 blog 。 此token的访问范围选择 repo 和 workflow 。 生成token，记住它的值。 到博客源码仓库的 Settings → Secrets 中新建一个 Actions secrets ,名字也叫做 blog ,Value填入上一步中的个人token的值。 在博客源码仓库的根目录下创建 .github/workflows/gh-pages.yml 文件，写入以下代码，然后提交： name:Deploy Blog#名字随便起on:push:branches:- master#源码所在分支jobs:deploy:runs-on:ubuntu-20.04steps:- uses:actions/checkout@v2- name:Setup Hugo#安装hugouses:peaceiris/actions-hugo@v2.4.13#使用peaceiris开发的actions-hugowith:hugo-version:'latest'#可以指定版本号，也可以使用latest表示最新版extended:true#支持hugo的扩展版- name:Build#使用hugo构建博客run:hugo --gc --minify- name:Deploy#部署博客uses:peaceiris/actions-gh-pages@v3.7.3#使用peaceiris开发的actions-gh-pageswith:personal_token:${{ secrets.blog }} external_repository:#用来发布博客的公有仓库publish_branch:masterpublish_dir:./publiccname:#填写你的域名commit_message:${{ github.event.head_commit.message }} 双仓库模式\r\r本博客即采用上面的 gh-pages.yml ，使用私有仓库存放博客源码，将Hugo构建好的 public 目录推送到公有仓库来发布。\r\r 双分支模式\r\r也可以在一个公有仓库中创建两个分支，一个放源码，一个用来发布，但是那样会暴露源码中一些服务的ID和Key。\r\r ","date":"2021-06-27","objectID":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/:7:2","tags":["Hugo-LoveIt"],"title":"Hugo+Loveit优化记(转载)","uri":"/hugo-loveit%E4%BC%98%E5%8C%96%E8%AE%B0/"},{"categories":["Python"],"content":"从Hexo到Hugo 从一个框架到另外一个框架的过渡，比较麻烦的就是文章的迁移，尤其是文章数量较多的时候。如果一个一个手动更改 MD 文档的头部配置信息，无疑是一个巨大的工程量。这个时候我们可以考虑使用脚本来完成重复性操作。 观察Hexo和HuGo的文档头部配置，很相近。 一个是类似于yaml的配置文件，一个类似于toml的配置文件。 ","date":"2021-06-26","objectID":"/%E4%BB%8Ehexo%E5%88%B0hugo%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%84%9A%E6%9C%ACdemo/:0:1","tags":["Python","脚本","Hugo-LoveIt"],"title":"从Hexo到Hugo的博客迁移脚本Demo","uri":"/%E4%BB%8Ehexo%E5%88%B0hugo%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%84%9A%E6%9C%ACdemo/"},{"categories":["Python"],"content":"思路 我是这样思考的： 把Hexo的_post路径下的所有文章全部复制到新的文件夹（怂，不敢对源文件直接操作）重命名Old，继续新建一个文件夹New，存放更改好的文件。 遍历此目录下的所有文件，使用os的读写操作，截选配置部分，进行解析，拿到单个参数对应的值。 把值按照Hugo的格式进行拼接，拿到Hugo的头部配置 把头部文件和剩余的正文部分，拼接，写入新的文件中，完成。 ","date":"2021-06-26","objectID":"/%E4%BB%8Ehexo%E5%88%B0hugo%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%84%9A%E6%9C%ACdemo/:0:2","tags":["Python","脚本","Hugo-LoveIt"],"title":"从Hexo到Hugo的博客迁移脚本Demo","uri":"/%E4%BB%8Ehexo%E5%88%B0hugo%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%84%9A%E6%9C%ACdemo/"},{"categories":["Python"],"content":"困境 思路很简单，就是文件字符的拼接罢了。 但是在实际操作中，发现以前博客的头部格式书写的并不规范，有时有好几个tags，这种情况使用正则直接提取---xxxx---的部分最方便，但是我写不好表达式，无奈只能按行读取按行取大致的前10行左右，通过判读符号: 是否存在来确定内容是否是头部配置部分。而时间中的：又会影响我使用列表分片取值，而且文章有大量的转义字符等，这些都需要考虑进去…..我哭了。。。乱七八糟写了一堆 if..else，终于能把头部配置转换过去了。 结果，正文部分的截取我不知道该如何操作了。有一种思路是通过文件修改前几行数据进行覆盖操作，但是百度了好多方法没成功，而且网上似乎对文件的更改操作教程较少。。。另一种思路是把文件内容加载到内存中，赋给一个变量，截选进行替换，但是强转之后是莫名使用不了replace方法，因为不是Str类型，可实际上已经使用\"\".join()方法转换过了。于是我卡在了这个地方，暂时还没有好的想法。。。 ","date":"2021-06-26","objectID":"/%E4%BB%8Ehexo%E5%88%B0hugo%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%84%9A%E6%9C%ACdemo/:0:3","tags":["Python","脚本","Hugo-LoveIt"],"title":"从Hexo到Hugo的博客迁移脚本Demo","uri":"/%E4%BB%8Ehexo%E5%88%B0hugo%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%84%9A%E6%9C%ACdemo/"},{"categories":["Python"],"content":"部分程序 import os for root, dirs, files in os.walk(r'C:\\Users\\lenovo\\Desktop\\Old'): for file in files: path = os.path.join(root, file) with open(path, \"r+\", encoding=\"utf-8\") as f: data = f.readlines()[0:9] print(data) data_list = [] tags = [] for i in data: if \":\" in i and \"tags\": info = i.split(\": \") data_list.append(info) elif \"- \" in i: i = i.lstrip() tags.append(i[2:-1]) # print(data_list) tag = data_list[2][1].replace(\"\\n\", \"\").lstrip() tags.append(tag) for a in tags: if a == \"\": tags.remove(a) head = \"---\\n\" new_tag = \"tags\" + \": \" + str(tags).replace(\"\\'\", \"\\\"\") new_title = \"title\" + \": \" + data_list[0][1].replace(\"\\n\", \"\") new_date = \"date\" + \": \" + data_list[1][1].replace(\" \", \"T\").replace(\"\\n\", \"\") + \"+08:00\" new_categories = \"categories\" + \": \" + \"[\\\"\" + data_list[3][1].replace(\"\\n\", \"\").lstrip() + \"\\\"]\" new_imgurl = \"featuredImage\" + \": \" + \"\\\"\" + data_list[4][1].replace(\"\\n\", \"\") + \"\\\"\" end = \"---\\n\\n\" head_last = head + new_title + \"\\n\" + new_date + \"\\n\" + \"draft: false\\n\" + new_tag + \"\\n\" + new_categories + \"\\n\" + new_imgurl + \"\\n\" + end print(path) print(head_last) 这里只实现了从hexo到hugo更改头部配置，但是怎么和正文部分合并，还未完成。 ","date":"2021-06-26","objectID":"/%E4%BB%8Ehexo%E5%88%B0hugo%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%84%9A%E6%9C%ACdemo/:0:4","tags":["Python","脚本","Hugo-LoveIt"],"title":"从Hexo到Hugo的博客迁移脚本Demo","uri":"/%E4%BB%8Ehexo%E5%88%B0hugo%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%84%9A%E6%9C%ACdemo/"},{"categories":["Java"],"content":" 琐碎闲谈录: 记录一些零零散散，日常遇到的一些问题和知识点。 ","date":"2021-06-24","objectID":"/java%E7%90%90%E7%A2%8E%E9%97%B2%E8%B0%88%E5%BD%95/:0:0","tags":["java","note"],"title":"Java琐碎闲谈录","uri":"/java%E7%90%90%E7%A2%8E%E9%97%B2%E8%B0%88%E5%BD%95/"},{"categories":["Java"],"content":"关于构造函数 在 Idea 中，如果有一个类，类中定义了几个属性，那么想要生成构造函数太简单了。快捷键一按，有参构造，无参构造，选中直接生成。 public class Person { private Cat cat; private Dog dog; private String name; //无参构造 public Person() { } //有参构造 public Person(Cat cat, Dog dog, String name) { this.cat = cat; this.dog = dog; this.name = name; } //普通函数 public void Method(){ System.out.println(\"我太普通了....\"); } } 这时，我们会发现， 与普通函数相比，构造出来的函数竟然不需要返回类型。 再仔细研究研究， 发现无参构造里面是空的，似乎我们可以往里面写内容？ 事实上，在 JVM 的运行机制里，如果我们在一个类中不声明构造函数， JVM 会帮我们默认生成一个空参数的构造函数（无参构造函数），我们把它称为 隐式构造。如果我们在类中声明了带参数列表的构造函数（有参构造函数），那么 JVM 就不会帮我们默认生成一个无参构造。所以，我们如果想要使用无参构造，那么就必须 显式的声明一个无参构造器。（即在无参构造器里面自己写内容），这样上面的代码就变成了下面的： public Person() { System.out.println(\"这是一个无参构造器\") } 紧接着问题又来了，这些构造函数有什么用？ 创建对象。任何一个对象创建时，都需要初始化才能使用，所以任何类想要创建实例对象就必须具有构造函数。 对象初始化。构造函数可以对对象进行初始化，并且是给与之格式（参数列表）相符合的对象初始化，是具有一定针对性的初始化函数。 好家伙，我看不懂，但我大受震撼。初始化是什么？为啥要初始化？ java规定，变量没有初始化不能使用，全局变量也就是类的属性，java会在编译的时候，自动将他们初始化，所以可以不进行变量初始化的操作，但是（局部）变量必须初始化。初始化就是在最开始定义成员变量时给它一个初始的值，为了防止程序运行时候出现未知的错误，或者bug，总之一句话，为了安全。 闲谈：初学Java的时候，对这些理解迷迷糊糊的。后来在写程序的时候，还是迷迷糊糊的，经常会对这些基础的东西感到困惑，为什么要用到构造函数，构造函数究竟在代码中实现了怎样的功能。 文章参考： 谈谈 java 中的构造函数 Java构造函数，初始化，this关键字 ","date":"2021-06-24","objectID":"/java%E7%90%90%E7%A2%8E%E9%97%B2%E8%B0%88%E5%BD%95/:0:1","tags":["java","note"],"title":"Java琐碎闲谈录","uri":"/java%E7%90%90%E7%A2%8E%E9%97%B2%E8%B0%88%E5%BD%95/"},{"categories":["Java"],"content":"浅谈 Getter/Setter 方法 java 有一个不成文的规定，如果要访问一个类的 private 字段，就需要写 getter/setter 方法。但我们在其它语言却很少见到类似的约定，为什么？ 它是“封装”的体现，对外隐藏了具体实现，允许之后对属性的访问注入新的逻辑（如验证逻辑）。 一些语言，如 python，提供了机制允许我们更改访问属性的逻辑，因此不需要手工写 getter/setter。 getter/setter 是对“属性访问”的封装 假设我们写了下面这段代码，直接访问类的 public 字段： class Person { public String name; } // caller String name = person.name; person.name = \"Java\"; 之后我们认为 name 属性只能是字母，不能包含其它的字符，上面这种实现中，我们就需要更改所有 caller 调用 person.name = ... 的代码。换句话说，类 Person 暴露了实现的细节（即字段 person）。 那么如果一开始就使用了 getter/setter，则我们不需要改变任何 caller，只需要在 setName 函数里增加相应的逻辑即可。 class Person { private String name; public String getName() { return this.name; } public void setName(String name) { validate_name(name); // the newly added validation logic this.name = name; } } // caller String name = person.getName(); person.setName(\"Java\"); 所以，通过这层封装，之后如果有需要，我们甚至可以更改字段的名字，类型等等。这就是封装的好处，而 getter/setter 这种写法能让我们为将来可能的修改做好准备。 其它语言里的 getter/setter getter/setter 的作用是为“属性的访问”（即 x.field 与 x.field = ...）提供日后修改的可能。一些“比较新”的语言就默认提供了这种能力。 Python 中提供了 Descriptor 的机制。在 Python 中，可以认为当访问对象的属性时，等价于调用对象的 __get__() 和 __set__() 方法，因此我们可以覆盖这两个方法来修改访问的逻辑。 同样的，Kotlin 在定义 properties 也可以自定义的 getter/setter 方法来修改属性访问的逻辑。 这里想说明的是，getter/setter 其实应该是默认实现，然后有需要时再覆盖，而不是每次都手工实现。 社区与约定 也许你会问，封装其实叫什么名字都行，为什么非要叫 getXXX 及 setXXX 呢？这其实是 JavaBeans 里约定的（7.1 节）。甚至从某种角度来说 getter/setter 的目的也不是为了封装，而只是一个约定，使框架能识别 JavaBeans 中的 property。 在实际工作中你会发现，90% 以上的 getter/setter 在未来并不会被用来增加逻辑什么的。所以“封装”的作用理论上是好的，但实际被使用到的频率特别低，反而增加了许多无用的代码。 另一方面，随着使用 getter/setter 使用的增加，且由于绝大多数 getter/setter 并不会增加额外的逻辑，使得人们开始习惯于假设 getter/setter 不会有额外逻辑。所以如果你想在 setter 里加一些额外的逻辑时，反而要注意会不会让使用的人感到吃惊。 写在最后 Getter/Setter 这个话题看上去似乎很简单，它的背后却有很多可以深究和思考的内容的。有人说 Getter 没关系，可怕的是 Setter；也有说现在lombok 这么方便，用 Getter/Setter 有利无害；也有人说尽量避免使用 Getter/Setter。这些观点背后都藏着一些软件的设计思维。例如怎样设计类的接口，如何实现封装，这些都是后续需要学习思考的内容。 闲谈：跟上面一样，学的时候不太懂，反正跟着视频敲就对了，也不知道有什么意义。后来get/set方法出现频率越来越高（学Spring的时候，控制反转），突然就有点明白了，隐隐约约跟bean有点关系，嗯，回过头重新记录一下。 文章参考：为什么 java 中要写 getter/setter？ （直接搬运了，写的很好） ","date":"2021-06-24","objectID":"/java%E7%90%90%E7%A2%8E%E9%97%B2%E8%B0%88%E5%BD%95/:0:2","tags":["java","note"],"title":"Java琐碎闲谈录","uri":"/java%E7%90%90%E7%A2%8E%E9%97%B2%E8%B0%88%E5%BD%95/"},{"categories":["Java"],"content":"组合优于继承原则 面向对象编程中，有一条非常经典的设计原则，那就是：组合优于继承，多用组合少用继承。因为大多数继承都可以利用组合（composition）、接口、委托（delegation）三个技术手段来实现。从而降低继承的层次和复杂的继承关系。 闲谈：以前用过，但是从未思考过还有这个概念。在学静态代理的时候，有这样个例子，关于房东，租客，中介三者之间的关系，房东有Rent方法，中介这个代理想要使用Rent()，可以使用继承，但是不建议。组合可以实现更多的独属于代理这个类的方法。 文章参考 ：为什么组合先于继承 ","date":"2021-06-24","objectID":"/java%E7%90%90%E7%A2%8E%E9%97%B2%E8%B0%88%E5%BD%95/:0:3","tags":["java","note"],"title":"Java琐碎闲谈录","uri":"/java%E7%90%90%E7%A2%8E%E9%97%B2%E8%B0%88%E5%BD%95/"},{"categories":null,"content":" About This Blog 美化的尽头终究是默认…… 实话说，内容倒是没写多少，反而从WordPress到Hexo再到Hugo，主题框架换个不停。可能是老了，越来越看不动以前花费大把时间去美化的Hexo博客了，总感觉花里胡哨的。每次好不容易准备发布(水)文章的时候，还要极不情愿的慢慢找张图片（其实是找不到好看的，懒的继续找），仅仅是为了跟以前的风格保持一致，想来想去感觉不太值得。 于是想找一个一个足够简洁，可以随心所欲的写写笔记，安安静静的记录生活，闲暇时能舒服的躺在角落里看着傻笑的就好了。 无意中了解到Hugo，速度快，而且足够简单，最主要这个主题我喜欢，哈哈。 ","date":"2021-06-21","objectID":"/about/:0:1","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":" About Me Lone 平平无奇一男的。 一个希望在 IT 世界里玩的愉快的菜鸡。 ","date":"2021-06-21","objectID":"/about/:0:2","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":" A word 世界上只有有一种真正的英雄主义，那就是在认清世界的真相之后，依旧热爱生活。 Peace！ ","date":"2021-06-21","objectID":"/about/:0:3","tags":null,"title":"About","uri":"/about/"},{"categories":["Java"],"content":"Spring ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"简介 Spring ——\u003e 春天，为开源软件带来了春天 2002，首次推出了Spring框架的雏形：interface21框架！ Spring框架以interface21框架为基础，经过重新设计，并不断丰富其内涵，于2004年3月24日发布了1.0正式版 Spring的理念：使用现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架！ SSH：Struct2 + Spring + Hibernate（全自动持久化框架）！ SSM：SpringMVC + Spring + MyBatis（半自动持久化框架，可自定义性质更强）！ spring官网： https://spring.io/projects/spring-framework#overview 官方下载： https://repo.spring.io/release/org/springframework/spring/ GitHub： https://github.com/spring-projects/spring-framework Spring Web MVC： spring-webmvc最新版 Spring Web MVC和Spring-JDBC的pom配置文件： \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:1","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"优点 Spring是一个开源的免费的框架（容器）！ Spring是一个轻量级的、非入侵式的框架！ 控制反转（IoC），面向切面编程（AOP） 支持事务的处理，对框架整合的支持！（几乎市面上所有热门框架都能整合进去）！ === 总结一句话：Spring就是一个轻量级的控制反转（IoC）和面向切面编程（AOP）的框架！ === ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:2","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"组成 ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:3","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"扩展 现代化的java开发 -\u003e 基于Spring的开发！ Spring Boot 一个快速开发的脚手架 基于SpringBoot可以快速开发单个微服务 约定大于配置！ Spring Cloud SpringCloud是基于SpringBoot实现的！ 因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC！承上启下的作用！ ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:4","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"（控制反转）理论推导 传统的调用 UserDao package dao; public interface UserDao { void getUser(); } UserDaoImp package dao; public class UserDaoImpl implements UserDao{ public void getUser() { System.out.println(\"默认获取用户数据\"); } } UserSevice package Service; public interface UserService { void getUser(); } UserServiceImp package Service; import dao.UserDao; import dao.UserDaoImpl; public class UserServiceImpl implements UserService{ UserDao userDao = new UserDaoImpl(); public void getUser(){ userDao.getUser(); } } 测试 package holle0; import Service.UserService; import Service.UserServiceImpl; public class MyTest0 { public static void main(String[] args) { // 用户实际调用的是业务层，dao层他们不需要接触 UserService userService = new UserServiceImpl(); userService.getUser(); } } 在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！ **改良：**我们使用一个Set接口实现。已经发生了革命性的变化！ //在Service层的实现类(UserServiceImpl)增加一个Set()方法 //利用set动态实现值的注入！ //DAO层并不写死固定调用哪一个UserDao的实现类 //而是通过Service层调用方法设置实现类！ private UserDao userDao; public void setUserDao(UserDao userDao){ this.userDao = userDao; } set() 方法实际上是动态改变了 UserDao userDao 的 初始化部分（new UserDaoImpl()） 测试中加上 ((UserServiceImpl)userService).setUserDao(new UserDaoImpl()); 之前，程序是主动创建对象！控制权在程序猿手上！ 使用了set注入后，程序不再具有主动性，而是变成了被动的接受对象！（主动权在客户手上） 本质上解决了问题，程序员不用再去管理对象的创建 系统的耦合性大大降低，可以更专注在业务的实现上 这是IoC（控制反转）的原型，反转(理解)：主动权交给了用户 ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"IoC本质 ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:1","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"HolleSpring 在父模块中导入jar包 \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e pojo的Hello.java package pojo; public class Hello { private String str; public String getStr() { return str; } public void setStr(String str) { this.str = str; } @Override public String toString() { return \"Holle [str=\" + str + \"]\"; } } 在resource里面的xml配置 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c!--在Spring中创建对象，在Spring这些都称为bean 类型 变量名 = new 类型(); Holle holle = new Holle(); bean = 对象(holle) id = 变量名(holle) class = new的对象(new Holle();) property 相当于给对象中的属性设值,让str=\"Spring\" --\u003e \u003cbean id=\"hello\" class=\"pojo.Hello\"\u003e \u003cproperty name=\"str\" value=\"Spring\"/\u003e \u003c/bean\u003e \u003c/beans\u003e 测试类MyTest package holle1; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import pojo.Hello; public class MyTest { public static void main(String[] args) { //获取Spring的上下文对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); //我们的对象下能在都在spring·中管理了，我们要使用，直接取出来就可以了 Hello holle = (Hello) context.getBean(\"hello\"); System.out.println(holle.toString()); } } 核心用set注入，所以必须要有下面的se()方法 //Hello类 public void setStr(String str) { this.str = str; } 思考： IoC：对象由Spring 来创建，管理，装配！ 弹幕评论里面的理解： 原来这套程序是：你写好菜单买好菜，客人来了自己把菜炒好招待，就相当于你请人吃饭 现在这套程序是：你告诉楼下餐厅，你要哪些菜，客人来的时候，餐厅把做好的你需要的菜送上来 IoC：炒菜这件事，不再由你自己来做，而是委托给了第三方__餐厅来做 此时的区别就是，如果我还需要做其他的菜，我不需要自己搞菜谱买材料再做好，而是告诉餐厅，我要什么菜，什么时候要，你做好送来 在前面第一个module试试引入Spring \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"userDaomSql\" class=\"dao.UserDaoMysqlImpl\"\u003e\u003c/bean\u003e \u003cbean id=\"userServiceImpl\" class=\"service.UserServiceImp\"\u003e \u003c!--ref引用spring中已经创建很好的对象--\u003e \u003c!--value是一个具体的值,基本数据类型--\u003e \u003cproperty name=\"userDao\" ref=\"userDaomSql\"/\u003e \u003c/bean\u003e \u003c/beans\u003e 第一个module改良后测试 package holle0; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import service.UserServiceImpl; public class MyTest0 { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); UserServiceImpl userServiceImpl = (UserServiceImpl) context.getBean(\"userServiceImpl\"); userServiceImpl.getUser(); } } 总结： 所有的类都要装配的beans.xml 里面； 所有的bean 都要通过容器去取； 容器里面取得的bean，拿出来就是一个对象，用对象调用方法即可； ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"IoC创建对象的方式 使用无参构造创建对象，默认。 使用有参构造（如下） 下标赋值 index指的是有参构造中参数的下标，下标从0开始; \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"user\" class=\"pojo.User\"\u003e \u003cconstructor-arg index=\"0\" value=\"chen\"/\u003e \u003c/bean\u003e \u003c/beans\u003e 类型赋值（不建议使用） \u003cbean id=\"user\" class=\"pojo.User\"\u003e \u003cconstructor-arg type=\"java.lang.String\" value=\"kuang\"/\u003e \u003c/bean\u003e 直接通过参数名（掌握） \u003cbean id=\"user\" class=\"pojo.User\"\u003e \u003cconstructor-arg name=\"name\" value=\"kuang\"\u003e\u003c/constructor-arg\u003e \u003c/bean\u003e \u003c!-- 比如参数名是name，则有name=\"具体值\" --\u003e 注册bean之后就对象的初始化了（类似 new 类名()） 弹幕评论： name方式还需要无参构造和set方法,index和type只需要有参构造 就算是new 两个对象，也是只有一个实例（单例模式：全局唯一） User user = (User) context.getBean(\"user\"); User user2 = (User) context.getBean(\"user\"); system.out.println(user == user2)//结果为true 总结：在配置文件加载的时候，容器(\u003c bean\u003e)中管理的对象就已经初始化了 ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"Spring配置 ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"别名 \u003cbean id=\"user\" class=\"pojo.User\"\u003e \u003cconstructor-arg name=\"name\" value=\"chen\"\u003e\u003c/constructor-arg\u003e \u003c/bean\u003e \u003calias name=\"user\" alias=\"userLove\"/\u003e \u003c!-- 使用时 User user2 = (User) context.getBean(\"userLove\"); --\u003e ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:1","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"Bean的配置 \u003c!--id：bean的唯一标识符，也就是相当于我们学的对象名 class：bean对象所对应的会限定名：包名+类型 name：也是别名，而且name可以同时取多个别名 --\u003e \u003cbean id=\"user\" class=\"pojo.User\" name=\"u1 u2,u3;u4\"\u003e \u003cproperty name=\"name\" value=\"chen\"/\u003e \u003c/bean\u003e \u003c!-- 使用时 User user2 = (User) context.getBean(\"u1\"); --\u003e ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:2","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"import import一般用于团队开发使用，它可以将多个配置文件，导入合并为一个 假设，现在项目中有多个人开发，这三个人复制不同的类开发，不同的类需要注册在不同的bean中，我们可以利 用import将所有人的beans.xml合并为一个总的！ 张三(beans.xm1) 李四(beans2.xm1) 王五(beans3.xm1) applicationContext.xml \u003cimport resource=\"beans.xm1\"/\u003e \u003cimport resource=\"beans2.xml\"/\u003e \u003cimport resource=\"beans3.xm1\"/\u003e 使用的时候，直接使用总的配置就可以了 弹幕评论： 按照在总的xml中的导入顺序来进行创建，后导入的会重写先导入的，最终实例化的对象会是后导入xml中的那个 ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:3","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"依赖注入（DI） ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"构造器注入 第4点有提到 ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:1","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"set方式注入【重点】 依赖注入：set注入！ 依赖：bean对象的创建依赖于容器 注入：bean对象中的所有属性，由容器来注入 【环境搭建】 复杂类型 Address类 真实测试对象 Student类 beans.xml 测试 MyTest3 Student类 package pojo; import java.util.*; @Get @Set public class Student { //别忘了写get和set方法（用lombok注解也行） private String name; private Address address; private String[] books; private List\u003cString\u003e hobbies; private Map\u003cString, String\u003e card; private Set\u003cString\u003e game; private Properties infor; private String wife; @Override public String toString() { return \"Student{\" +\"\\n\"+ \"name='\" + name + '\\'' +\"\\n\"+ \", address=\" + address.toString() +\"\\n\"+ \", books=\" + Arrays.toString(books) +\"\\n\"+ \", hobbies=\" + hobbies +\"\\n\"+ \", card=\" + card +\"\\n\"+ \", game=\" + game +\"\\n\"+ \", infor=\" + infor +\"\\n\"+ \", wife='\" + wife + '\\'' +\"\\n\"+ '}'; } } Address类 package pojo; public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public String toString() { return \"Address{\" + \"address='\" + address + '\\'' + '}'; } } beans.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"address\" class=\"pojo.Address\"\u003e \u003cproperty name=\"address\" value=\"address你好\" /\u003e \u003c/bean\u003e \u003cbean id=\"student\" class=\"pojo.Student\"\u003e \u003c!--第一种，普通值注入 --\u003e \u003cproperty name=\"name\" value=\"name你好\" /\u003e \u003c!--第二种，ref注入 --\u003e \u003cproperty name=\"address\" ref=\"address\" /\u003e \u003c!--数组注入 --\u003e \u003cproperty name=\"books\"\u003e \u003carray\u003e \u003cvalue\u003e三国\u003c/value\u003e \u003cvalue\u003e西游\u003c/value\u003e \u003cvalue\u003e水浒\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e \u003c!--list列表注入 --\u003e \u003cproperty name=\"hobbies\"\u003e \u003clist\u003e \u003cvalue\u003e唱\u003c/value\u003e \u003cvalue\u003e跳\u003c/value\u003e \u003cvalue\u003erap\u003c/value\u003e \u003cvalue\u003e篮球\u003c/value\u003e \u003c/list\u003e \u003c/property\u003e \u003c!--map键值对注入 --\u003e \u003cproperty name=\"card\"\u003e \u003cmap\u003e \u003centry key=\"username\" value=\"root\" /\u003e \u003centry key=\"password\" value=\"root\" /\u003e \u003c/map\u003e \u003c/property\u003e \u003c!--set(可去重)注入 --\u003e \u003cproperty name=\"game\"\u003e \u003cset\u003e \u003cvalue\u003ewangzhe\u003c/value\u003e \u003cvalue\u003elol\u003c/value\u003e \u003cvalue\u003egalname\u003c/value\u003e \u003c/set\u003e \u003c/property\u003e \u003c!--空指针null注入 --\u003e \u003cproperty name=\"wife\"\u003e \u003cnull\u003e\u003c/null\u003e \u003c/property\u003e \u003c!--properties常量注入 --\u003e \u003cproperty name=\"infor\"\u003e \u003cprops\u003e \u003cprop key=\"id\"\u003e20200802\u003c/prop\u003e \u003cprop key=\"name\"\u003ecbh\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e MyTest3 import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import pojo.Student; public class MyTest3 { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Student stu = (Student) context.getBean(\"student\"); System.out.println(stu.toString()); } } ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:2","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"拓展注入 方文档位置 pojo增加User类 package pojo; public class User { private String name; private int id; public User() { } public User(String name, int id) { super(); this.name = name; this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } @Override public String toString() { return \"User [name=\" + name + \", id=\" + id + \"]\"; } } 注意： beans 里面加上这下面两行 使用p和c命名空间需要导入xml约束 xmlns:p=“http://www.springframework.org/schema/p” xmlns:c=“http://www.springframework.org/schema/c” ?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:c=\"http://www.springframework.org/schema/c\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c!--p命名空间注入/set注入，可以直接注入属性的值-》property--\u003e \u003cbean id=\"user\" class=\"pojo.User\" p:name=\"cxk\" p:id=\"20\" \u003e \u003c/bean\u003e \u003c!--c命名空间，通过构造器注入，需要写入有参和无参构造方法-》construct-args--\u003e \u003cbean id=\"user2\" class=\"pojo.User\" c:name=\"cbh\" c:id=\"22\"\u003e\u003c/bean\u003e \u003c/beans\u003e 测试 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = context.getBean(\"user\",User.class);//确定class对象，就不用再强转了 System.out.println(user.toString()); ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:3","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"Bean作用域 单例模式（默认） \u003cbean id=\"user2\" class=\"pojo.User\" c:name=\"cxk\" c:age=\"19\" scope=\"singleton\"\u003e\u003c/bean\u003e 1 弹幕评论：单例模式是把对象放在pool中，需要再取出来，使用的都是同一个对象实例 原型模式: 每次从容器中get的时候，都产生一个新对象！ \u003cbean id=\"user2\" class=\"pojo.User\" c:name=\"cxk\" c:age=\"19\" scope=\"prototype\"\u003e\u003c/bean\u003e 1 其余的request、session、application这些只能在web开放中使用！ ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:4","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"Bean的自动装配 自动装配是Spring满足bean依赖的一种方式 Spring会在上下文自动寻找，并自动给bean装配属性 在Spring中有三种装配的方式 在xml中显示配置 在java中显示配置 隐式的自动装配bean 【重要】 环境搭建：一个人有两个宠物 byType自动装配：byType会自动查找，和自己对象set方法参数的类型相同的bean 保证所有的class唯一(类为全局唯一) byName自动装配：byName会自动查找，和自己对象set对应的值对应的id 保证所有id唯一，并且和set注入的值一致 \u003c!-- 找不到id和多个相同class --\u003e \u003cbean id=\"cat1\" class=\"pojo.Cat\"/\u003e \u003cbean id=\"cat2\" class=\"pojo.Cat\"/\u003e \u003c!-- 找不到 id=cat，且有两个Cat --\u003e ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"测试：自动装配 pojo的Cat类 public class Cat { public void shut(){ System.out.println(\"miao\"); } } pojo的Dog类 public class Dog { public void shut(){ System.out.println(\"wow\"); } } pojo的People类 package pojo; public class People { private Cat cat; private Dog dog; private String name; public Cat getCat() { return cat; } public void setCat(Cat cat) { this.cat = cat; } public Dog getDog() { return dog; } public void setDog(Dog dog) { this.dog = dog; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"People{\" + \"cat=\" + cat + \", dog=\" + dog + \", name='\" + name + '\\'' + '}'; } } xml配置 -\u003e byType 自动装配 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"cat\" class=\"pojo.Cat\"/\u003e \u003cbean id=\"dog\" class=\"pojo.Dog\"/\u003e \u003c!--byType会在容器自动查找，和自己对象属性相同的bean 例如，Dog dog; 那么就会查找pojo的Dog类，再进行自动装配 --\u003e \u003cbean id=\"people\" class=\"pojo.People\" autowire=\"byType\"\u003e \u003cproperty name=\"name\" value=\"cbh\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e xml配置 -\u003e byName 自动装配 \u003cbean id=\"cat\" class=\"pojo.Cat\"/\u003e \u003cbean id=\"dog\" class=\"pojo.Dog\"/\u003e \u003c!--byname会在容器自动查找，和自己对象set方法的set后面的值对应的id 例如:setDog()，取set后面的字符作为id，则要id = dog 才可以进行自动装配 --\u003e \u003cbean id=\"people\" class=\"pojo.People\" autowire=\"byName\"\u003e \u003cproperty name=\"name\" value=\"cbh\"\u003e\u003c/property\u003e \u003c/bean\u003e 弹幕评论：byName只能取到小写，大写取不到 ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:1","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"使用注解实现自动装配 jdk1.5支持的注解，spring2.5支持的注解 The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML.（翻译：基于注释的配置的引入提出了一个问题，即这种方法是否比XML“更好”） 导入context约束 xmlns:context=“http://www.springframework.org/schema/context\" 配置注解的支持：\u003c context:annotation-config/\u003e \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003ccontext:annotation-config/\u003e \u003c/beans\u003e @Autowired 默认是byType方式，如果匹配不上，就会byName 在属性上个使用，也可以在set上使用 我们可以不用编写set方法了，前提是自动装配的属性在Spring容器里，且要符合ByName 自动装配 public class People { @Autowired private Cat cat; @Autowired private Dog dog; private String name; } @Nullable 字段标记了这个注解，说明该字段可以为空 public name(@Nullable String name){ } //源码 public @interface Autowired { boolean required() default true; } 如果定义了Autowire的require属性为false，说明这个对象可以为null，否则不允许为空（false表示找不到装配，不抛出异常） @Autowired+@Qualifier @Autowired不能唯一装配时，需要@Autowired+@Qualifier 如果@Autowired自动装配环境比较复杂。自动装配无法通过一个注解完成的时候，可以使用@Qualifier(value = “dog”)去配合使用，指定一个唯一的id对象 public class People { @Autowired private Cat cat; @Autowired @Qualifier(value = \"dog\") private Dog dog; private String name; } 弹幕评论： 如果xml文件中同一个对象被多个bean使用，Autowired无法按类型找到，可以用@Qualifier指定id查找 @Resource 默认是byName方式，如果匹配不上，就会byType public class People { Resource(name=\"cat\") private Cat cat; Resource(name=\"dog\") private Dog dog; private String name; } 弹幕评论： Autowired是byType，@Autowired+@Qualifier = byType || byName Autowired是先byteType,如果唯一則注入，否则byName查找。resource是先byname,不符合再继续byType 区别： @Resource和@Autowired的区别： 都是用来自动装配的，都可以放在属性字段上 @Autowired通过byType的方式实现，而且必须要求这个对象存在！【常用】 @Resource默认通过byname的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错！【常用】 执行顺序不同：@Autowired通过byType的方式实现。@Resource默认通过byname的方式实现 ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:2","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"使用注解开发 在spring4之后，使用注解开发，必须要保证aop包的导入 使用注解需要导入contex的约束 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003ccontext:annotation-config/\u003e \u003c/beans\u003e ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:0","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"bean 弹幕评论： 有了\u003c context:component-scan\u003e，另一个\u003c context:annotation-config/\u003e标签可以移除掉，因为已经被包含进去了。 \u003c!--指定要扫描的包，这个包下面的注解才会生效 别只扫一个com.kuang.pojo包--\u003e \u003ccontext:component-scan base-package=\"com.kuang\"/\u003e \u003ccontext:annotation-config/\u003e //@Component 组件 //等价于\u003cbean id=\"user\" classs\"pojo.User\"/\u003e @Component public class User { public String name =\"秦疆\"; } ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:1","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"8.2、属性如何注入@value @Component public class User { //相当于\u003cproperty name=\"name\" value=\"kuangshen\"/\u003e @value(\"kuangshen\") public String name; //也可以放在set方法上面 //@value(\"kuangshen\") public void setName(String name) { this.name = name; } } ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:2","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"衍生的注解 @Component有几个衍生注解，会按照web开发中，mvc架构中分层。 dao （@Repository） service（@Service） controller（@Controller） 这四个注解的功能是一样的，都是代表将某个类注册到容器中 ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:3","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"自动装配置 @Autowired：默认是byType方式，如果匹配不上，就会byName @Nullable：字段标记了这个注解，说明该字段可以为空 @Resource：默认是byName方式，如果匹配不上，就会byType ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:4","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"作用域@scope //原型模式prototype，单例模式singleton //scope(\"prototype\")相当于\u003cbean scope=\"prototype\"\u003e\u003c/bean\u003e @Component @scope(\"prototype\") public class User { //相当于\u003cproperty name=\"name\" value=\"kuangshen\"/\u003e @value(\"kuangshen\") public String name; //也可以放在set方法上面 @value(\"kuangshen\") public void setName(String name) { this.name = name; } } ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:5","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"小结 xml与注解： xml更加万能，维护简单，适用于任何场合 注解，不是自己的类使用不了，维护复杂 最佳实践： xml用来管理bean 注解只用来完成属性的注入 要开启注解支持 ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:6","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"使用Java的方式配置Spring 不使用Spring的xml配置，完全交给java来做！ Spring的一个子项目，在spring4之后，，，它成为了核心功能 实体类：pojo的User.java //这里这个注解的意思,就是说明这个类被Spring接管了,注册到了容器中 @component public class User { private String name; public String getName() { return name; } //属性注入值 @value(\"QINJIANG') public void setName(String name) { this.name = name; } @Override public String toString() { return \"user{\" + \"name='\" + name + '\\''+ '}'; } } 弹幕评论：要么使用@Bean，要么使用@Component和ComponentScan，两种效果一样 配置文件：config中的kuang.java @Import(KuangConfig2.class)，用@import来包含KuangConfig2.java //这个也会Spring容器托管,注册到容器中,因为他本米就是一个@Component // @Configuration表这是一个配置类,就像我们之前看的beans.xml，类似于\u003cbeans\u003e标签 @Configuration @componentScan(\"com.Kuang.pojo\") //开启扫描 //@Import(KuangConfig2.class) public class KuangConfig { //注册一个bean , 就相当于我们之前写的一个bean 标签 //这个方法的名字,就相当于bean 标签中的 id 属性 -\u003egetUser //这个方法的返同值,就相当于bean 标签中的class 属性 -\u003eUser //@Bean public User getUser(){ return new User(); //就是返回要注入到bean的对象! } } 弹幕评论：ComponentScan、@Component(“pojo”) 这两个注解配合使用 测试类 public class MyTest { public static void main(String[ ] args) { //如果完全使用了配置类方式去做,我们就只能通过 Annotationconfig 上下文来获取容器,通过配置类的class对象加载! ApplicationContext context = new AnnotationConfigApplicationContext(KuangConfig.Class); //class对象 User getUser =(User)context.getBean( \"getUser\"); //方法名getUser System.out.Println(getUser.getName()); } } 会创建两个相同对象问题的说明： 弹幕总结 - -\u003e @Bean是相当于\u003c bean\u003e标签创建的对象，而我们之前学的@Component是通过spring自动创建的这个被注解声明的对象，所以这里相当于有两个User对象被创建了。一个是bean标签创建的（@Bean），一个是通过扫描然后使用@Component，spring自动创建的User对象，所以这里去掉@Bean这些东西，然后开启扫描。之后在User头上用@Component即可达到spring自动创建User对象了 //这个也会Spring容器托管,注册到容器中,因为他本米就是一个@Component // @Configuration表这是一个配置类,就像我们之前看的beans.xml，类似于\u003cbeans\u003e标签 @Configuration @componentScan(\"com.Kuang.pojo\") //开启扫描 //@Import(KuangConfig2.class) public class KuangConfig { //注册一个bean , 就相当于我们之前写的一个bean 标签 //这个方法的名字,就相当于bean 标签中的 id 属性 -\u003egetUser //这个方法的返同值,就相当于bean 标签中的class 属性 -\u003eUser //@Bean public User getUser(){ return new User(); //就是返回要注入到bean的对象! } } 弹幕评论：ComponentScan、@Component(“pojo”) 这两个注解配合使用 测试类 public class MyTest { public static void main(String[ ] args) { //如果完全使用了配置类方式去做,我们就只能通过 Annotationconfig 上下文来获取容器,通过配置类的class对象加载! ApplicationContext context = new AnnotationConfigApplicationContext(KuangConfig.Class); //class对象 User getUser =(User)context.getBean( \"getUser\"); //方法名getUser System.out.Println(getUser.getName()); } } 会创建两个相同对象问题的说明： 弹幕总结 - -\u003e @Bean是相当于\u003c bean\u003e标签创建的对象，而我们之前学的@Component是通过spring自动创建的这个被注解声明的对象，所以这里相当于有两个User对象被创建了。一个是bean标签创建的（@Bean），一个是通过扫描然后使用@Component，spring自动创建的User对象，所以这里去掉@Bean这些东西，然后开启扫描。之后在User头上用@Component即可达到spring自动创建User对象了 ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:0","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"动态代理 代理模式是SpringAOP的底层 分类：动态代理和静态代理 ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:10:0","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"静态代理 代码步骤： 1、接口 package pojo; public interface Host { public void rent(); } 2、真实角色 package pojo; public class HostMaster implements Host{ public void rent() { System.out.println(\"房东要出租房子\"); } } 3、代理角色 package pojo; public class Proxy { public Host host; public Proxy() { } public Proxy(Host host) { super(); this.host = host; } public void rent() { seeHouse(); host.rent(); fee(); sign(); } //看房 public void seeHouse() { System.out.println(\"看房子\"); } //收费 public void fee() { System.out.println(\"收中介费\"); } //合同 public void sign() { System.out.println(\"签合同\"); } } 4、客户端访问代理角色 package holle4_proxy; import pojo.Host; import pojo.HostMaster; import pojo.Proxy; public class My { public static void main(String[] args) { //房东要出租房子 Host host = new HostMaster(); //中介帮房东出租房子，但也收取一定费用（增加一些房东不做的操作） Proxy proxy = new Proxy(host); //看不到房东，但通过代理，还是租到了房子 proxy.rent(); } } 代码翻倍：几十个真实角色就得写几十个代理 AOP横向开发 ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:10:1","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"动态代理 动态代理和静态角色一样，动态代理底层是反射机制 动态代理类是动态生成的，不是我们直接写好的！ 动态代理(两大类)：基于接口，基于类 基于接口：JDK的动态代理【使用ing】 基于类：cglib java字节码实现：javasisit 了解两个类 1、Proxy：代理 2、InvocationHandler：调用处理程序 实例： 接口 Host.java //接口 package pojo2; public interface Host { public void rent(); } 接口Host实现类 HostMaster.java //接口实现类 package pojo2; public class HostMaster implements Host{ public void rent() { System.out.println(\"房东要租房子\"); } } 代理角色的处理程序类 ProxyInvocationHandler.java package pojo2; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; ///用这个类，自动生成代理 public class ProxyInvocationHandler implements InvocationHandler { // Foo f =(Foo) Proxy.NewProxyInstance(Foo. Class.GetClassLoader(), // new Class\u003c?\u003e[] { Foo.Class }, // handler); // 被代理的接口 public HostMaster hostMaster ; public void setHostMaster(HostMaster hostMaster) { this.hostMaster = hostMaster; } // 得到生成的代理类 public Object getProxy() { // newProxyInstance() -\u003e 生成代理对象，就不用再写具体的代理类了 // this.getClass().getClassLoader() -\u003e 找到加载类的位置 // hostMaster.getClass().getInterfaces() -\u003e 代理的具体接口 // this -\u003e 代表了接口InvocationHandler的实现类ProxyInvocationHandler return Proxy.newProxyInstance(this.getClass().getClassLoader(), hostMaster.getClass().getInterfaces(), this); // 处理代理实例并返回结果 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { seeHouse(); // 动态代理的本质，就是使用反射机制实现的 // invoke()执行它真正要执行的方法 Object result = method.invoke(hostMaster, args); fee(); return result; } public void seeHouse() { System.out.println(\"看房子\"); } public void fee() { System.out.println(\"收中介费\"); } } 用户类 My2.java package holle4_proxy; import pojo2.Host; import pojo2.Host2; import pojo2.HostMaster; import pojo2.ProxyInvocationHandler; public class My2 { public static void main(String[] args) { //真实角色 HostMaster hostMaster = new HostMaster(); //代理角色，现在没有；用代理角色的处理程序来实现Host接口的调用 ProxyInvocationHandler pih = new ProxyInvocationHandler(); //pih -\u003e HostMaster接口类 -\u003e Host接口 pih.setHostMaster(hostMaster); //获取newProxyInstance动态生成代理类 Host proxy = (Host) pih.getProxy(); proxy.rent(); } } 弹幕评论： 什么时候调用invoke方法的? 代理实例调用方法时invoke方法就会被调用，可以debug试试 改为万能代理类 ///用这个类，自动生代理 public class ProxyInvocationHandler implements InvocationHandler { // 被代理的接口 public Object target; public void setTarget(Object target) { this.target = target; } // 得到生成的代理类 -\u003e 固定的代码 public Object getProxy() { return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this); } // 处理代理实例并返回结果 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 动态代理的本质，就是使用反射机制实现的 // invoke()执行它真正要执行的方法 Object result = method.invoke(target, args); return result; } } ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:10:2","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"AOP ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:0","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"什么是AOP ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:1","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"AOP在Spring中的使用 提供声明式事务，允许用户自定义切面 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志，安全，缓存，事务等等… 切面(Aspect)：横切关注点 被模块化的特殊对象。即，它是一个类。（Log类） 通知(Advice)：切面必须要完成的工作。即，它是类中的一个方法。（Log类中的方法） 目标(Target)：被通知对象。（生成的代理类) 代理(Proxy)：向目标对象应用通知之后创建的对象。（生成的代理类） 切入点(PointCut)：切面通知执行的”地点”的定义。（最后两点：在哪个地方执行，比如：method.invoke()） 连接点(JointPoint)：与切入点匹配的执行点。 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice: 即AOP在不改变原有代码的情况下，去增加新的功能。（代理） ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:2","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"使用Spring实现AOP 导入jar包 \u003c!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.9.4\u003c/version\u003e \u003c/dependency\u003e 方法一：使用原生spring接口 springAPI接口实现 applicationContext.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!--注册bean--\u003e \u003cbean id=\"userservice\" class=\"service.UserServiceImpl\"/\u003e \u003cbean id=\"log\" class=\"log.Log\"/\u003e \u003cbean id=\"afterLog\" class=\"log.AfterLog\"/\u003e \u003c!--方式一，使用原生Spring API接口--\u003e \u003c!--配置aop,还需要导入aop约束--\u003e \u003caop:config\u003e \u003c!--切入点：expression:表达式，execution（要执行的位置）--\u003e \u003caop:pointcut id=\"pointcut\" expression=\"execution(* service.UserServiceImpl.*(..))\"/\u003e \u003c!--UserServiceImpl.*(..) -》 UserServiceImpl类下的所以方法(参数)--\u003e \u003c!--执行环绕增加--\u003e \u003caop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/\u003e \u003caop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/\u003e \u003c!-- 环绕,在id=\"pointcut\"的前后切入 --\u003e \u003c/aop:config\u003e \u003c/beans\u003e execution(返回类型，类名，方法名(参数)) -\u003e execution(* com.service.*,*(…)) UserService.java package service; public interface UserService { public void add() ; public void delete() ; public void query() ; public void update(); } UserService 的实现类 UserServiceImp.java package service; public class UserServiceImpl implements UserService { public void add() { System.out.println(\"add增\"); } public void delete() { System.out.println(\"delete删\"); } public void update() { System.out.println(\"update改\"); } public void query() { System.out.println(\"query查\"); } } 前置Log.java package log; import org.springframework.aop.MethodBeforeAdvice; import java.lang.reflect.Method; public class Log implements MethodBeforeAdvice { //method：要执行的目标对象的方法 //args：参数 //target：目标对象 public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(target.getClass().getName()+\"的\"+method.getName()+\"被执行了\"); } } 后置AfterLog.java package log; import java.lang.reflect.Method; import org.springframework.aop.AfterReturningAdvice; public class AfterLog implements AfterReturningAdvice { //returnVaule: 返回值 public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(\"执行了\"+method.getName()+\"方法，返回值是\"+returnValue); } } 测试类MyTest5 import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import service.UserService; public class MyTest5 { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //注意:动态代理代理的是接口 UserService userService = (UserService) context.getBean(\"userservice\"); userService.add(); } } 方法二：自定义类实现AOP \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!--注册bean--\u003e \u003cbean id=\"userservice\" class=\"service.UserServiceImpl\"/\u003e \u003cbean id=\"log\" class=\"log.Log\"/\u003e \u003cbean id=\"afterLog\" class=\"log.AfterLog\"/\u003e \u003c!-- 方式二，自定义 --\u003e \u003cbean id=\"diy\" class=\"diy.DiyPointcut\"/\u003e \u003caop:config\u003e \u003c!--自定义切面--\u003e \u003caop:aspect ref=\"diy\"\u003e \u003c!--切入点--\u003e \u003caop:pointcut id=\"point\" expression=\"execution(* service.UserServiceImpl.*(..))\"/\u003e \u003caop:before method=\"before\" pointcut-ref=\"point\"/\u003e \u003caop:after method=\"after\" pointcut-ref=\"point\"/\u003e \u003c/aop:aspect\u003e \u003c/aop:config\u003e \u003c/beans\u003e package diy; public class DiyPointcut { public void before(){ Sys","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:3","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"整合mybatis mybatis-spring官网：https://mybatis.org/spring/zh/ mybatis的配置流程： 编写实体类 编写核心配置文件 编写接口 编写Mapper.xmi 测试 ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:12:0","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"mybatis-spring-方式一 编写数据源配置 sqISessionFactory sqISessionTemplate（相当于sqISession） 需要给接口加实现类【new】 将自己写的实现类，注入到Spring中 测试！ 先导入jar包 \u003cdependencies\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.9.4\u003c/version\u003e \u003c/dependency\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring\u003c/artifactId\u003e \u003cversion\u003e2.0.4\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.12\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.12\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c!--在build中配置resources，来防止资源导出失败的问题--\u003e \u003c!-- Maven解决静态资源过滤问题 --\u003e \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resources\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e 编写顺序： User -\u003e UserMapper -\u003e UserMapper.xml -\u003e spring-dao.xml -\u003e UserServiceImpl -\u003e applicationContext.xml -\u003e MyTest6 代码步骤： pojo实体类 User package pojo; import lombok.Data; @Data public class User { private int id; private String name; private String pwd; } mapper目录下的 UserMapper、UserMapperImpl、UserMapper.xml 接口UserMapper package mapper; import java.util.List; import pojo.User; public interface UserMapper { public List\u003cUser\u003e getUser(); } UserMapperImpl package mapper; import java.util.List; import org.mybatis.spring.SqlSessionTemplate; import pojo.User; public class UserMapperImpl implements UserMapper{ //我们的所有操作，在原来都使用sqlSession来执行，现在都使用SqlSessionTemplate； private SqlSessionTemplate sqlSessionTemplate; public void setSqlSessionTemplate(SqlSessionTemplate sqlSessionTemplate) { this.sqlSessionTemplate = sqlSessionTemplate; } public List\u003cUser\u003e getUser() { UserMapper mapper = sqlSessionTemplate.getMapper(UserMapper.class); return mapper.getUser(); } } UserMapper.xml （狂神给面子才留下来的） \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003c!-- 绑定接口 --\u003e \u003cmapper namespace=\"mapper.UserMapper\"\u003e \u003cselect id=\"getUser\" resultType=\"pojo.User\"\u003e select * from mybatis.mybatis \u003c/select\u003e \u003c/mapper\u003e resource目录下的 mybatis-config.xml、spring-dao.xml、applicationContext.xml mybatis-config.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003c!--开启日志--\u003e \u003csettings\u003e \u003csetting name=\"logImpl\" value=\"STDOUT_LOGGING\" /\u003e \u003c/settings\u003e \u003c!--可以给实体类起别名 --\u003e \u003ctypeAliases\u003e \u003cpackage name=\"pojo\" /\u003e \u003c/typeAliases\u003e \u003c/configuration\u003e spring-dao.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!--DataSource:使用Spring的数帮源替换Mybatis的配置 其他数据源：c3p0、dbcp、druid 这使用Spring提供的JDBC: org.springframework.jdbc.datasource --\u003e \u003c!--data source --\u003e \u003cbean id=\"datasource\" class=\"org.springfr","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:12:1","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"mybatis-spring-方式二 UserServiceImpl2 package mapper; import pojo.User; import org.apache.ibatis.session.SqlSession; import org.mybatis.spring.support.SqlSessionDaoSupport; import java.util.List; //继承SqlSessionDaoSupport 类 public class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper { public List\u003cUser\u003e getUser() { SqlSession sqlSession = getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.getUser(); //或者一句话：return getSqlSession().getMapper(UserMapper.class).getUser(); } } spring-dao.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!--DataSource:使用Spring的数帮源替换Mybatis的配置 c3p0 dbcp druid 这使用Spring提供的JDBC: org.springframework.jdbc.datasource --\u003e \u003c!--data source --\u003e \u003cbean id=\"datasource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"\u003e \u003cproperty name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\" /\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/mybatis?useSSL=false\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;serverTimezone=Asia/Shanghai\"/\u003e \u003cproperty name=\"username\" value=\"root\" /\u003e \u003cproperty name=\"password\" value=\"root\" /\u003e \u003c/bean\u003e \u003c!--sqlSessionFactory--\u003e \u003cbean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003cproperty name=\"dataSource\" ref=\"datasource\" /\u003e \u003c!--绑定 mybatis 配置文件--\u003e \u003cproperty name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/\u003e \u003cproperty name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"/\u003e \u003c/bean\u003e \u003c!-- 方法二：SqlSessionTemplate 可以不写了--\u003e \u003c/beans\u003e applicationContext.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003cimport resource=\"spring-dao.xml\" /\u003e \u003c!-- 方法二 --\u003e \u003cbean id=\"userMapper2\" class=\"mapper.UserMapperImpl2\"\u003e \u003cproperty name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e 测试 public class MyTest6 { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserMapper userMapper = (UserMapper) context.getBean(\"userMapper2\"); for (User user : userMapper.getUser()) { System.out.println(user); } } } ","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:12:2","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"声明式事务 把一组业务当成一个业务来做；要么都成功，要么都失败！ 事务在项目开发中，十分的重要，涉及到数据的一致性问题 确保完整性和一致性 事务的ACID原则： 1、原子性 2、隔离性 3、一致性 4、持久性 ACID参考文章：https://www.cnblogs.com/malaikuangren/archive/2012/04/06/2434760.html Spring中的事务管理 声明式事务：AOP 编程式事务：需要再代码中，进行事务管理 声明式事务 先导入jar包 \u003cdependencies\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.9.4\u003c/version\u003e \u003c/dependency\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring\u003c/artifactId\u003e \u003cversion\u003e2.0.4\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.12\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.12\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c!--在build中配置resources，来防止资源导出失败的问题--\u003e \u003c!-- Maven解决静态资源过滤问题 --\u003e \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resources\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e 代码步骤： pojo实体类 User package pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @AllArgsConstructor @NoArgsConstructor public class User { private int id; private String name; private String pwd; } mapper目录下的 UserMapper、UserMapperImpl、UserMapper.xml 接口UserMapper package mapper; import java.util.List; import org.apache.ibatis.annotations.Param; import pojo.User; public interface UserMapper { public List\u003cUser\u003e getUser(); public int insertUser(User user); public int delUser(@Param(\"id\") int id); } UserMapperImpl package mapper; import pojo.User; import org.apache.ibatis.session.SqlSession; import org.mybatis.spring.support.SqlSessionDaoSupport; import java.util.List; public class UserMapperImpl extends SqlSessionDaoSupport implements UserMapper { public List\u003cUser\u003e getUser() { User user = new User(5,\"你好\",\"ok\"); insertUser(user); delUser(5); SqlSession sqlSession = getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.getUser(); //或者return getSqlSession().getMapper(UserMapper.class).getUser(); } //插入 public int insertUser(User user) { return getSqlSession().getMapper(UserMapper.class).insertUser(user); } //删除 public int delUser(int id) { return getSqlSession().getMapper(UserMapper.class).delUser(id); } } UserMapper.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003c!-- 绑定接口 --\u003e \u003cmapper namespace=\"mapper.UserMapper\"\u003e \u003cselect id=\"getUser\" resultType=\"pojo.User\"\u003e select * from mybatis.mybatis \u003c/select\u003e \u003cinsert id=\"insertUser\" parameterType=\"pojo.User\" \u003e insert into mybatis.mybatis (id,name,pwd) values (#{id},#{name},#{pwd}) \u003c/insert\u003e \u003cdelete id=\"delUser\" parameterType=\"_int\"\u003e deleteAAAAA from mybatis.mybatis where id = #{id} \u003c!-- deleteAAAAA是故意写错的 --\u003e \u003c/delete\u003e \u003c/mapper\u003e resource目录下的 mybatis-config.xml、spring-dao.xml、applicationContext.xml mybatis-config.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003c!-- configuration --\u003e \u003cconfiguration\u003e \u003c!--开启日志--\u003e \u003csettings\u003e \u003csetting name=\"logImpl\" value=\"STDOUT_LOGGING\" /","date":"2021-06-20","objectID":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:13:0","tags":["java","note","Spring"],"title":"Spring5 学习笔记","uri":"/spring5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["校园"],"content":"序 总有些事，有些景，有个人，值得你去留恋……聊以此文章来纪念一段我最后的大学校园时光。 ","date":"2021-05-26","objectID":"/%E4%B8%80%E6%AC%A1%E6%97%A5%E8%90%BD/:0:1","tags":["twilight"],"title":"一次日落","uri":"/%E4%B8%80%E6%AC%A1%E6%97%A5%E8%90%BD/"},{"categories":["校园"],"content":"2021.5.17 连续下了好多天的雨，早上终于出太阳了，随手拍的宿舍楼以及一朵可爱的云。阳光真好，连着心情都愉快了很多 ","date":"2021-05-26","objectID":"/%E4%B8%80%E6%AC%A1%E6%97%A5%E8%90%BD/:0:2","tags":["twilight"],"title":"一次日落","uri":"/%E4%B8%80%E6%AC%A1%E6%97%A5%E8%90%BD/"},{"categories":["校园"],"content":"2021.5.26 不知从何时起，开始喜欢一个人静静的看着日落，看夕阳把云霞染成淡粉，染成金黄，直到暮色一点一点蚕食天际，世界一片安静…… 只要我静静的看着它，似乎就可以安抚一切的负面情绪，有的只是坦荡与平和 这是我们楼层走廊尽头拍的，学校的后面。日暮真美，瑰丽而壮阔。 ","date":"2021-05-26","objectID":"/%E4%B8%80%E6%AC%A1%E6%97%A5%E8%90%BD/:0:3","tags":["twilight"],"title":"一次日落","uri":"/%E4%B8%80%E6%AC%A1%E6%97%A5%E8%90%BD/"},{"categories":["校园"],"content":"2021.6.11 最近看到一段话，莫名的鼓励了我，希望也鼓励了你。 我知道你最近很累，是那种看不见的，身体上和精神上的疲惫感，但是请你一定要坚持下去。 就算无人问津也好，技不如人也罢，千万别让烦躁和焦虑毁了你本就不多的热情和定力。 别贪心，我们不可能什么都有，也别灰心，我们不可能什么也没有。 明天加油 ，peace. ","date":"2021-05-26","objectID":"/%E4%B8%80%E6%AC%A1%E6%97%A5%E8%90%BD/:0:4","tags":["twilight"],"title":"一次日落","uri":"/%E4%B8%80%E6%AC%A1%E6%97%A5%E8%90%BD/"},{"categories":["Java"],"content":"数据表 现在有两张表，分别是Student和Teacher。两张表的id均为主键，而Student表中的tid为外键关联到了Teacher表的主键。如图： 相应的SQL语句 CREATETABLE`teacher`(`id`INT(10)NOTNULL,`name`VARCHAR(30)DEFAULTNULL,PRIMARYKEY(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8INSERTINTOteacher(id,NAME)VALUES(1,'秦老师');CREATETABLE`student`(`id`INT(10)NOTNULL,`name`VARCHAR(30)DEFAULTNULL,`tid`INT(10)DEFAULTNULL,PRIMARYKEY(`id`),KEY`fktid`(`tid`),CONSTRAINT`fktid`FOREIGNKEY(`tid`)REFERENCES`teacher`(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8INSERTINTO`student`(`id`,`name`,`tid`)VALUES(1,'小明',1);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(2,'小红',1);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(3,'小张',1);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(4,'小李',1);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(5,'小王',1); ","date":"2021-05-13","objectID":"/mybatis%E7%9A%84%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%9F%A5%E8%AF%A2/:0:1","tags":["MyBatis"],"title":"MyBatis的一对多，多对一查询","uri":"/mybatis%E7%9A%84%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%9F%A5%E8%AF%A2/"},{"categories":["Java"],"content":"多对一 通过学生表，查询授课老师，属于多对一的关系。 按照我的理解，SQL有如下两种方式书写 --第一种(子查询) selects.id,s.`name`,t.`name`fromstudents,teachertwheretid=(selectidfromteacher)--第二种 selects.id,s.`name`,t.`name`fromstudents,teachertwheres.tid=t.id; 图例： 那么在Mybatis中，写好了实体类与接口，该如何对应的写出相应的Mapper.xml。 为了连Teacher表，我们在建立实体类的时候，建了一个Teacher类，这样通过Teacher类可以方便的拿到表里面的数据。 按照查询嵌套处理 \u003cselect id=\"getStudent\" resultMap=\"StudentTeacher\"\u003e select * from mybatis.student \u003c/select\u003e \u003cresultMap id=\"StudentTeacher\" type=\"Student\"\u003e \u003cresult property=\"id\" column=\"id\"/\u003e \u003cresult property=\"name\" column=\"name\"/\u003e \u003cassociation property=\"teacher\" column=\"tid\" javaType=\"Teacher\" select=\"getTeacher\"/\u003e \u003c/resultMap\u003e \u003cselect id=\"getTeacher\" resultType=\"Teacher\"\u003e select *from mybatis.teacher where id = #{tid} \u003c/select\u003e 使用select进行学生数据表查询时，由于不是一个单一的对象，所以我们使用结果集映射resultMap而不是resultType。resultMap的属性值我们可以随意定义，接着对结果集的每一个字段与属性进行一一映射。colum就是数据库中的列名或名别。对于复杂的属性使用association进行配置，非常类似嵌套查询。 根据结果查询 \u003cselect id=\"getStudent2\" resultMap=\"StudentTeacher2\"\u003e select s.id sid,s.name sname,t.name tname,t.id tid from mybatis.student s,mybatis.teacher t where s.tid = t.id; \u003c/select\u003e \u003cresultMap id=\"StudentTeacher2\" type=\"Student\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003cassociation property=\"teacher\" javaType=\"Teacher\"\u003e \u003cresult property=\"name\" column=\"tname\"/\u003e \u003cresult property=\"id\" column=\"tid\"/\u003e \u003c/association\u003e \u003c/resultMap\u003e Teacher中的实体类 @Data public class Teacher { private int id; private String name; } Student中的实体类 @Data public class Student { private int id; private String name; //学生需要关联一个老师 private Teacher teacher; } ","date":"2021-05-13","objectID":"/mybatis%E7%9A%84%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%9F%A5%E8%AF%A2/:0:2","tags":["MyBatis"],"title":"MyBatis的一对多，多对一查询","uri":"/mybatis%E7%9A%84%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%9F%A5%E8%AF%A2/"},{"categories":["Java"],"content":"一对多 根据结果查询 \u003cselect id=\"getTeacher\" resultMap=\"TeacherStudent\"\u003e select s.id sid,s.name sname,t.name tname,t.id tid from mybatis.student s,mybatis.teacher t where s.tid = t.id and t.id = #{tid}; \u003c/select\u003e \u003cresultMap id=\"TeacherStudent\" type=\"Teacher\"\u003e \u003cresult property=\"id\" column=\"tid\"/\u003e \u003cresult property=\"name\" column=\"tname\"/\u003e \u003ccollection property=\"students\" ofType=\"Student\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003cresult property=\"tid\" column=\"tid\"/\u003e \u003c/collection\u003e \u003c/resultMap\u003e 按照查询嵌套处理 \u003c/select\u003e \u003cresultMap id=\"TeacherStudent\" type=\"Teacher\"\u003e \u003cresult property=\"id\" column=\"id\"/\u003e \u003ccollection property=\"students\" column=\"id\" javaType=\"ArrayList\" ofType=\"Student\" select=\"getStudentTeacherId\"/\u003e \u003c/resultMap\u003e \u003cselect id=\"getStudentTeacherId\" resultType=\"Student\"\u003e select * from mybatis.student where tid = #{tid} \u003c/select\u003e Teacher中的实体类 @Data public class Teacher { private int id; private String name; private List\u003cStudent\u003e students; } Student中的实体类 @Data public class Student { private int id; private String name; private int tid; ","date":"2021-05-13","objectID":"/mybatis%E7%9A%84%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%9F%A5%E8%AF%A2/:0:3","tags":["MyBatis"],"title":"MyBatis的一对多，多对一查询","uri":"/mybatis%E7%9A%84%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%9F%A5%E8%AF%A2/"},{"categories":["Java"],"content":"总结 各属性名的作用： column : 数据库中的列名，或者是列的别名 property: 映射到结果的字段或者属性 javaType: 一个java类的完全限定名 ofType:集合中的泛型信息 关联 - association 【多对一】 集合 - collection 【一对多】 javaType \u0026 ofType JavaType 用来指定实体类中的属性的类型 ofType 用来指定映射到List或者集合中的 pojo 类型，泛型中的约束类型 ","date":"2021-05-13","objectID":"/mybatis%E7%9A%84%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%9F%A5%E8%AF%A2/:0:4","tags":["MyBatis"],"title":"MyBatis的一对多，多对一查询","uri":"/mybatis%E7%9A%84%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%9F%A5%E8%AF%A2/"},{"categories":["Java"],"content":"Mybatis-9.28 环境： JDK1.8 Mysql 5.7 maven 3.6.1 IDEA 回顾： JDBC Mysql Java基础 Maven Junit SSM框架：配置文件的。 最好的方式：看官网文档； ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:1:0","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"1、简介 ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:2:0","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"1.1、什么是Mybatis MyBatis 是一款优秀的持久层框架 它支持定制化 SQL、存储过程以及高级映射。 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。 MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。 2013年11月迁移到Github。 如何获得Mybatis？ maven仓库： \u003c!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e Github ： https://github.com/mybatis/mybatis-3/releases 中文文档：https://mybatis.org/mybatis-3/zh/index.html ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:2:1","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"1.2、持久化 数据持久化 持久化就是将程序的数据在持久状态和瞬时状态转化的过程 内存：断电即失 数据库(Jdbc)，io文件持久化。 生活：冷藏. 罐头。 为什么需要需要持久化？ 有一些对象，不能让他丢掉。 内存太贵了 ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:2:2","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"1.3、持久层 Dao层，Service层，Controller层…. 完成持久化工作的代码块 层界限十分明显。 ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:2:3","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"1.4 为什么需要Mybatis？ 帮助程序猿将数据存入到数据库中。 方便 传统的JDBC代码太复杂了。简化。框架。自动化。 不用Mybatis也可以。更容易上手。 技术没有高低之分 优点： 简单易学 灵活 sql和代码的分离，提高了可维护性。 提供映射标签，支持对象与数据库的orm字段关系映射 提供对象关系映射标签，支持对象关系组建维护 提供xml标签，支持编写动态sql。 最重要的一点：使用的人多！ Spring SpringMVC SpringBoot ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:2:4","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"2、第一个Mybatis程序 思路：搭建环境–\u003e导入Mybatis–\u003e编写代码–\u003e测试！ ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:3:0","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"2.1、搭建环境 搭建数据库 CREATE DATABASE `mybatis`; USE `mybatis`; CREATE TABLE `user`( `id` INT(20) NOT NULL PRIMARY KEY, `name` VARCHAR(30) DEFAULT NULL, `pwd` VARCHAR(30) DEFAULT NULL )ENGINE=INNODB DEFAULT CHARSET=utf8; INSERT INTO `user`(`id`,`name`,`pwd`) VALUES (1,'狂神','123456'), (2,'张三','123456'), (3,'李四','123890') 新建项目 新建一个普通的maven项目 删除src目录 导入maven依赖 \u003c!--导入依赖--\u003e \u003cdependencies\u003e \u003c!--mysql驱动--\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.47\u003c/version\u003e \u003c/dependency\u003e \u003c!--mybatis--\u003e \u003c!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e \u003c!--junit--\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:3:1","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"2.2、创建一个模块 编写mybatis的核心配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003c!--configuration核心配置文件--\u003e \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"com.mysql.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true\u0026amp;useUnicode=true\u0026amp;characterEncoding=UTF-8\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"123456\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003c/configuration\u003e 编写mybatis工具类 //sqlSessionFactory --\u003e sqlSession public class MybatisUtils { private static SqlSessionFactory sqlSessionFactory; static{ try { //使用Mybatis第一步：获取sqlSessionFactory对象 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } //既然有了 SqlSessionFactory，顾名思义，我们就可以从中获得 SqlSession 的实例了。 // SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。 public static SqlSession getSqlSession(){ return sqlSessionFactory.openSession(); } } ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:3:2","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"2.3、编写代码 实体类 package com.kuang.pojo; //实体类 public class User { private int id; private String name; private String pwd; public User() { } public User(int id, String name, String pwd) { this.id = id; this.name = name; this.pwd = pwd; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPwd() { return pwd; } public void setPwd(String pwd) { this.pwd = pwd; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", pwd='\" + pwd + '\\'' + '}'; } } Dao接口 public interface UserDao { List\u003cUser\u003e getUserList(); } 接口实现类由原来的UserDaoImpl转变为一个 Mapper配置文件. \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003c!--namespace=绑定一个对应的Dao/Mapper接口--\u003e \u003cmapper namespace=\"com.kuang.dao.UserDao\"\u003e \u003c!--select查询语句--\u003e \u003cselect id=\"getUserList\" resultType=\"com.kuang.pojo.User\"\u003e select * from mybatis.user \u003c/select\u003e \u003c/mapper\u003e ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:3:3","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"2.4、测试 注意点： org.apache.ibatis.binding.BindingException: Type interface com.kuang.dao.UserDao is not known to the MapperRegistry. MapperRegistry是什么？ 核心配置文件中注册 mappers junit测试 @Test public void test(){ //第一步：获得SqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); //方式一：getMapper UserDao userDao = sqlSession.getMapper(UserDao.class); List\u003cUser\u003e userList = userDao.getUserList(); for (User user : userList) { System.out.println(user); } //关闭SqlSession sqlSession.close(); } 你们可以能会遇到的问题： 配置文件没有注册 绑定接口错误。 方法名不对 返回类型不对 Maven导出资源问题 ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:3:4","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"3、CRUD ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:4:0","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"1、namespace namespace中的包名要和 Dao/mapper 接口的包名一致！ ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:4:1","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"2、select 选择，查询语句; id : 就是对应的namespace中的方法名； resultType：Sql语句执行的返回值！ parameterType ： 参数类型！ 编写接口 //根据ID查询用户 User getUserById(int id); 编写对应的mapper中的sql语句 \u003cselect id=\"getUserById\" parameterType=\"int\" resultType=\"com.kuang.pojo.User\"\u003e select * from mybatis.user where id = #{id} \u003c/select\u003e 测试 @Test public void getUserById() { SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); sqlSession.close(); } ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:4:2","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"3、Insert \u003c!--对象中的属性，可以直接取出来--\u003e \u003cinsert id=\"addUser\" parameterType=\"com.kuang.pojo.User\"\u003e insert into mybatis.user (id, name, pwd) values (#{id},#{name},#{pwd}); \u003c/insert\u003e ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:4:3","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"4、update \u003cupdate id=\"updateUser\" parameterType=\"com.kuang.pojo.User\"\u003e update mybatis.user set name=#{name},pwd=#{pwd} where id = #{id} ; \u003c/update\u003e ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:4:4","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"5、Delete \u003cdelete id=\"deleteUser\" parameterType=\"int\"\u003e delete from mybatis.user where id = #{id}; \u003c/delete\u003e 注意点： 增删改需要提交事务！ ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:4:5","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"6、分析错误 标签不要匹配错 resource 绑定mapper，需要使用路径！ 程序配置文件必须符合规范！ NullPointerException，没有注册到资源! 输出的xml文件中存在中文乱码问题！ maven资源没有导出问题！ ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:4:6","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"7、万能Map 假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map！ //万能的Map int addUser2(Map\u003cString,Object\u003e map); \u003c!--对象中的属性，可以直接取出来 传递map的key--\u003e \u003cinsert id=\"addUser\" parameterType=\"map\"\u003e insert into mybatis.user (id, pwd) values (#{userid},#{passWord}); \u003c/insert\u003e @Test public void addUser2(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); Map\u003cString, Object\u003e map = new HashMap\u003cString, Object\u003e(); map.put(\"userid\",5); map.put(\"passWord\",\"2222333\"); mapper.addUser2(map); sqlSession.close(); } Map传递参数，直接在sql中取出key即可！ 【parameterType=“map”】 对象传递参数，直接在sql中取对象的属性即可！【parameterType=“Object”】 只有一个基本类型参数的情况下，可以直接在sql中取到！ 多个参数用Map，或者注解！ ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:4:7","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"8、思考题 模糊查询怎么写？ Java代码执行的时候，传递通配符 % % List\u003cUser\u003e userList = mapper.getUserLike(\"%李%\"); 在sql拼接中使用通配符！ select * from mybatis.user where name like \"%\"#{value}\"%\" ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:4:8","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"4、配置解析 ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:5:0","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"1、核心配置文件 mybatis-config.xml MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:5:1","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"2、环境配置（environments） MyBatis 可以配置成适应多种环境 不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。 学会使用配置多套运行环境！ Mybatis默认的事务管理器就是 JDBC ， 连接池 ： POOLED ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:5:2","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"3、属性（properties） 我们可以通过properties属性来实现引用配置文件 这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。【db.properties】 编写一个配置文件 db.properties driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis?useSSL=true\u0026useUnicode=true\u0026characterEncoding=UTF-8 username=root password=123456 在核心配置文件中映入 \u003c!--引入外部配置文件--\u003e \u003cproperties resource=\"db.properties\"\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"pwd\" value=\"11111\"/\u003e \u003c/properties\u003e 可以直接引入外部文件 可以在其中增加一些属性配置 如果两个文件有同一个字段，优先使用外部配置文件的！ ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:5:3","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"4、类型别名（typeAliases） 类型别名是为 Java 类型设置一个短的名字。‘ 存在的意义仅在于用来减少类完全限定名的冗余。 \u003c!--可以给实体类起别名--\u003e \u003ctypeAliases\u003e \u003ctypeAlias type=\"com.kuang.pojo.User\" alias=\"User\"/\u003e \u003c/typeAliases\u003e 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如： 扫描实体类的包，它的默认别名就为这个类的 类名，首字母小写！ \u003c!--可以给实体类起别名--\u003e \u003ctypeAliases\u003e \u003cpackage name=\"com.kuang.pojo\"/\u003e \u003c/typeAliases\u003e 在实体类比较少的时候，使用第一种方式。 如果实体类十分多，建议使用第二种。 第一种可以DIY别名，第二种则·不行·，如果非要改，需要在实体上增加注解 @Alias(\"user\") public class User {} ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:5:4","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"5、设置 这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:5:5","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"6、其他配置 typeHandlers（类型处理器） objectFactory（对象工厂） plugins插件 mybatis-generator-core mybatis-plus 通用mapper ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:5:6","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"7、映射器（mappers） MapperRegistry：注册绑定我们的Mapper文件； 方式一： 【推荐使用】 \u003c!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--\u003e \u003cmappers\u003e \u003cmapper resource=\"com/kuang/dao/UserMapper.xml\"/\u003e \u003c/mappers\u003e 方式二：使用class文件绑定注册 \u003c!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--\u003e \u003cmappers\u003e \u003cmapper class=\"com.kuang.dao.UserMapper\"/\u003e \u003c/mappers\u003e 注意点： 接口和他的Mapper配置文件必须同名！ 接口和他的Mapper配置文件必须在同一个包下！ 方式三：使用扫描包进行注入绑定 \u003c!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--\u003e \u003cmappers\u003e \u003cpackage name=\"com.kuang.dao\"/\u003e \u003c/mappers\u003e 注意点： 接口和他的Mapper配置文件必须同名！ 接口和他的Mapper配置文件必须在同一个包下！ 练习时间： 将数据库配置文件外部引入 实体类别名 保证UserMapper 接口 和 UserMapper .xml 改为一致！并且放在同一个包下！ ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:5:7","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"8、生命周期和作用域 生命周期，和作用域，是至关重要的，因为错误的使用会导致非常严重的并发问题。 SqlSessionFactoryBuilder： 一旦创建了 SqlSessionFactory，就不再需要它了 局部变量 SqlSessionFactory： 说白了就是可以想象为 ：数据库连接池 SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 因此 SqlSessionFactory 的最佳作用域是应用作用域。 最简单的就是使用单例模式或者静态单例模式。 SqlSession 连接到连接池的一个请求！ SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 用完之后需要赶紧关闭，否则资源被占用！ 这里面的每一个Mapper，就代表一个具体的业务！ ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:5:8","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"5、解决属性名和字段名不一致的问题 ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:6:0","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"1、 问题 数据库中的字段 新建一个项目，拷贝之前的，测试实体类字段不一致的情况 public class User { private int id; private String name; private String password; } 测试出现问题 // select * from mybatis.user where id = #{id} //类型处理器 // select id,name,pwd from mybatis.user where id = #{id} 解决方法： 起别名 \u003cselect id=\"getUserById\" resultType=\"com.kuang.pojo.User\"\u003e select id,name,pwd as password from mybatis.user where id = #{id} \u003c/select\u003e ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:6:1","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"2、resultMap 结果集映射 id name pwd id name password \u003c!--结果集映射--\u003e \u003cresultMap id=\"UserMap\" type=\"User\"\u003e \u003c!--column数据库中的字段，property实体类中的属性--\u003e \u003cresult column=\"id\" property=\"id\"/\u003e \u003cresult column=\"name\" property=\"name\"/\u003e \u003cresult column=\"pwd\" property=\"password\"/\u003e \u003c/resultMap\u003e \u003cselect id=\"getUserById\" resultMap=\"UserMap\"\u003e select * from mybatis.user where id = #{id} \u003c/select\u003e resultMap 元素是 MyBatis 中最重要最强大的元素 ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。 ResultMap 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。 如果世界总是这么简单就好了。 ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:6:2","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"6、日志 ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:7:0","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"6.1、日志工厂 如果一个数据库操作，出现了异常，我们需要排错。日志就是最好的助手！ 曾经：sout 、debug 现在：日志工厂！ SLF4J LOG4J 【掌握】 LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING 【掌握】 NO_LOGGING 在Mybatis中具体使用那个一日志实现，在设置中设定！ STDOUT_LOGGING标准日志输出 在mybatis核心配置文件中，配置我们的日志！ \u003csettings\u003e \u003csetting name=\"logImpl\" value=\"STDOUT_LOGGING\"/\u003e \u003c/settings\u003e ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:7:1","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"6.2、Log4j 什么是Log4j？ Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件 我们也可以控制每一条日志的输出格式； 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 先导入log4j的包 \u003c!-- https://mvnrepository.com/artifact/log4j/log4j --\u003e \u003cdependency\u003e \u003cgroupId\u003elog4j\u003c/groupId\u003e \u003cartifactId\u003elog4j\u003c/artifactId\u003e \u003cversion\u003e1.2.17\u003c/version\u003e \u003c/dependency\u003e log4j.properties #将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码 log4j.rootLogger=DEBUG,console,file #控制台输出的相关设置 log4j.appender.console = org.apache.log4j.ConsoleAppender log4j.appender.console.Target = System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout = org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n #文件输出的相关设置 log4j.appender.file = org.apache.log4j.RollingFileAppender log4j.appender.file.File=./log/kuang.log log4j.appender.file.MaxFileSize=10mb log4j.appender.file.Threshold=DEBUG log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n #日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG 配置log4j为日志的实现 \u003csettings\u003e \u003csetting name=\"logImpl\" value=\"\"/\u003e \u003c/settings\u003e Log4j的使用！，直接测试运行刚才的查询 简单使用 在要使用Log4j 的类中，导入包 import org.apache.log4j.Logger; 日志对象，参数为当前类的class static Logger logger = Logger.getLogger(UserDaoTest.class); 日志级别 logger.info(\"info:进入了testLog4j\"); logger.debug(\"debug:进入了testLog4j\"); logger.error(\"error:进入了testLog4j\"); ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:7:2","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"7、分页 思考：为什么要分页？ 减少数据的处理量 ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:8:0","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"7.1、使用Limit分页 语法：SELECT*fromuserlimitstartIndex,pageSize;SELECT*fromuserlimit3;#[0,n] 使用Mybatis实现分页，核心SQL 接口 //分页 List\u003cUser\u003e getUserByLimit(Map\u003cString,Integer\u003e map); Mapper.xml \u003c!--//分页--\u003e \u003cselect id=\"getUserByLimit\" parameterType=\"map\" resultMap=\"UserMap\"\u003e select * from mybatis.user limit #{startIndex},#{pageSize} \u003c/select\u003e 测试 @Test public void getUserByLimit(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); HashMap\u003cString, Integer\u003e map = new HashMap\u003cString, Integer\u003e(); map.put(\"startIndex\",1); map.put(\"pageSize\",2); List\u003cUser\u003e userList = mapper.getUserByLimit(map); for (User user : userList) { System.out.println(user); } sqlSession.close(); } ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:8:1","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"7.2、RowBounds分页 不再使用SQL实现分页 接口 //分页2 List\u003cUser\u003e getUserByRowBounds(); mapper.xml \u003c!--分页2--\u003e \u003cselect id=\"getUserByRowBounds\" resultMap=\"UserMap\"\u003e select * from mybatis.user \u003c/select\u003e 测试 @Test public void getUserByRowBounds(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); //RowBounds实现 RowBounds rowBounds = new RowBounds(1, 2); //通过Java代码层面实现分页 List\u003cUser\u003e userList = sqlSession.selectList(\"com.kuang.dao.UserMapper.getUserByRowBounds\",null,rowBounds); for (User user : userList) { System.out.println(user); } sqlSession.close(); } ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:8:2","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"7.3、分页插件 了解即可，万一 以后公司的架构师，说要使用，你需要知道它是什么东西！ ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:8:3","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"8、使用注解开发 ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:9:0","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"8.1、面向接口编程 - 大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程 - 根本原因 : ==解耦== , 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准 , 使得开发变得容易 , 规范性更好 - 在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了； - 而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。 关于接口的理解 - 接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。 - 接口的本身反映了系统设计人员对系统的抽象理解。 - 接口应有两类： - 第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)； - 第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）； - 一个体有可能有多个抽象面。抽象体与抽象面是有区别的。 三个面向区别 - 面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法 . - 面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 . - 接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构 ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:9:1","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"8.2、使用注解开发 注解在接口上实现 @Select(\"select * from user\") List\u003cUser\u003e getUsers(); 需要再核心配置文件中绑定接口！ \u003c!--绑定接口--\u003e \u003cmappers\u003e \u003cmapper class=\"com.kuang.dao.UserMapper\"/\u003e \u003c/mappers\u003e 测试 本质：反射机制实现 底层：动态代理！ Mybatis详细的执行流程！ ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:9:2","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"8.3、CRUD 我们可以在工具类创建的时候实现自动提交事务！ public static SqlSession getSqlSession(){ return sqlSessionFactory.openSession(true); } 编写接口，增加注解 public interface UserMapper { @Select(\"select * from user\") List\u003cUser\u003e getUsers(); // 方法存在多个参数，所有的参数前面必须加上 @Param(\"id\")注解 @Select(\"select * from user where id = #{id}\") User getUserByID(@Param(\"id\") int id); @Insert(\"insert into user(id,name,pwd) values (#{id},#{name},#{password})\") int addUser(User user); @Update(\"update user set name=#{name},pwd=#{password} where id = #{id}\") int updateUser(User user); @Delete(\"delete from user where id = #{uid}\") int deleteUser(@Param(\"uid\") int id); } 测试类 【注意：我们必须要讲接口注册绑定到我们的核心配置文件中！】 关于@Param() 注解 基本类型的参数或者String类型，需要加上 引用类型不需要加 如果只有一个基本类型的话，可以忽略，但是建议大家都加上！ 我们在SQL中引用的就是我们这里的 @Param() 中设定的属性名！ #{} ${} 区别 ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:9:3","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"9、Lombok Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java. Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more. java library plugs build tools with one annotation your class 使用步骤： 在IDEA中安装Lombok插件！ 在项目中导入lombok的jar包 \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.10\u003c/version\u003e \u003c/dependency\u003e 在实体类上加注解即可！ @Data @AllArgsConstructor @NoArgsConstructor @Getter and @Setter @FieldNameConstants @ToString @EqualsAndHashCode @AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor @Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger @Data @Builder @Singular @Delegate @Value @Accessors @Wither @SneakyThrows 说明： @Data：无参构造，get、set、tostring、hashcode，equals @AllArgsConstructor @NoArgsConstructor @EqualsAndHashCode @ToString @Getter ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:10:0","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"10、多对一处理 多对一： 多个学生，对应一个老师 对于学生这边而言， 关联 .. 多个学生，关联一个老师 【多对一】 对于老师而言， 集合 ， 一个老师，有很多学生 【一对多】 SQL： CREATETABLE`teacher`(`id`INT(10)NOTNULL,`name`VARCHAR(30)DEFAULTNULL,PRIMARYKEY(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8INSERTINTOteacher(`id`,`name`)VALUES(1,'秦老师');CREATETABLE`student`(`id`INT(10)NOTNULL,`name`VARCHAR(30)DEFAULTNULL,`tid`INT(10)DEFAULTNULL,PRIMARYKEY(`id`),KEY`fktid`(`tid`),CONSTRAINT`fktid`FOREIGNKEY(`tid`)REFERENCES`teacher`(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8INSERTINTO`student`(`id`,`name`,`tid`)VALUES('1','小明','1');INSERTINTO`student`(`id`,`name`,`tid`)VALUES('2','小红','1');INSERTINTO`student`(`id`,`name`,`tid`)VALUES('3','小张','1');INSERTINTO`student`(`id`,`name`,`tid`)VALUES('4','小李','1');INSERTINTO`student`(`id`,`name`,`tid`)VALUES('5','小王','1'); ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:11:0","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"测试环境搭建 导入lombok 新建实体类 Teacher，Student 建立Mapper接口 建立Mapper.XML文件 在核心配置文件中绑定注册我们的Mapper接口或者文件！【方式很多，随心选】 测试查询是否能够成功！ ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:11:1","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"按照查询嵌套处理 \u003c!-- 思路: 1. 查询所有的学生信息 2. 根据查询出来的学生的tid，寻找对应的老师！ 子查询 --\u003e \u003cselect id=\"getStudent\" resultMap=\"StudentTeacher\"\u003e select * from student \u003c/select\u003e \u003cresultMap id=\"StudentTeacher\" type=\"Student\"\u003e \u003cresult property=\"id\" column=\"id\"/\u003e \u003cresult property=\"name\" column=\"name\"/\u003e \u003c!--复杂的属性，我们需要单独处理 对象： association 集合： collection --\u003e \u003cassociation property=\"teacher\" column=\"tid\" javaType=\"Teacher\" select=\"getTeacher\"/\u003e \u003c/resultMap\u003e \u003cselect id=\"getTeacher\" resultType=\"Teacher\"\u003e select * from teacher where id = #{id} \u003c/select\u003e ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:11:2","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"按照结果嵌套处理 \u003c!--按照结果嵌套处理--\u003e \u003cselect id=\"getStudent2\" resultMap=\"StudentTeacher2\"\u003e select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid = t.id; \u003c/select\u003e \u003cresultMap id=\"StudentTeacher2\" type=\"Student\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003cassociation property=\"teacher\" javaType=\"Teacher\"\u003e \u003cresult property=\"name\" column=\"tname\"/\u003e \u003c/association\u003e \u003c/resultMap\u003e 回顾Mysql 多对一查询方式： 子查询 联表查询 ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:11:3","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"11、一对多处理 比如：一个老师拥有多个学生！ 对于老师而言，就是一对多的关系! ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:12:0","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"环境搭建 环境搭建，和刚才一样 实体类 @Data public class Student { private int id; private String name; private int tid; } @Data public class Teacher { private int id; private String name; //一个老师拥有多个学生 private List\u003cStudent\u003e students; } ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:12:1","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"按照结果嵌套处理 \u003c!--按结果嵌套查询--\u003e \u003cselect id=\"getTeacher\" resultMap=\"TeacherStudent\"\u003e select s.id sid, s.name sname, t.name tname,t.id tid from student s,teacher t where s.tid = t.id and t.id = #{tid} \u003c/select\u003e \u003cresultMap id=\"TeacherStudent\" type=\"Teacher\"\u003e \u003cresult property=\"id\" column=\"tid\"/\u003e \u003cresult property=\"name\" column=\"tname\"/\u003e \u003c!--复杂的属性，我们需要单独处理 对象： association 集合： collection javaType=\"\" 指定属性的类型！ 集合中的泛型信息，我们使用ofType获取 --\u003e \u003ccollection property=\"students\" ofType=\"Student\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003cresult property=\"tid\" column=\"tid\"/\u003e \u003c/collection\u003e \u003c/resultMap\u003e ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:12:2","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"按照查询嵌套处理 \u003cselect id=\"getTeacher2\" resultMap=\"TeacherStudent2\"\u003e select * from mybatis.teacher where id = #{tid} \u003c/select\u003e \u003cresultMap id=\"TeacherStudent2\" type=\"Teacher\"\u003e \u003ccollection property=\"students\" javaType=\"ArrayList\" ofType=\"Student\" select=\"getStudentByTeacherId\" column=\"id\"/\u003e \u003c/resultMap\u003e \u003cselect id=\"getStudentByTeacherId\" resultType=\"Student\"\u003e select * from mybatis.student where tid = #{tid} \u003c/select\u003e ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:12:3","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"小结 关联 - association 【多对一】 集合 - collection 【一对多】 javaType \u0026 ofType JavaType 用来指定实体类中属性的类型 ofType 用来指定映射到List或者集合中的 pojo类型，泛型中的约束类型！ 注意点： 保证SQL的可读性，尽量保证通俗易懂 注意一对多和多对一中，属性名和字段的问题！ 如果问题不好排查错误，可以使用日志 ， 建议使用 Log4j 慢SQL 1s 1000s 面试高频 Mysql引擎 InnoDB底层原理 索引 索引优化！ ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:12:4","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"12、动态 SQL ==什么是动态SQL：动态SQL就是指根据不同的条件生成不同的SQL语句== 利用动态 SQL 这一特性可以彻底摆脱这种痛苦。 动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。 if choose (when, otherwise) trim (where, set) foreach ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:13:0","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"搭建环境 CREATETABLE`blog`(`id`varchar(50)NOTNULLCOMMENT'博客id',`title`varchar(100)NOTNULLCOMMENT'博客标题',`author`varchar(30)NOTNULLCOMMENT'博客作者',`create_time`datetimeNOTNULLCOMMENT'创建时间',`views`int(30)NOTNULLCOMMENT'浏览量')ENGINE=InnoDBDEFAULTCHARSET=utf8 创建一个基础工程 导包 编写配置文件 编写实体类 @Data public class Blog { private int id; private String title; private String author; private Date createTime; private int views; } 编写实体类对应Mapper接口 和 Mapper.XML文件 ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:13:1","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"IF \u003cselect id=\"queryBlogIF\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog where 1=1 \u003cif test=\"title != null\"\u003e and title = #{title} \u003c/if\u003e \u003cif test=\"author != null\"\u003e and author = #{author} \u003c/if\u003e \u003c/select\u003e ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:13:2","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"choose (when, otherwise) \u003cselect id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cchoose\u003e \u003cwhen test=\"title != null\"\u003e title = #{title} \u003c/when\u003e \u003cwhen test=\"author != null\"\u003e and author = #{author} \u003c/when\u003e \u003cotherwise\u003e and views = #{views} \u003c/otherwise\u003e \u003c/choose\u003e \u003c/where\u003e \u003c/select\u003e ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:13:3","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"trim (where,set) select * from mybatis.blog \u003cwhere\u003e \u003cif test=\"title != null\"\u003e title = #{title} \u003c/if\u003e \u003cif test=\"author != null\"\u003e and author = #{author} \u003c/if\u003e \u003c/where\u003e \u003cupdate id=\"updateBlog\" parameterType=\"map\"\u003e update mybatis.blog \u003cset\u003e \u003cif test=\"title != null\"\u003e title = #{title}, \u003c/if\u003e \u003cif test=\"author != null\"\u003e author = #{author} \u003c/if\u003e \u003c/set\u003e where id = #{id} \u003c/update\u003e ==所谓的动态SQL，本质还是SQL语句 ， 只是我们可以在SQL层面，去执行一个逻辑代码== if where ， set ， choose ，when ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:13:4","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"SQL片段 有的时候，我们可能会将一些功能的部分抽取出来，方便复用！ 使用SQL标签抽取公共的部分 \u003csql id=\"if-title-author\"\u003e \u003cif test=\"title != null\"\u003e title = #{title} \u003c/if\u003e \u003cif test=\"author != null\"\u003e and author = #{author} \u003c/if\u003e \u003c/sql\u003e 在需要使用的地方使用Include标签引用即可 \u003cselect id=\"queryBlogIF\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cinclude refid=\"if-title-author\"\u003e\u003c/include\u003e \u003c/where\u003e \u003c/select\u003e 注意事项： 最好基于单表来定义SQL片段！ 不要存在where标签 ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:13:5","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"Foreach select*fromuserwhere1=1and\u003cforeachitem=\"id\"collection=\"ids\"open=\"(\"separator=\"or\"close=\")\"\u003e#{id}\u003c/foreach\u003e(id=1orid=2orid=3) \u003c!-- select * from mybatis.blog where 1=1 and (id=1 or id = 2 or id=3) 我们现在传递一个万能的map ， 这map中可以存在一个集合！ --\u003e \u003cselect id=\"queryBlogForeach\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cforeach collection=\"ids\" item=\"id\" open=\"and (\" close=\")\" separator=\"or\"\u003e id = #{id} \u003c/foreach\u003e \u003c/where\u003e \u003c/select\u003e ==动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了== 建议： 现在Mysql中写出完整的SQL,再对应的去修改成为我们的动态SQL实现通用即可！ ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:13:6","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"13、缓存 （了解） ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:14:0","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"13.1、简介 查询 ： 连接数据库 ，耗资源！ 一次查询的结果，给他暂存在一个可以直接取到的地方！--\u003e 内存 ： 缓存 我们再次查询相同数据的时候，直接走缓存，就不用走数据库了 什么是缓存 [ Cache ]？ 存在内存中的临时数据。 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。 为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率。 什么样的数据能使用缓存？ 经常查询并且不经常改变的数据。【可以使用缓存】 ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:14:1","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"13.2、Mybatis缓存 MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。 MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:14:2","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"13.3、一级缓存 一级缓存也叫本地缓存： SqlSession 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库； 测试步骤： 开启日志！ 测试在一个Sesion中查询两次相同记录 查看日志输出 缓存失效的情况： 查询不同的东西 增删改操作，可能会改变原来的数据，所以必定会刷新缓存！ 查询不同的Mapper.xml 手动清理缓存！ 小结：一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接这个区间段！ 一级缓存就是一个Map。 ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:14:3","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"13.4、二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于namespace级别的缓存，一个名称空间，对应一个二级缓存； 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中； 新的会话查询信息，就可以从二级缓存中获取内容； 不同的mapper查出的数据会放在自己对应的缓存（map）中； 步骤： 开启全局缓存 \u003c!--显示的开启全局缓存--\u003e \u003csetting name=\"cacheEnabled\" value=\"true\"/\u003e 在要使用二级缓存的Mapper中开启 \u003c!--在当前Mapper.xml中使用二级缓存--\u003e \u003ccache/\u003e 也可以自定义参数 \u003c!--在当前Mapper.xml中使用二级缓存--\u003e \u003ccache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/\u003e 测试 问题:我们需要将实体类序列化！否则就会报错！ Caused by: java.io.NotSerializableException: com.kuang.pojo.User 小结： 只要开启了二级缓存，在同一个Mapper下就有效 所有的数据都会先放在一级缓存中； 只有当会话提交，或者关闭的时候，才会提交到二级缓冲中！ ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:14:4","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"13.5、缓存原理 ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:14:5","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"13.6、自定义缓存-ehcache Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存 要在程序中使用ehcache，先要导包！ \u003c!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.caches\u003c/groupId\u003e \u003cartifactId\u003emybatis-ehcache\u003c/artifactId\u003e \u003cversion\u003e1.1.0\u003c/version\u003e \u003c/dependency\u003e 在mapper中指定使用我们的ehcache缓存实现！ \u003c!--在当前Mapper.xml中使用二级缓存--\u003e \u003ccache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/\u003e ehcache.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\" updateCheck=\"false\"\u003e \u003c!-- diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下： user.home – 用户主目录 user.dir – 用户当前工作目录 java.io.tmpdir – 默认临时文件路径 --\u003e \u003cdiskStore path=\"./tmpdir/Tmp_EhCache\"/\u003e \u003cdefaultCache eternal=\"false\" maxElementsInMemory=\"10000\" overflowToDisk=\"false\" diskPersistent=\"false\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"259200\" memoryStoreEvictionPolicy=\"LRU\"/\u003e \u003ccache name=\"cloud_user\" eternal=\"false\" maxElementsInMemory=\"5000\" overflowToDisk=\"false\" diskPersistent=\"false\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"1800\" memoryStoreEvictionPolicy=\"LRU\"/\u003e \u003c!-- defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。 --\u003e \u003c!-- name:缓存名称。 maxElementsInMemory:缓存最大数目 maxElementsOnDisk：硬盘最大缓存个数。 eternal:对象是否永久有效，一但设置了，timeout将不起作用。 overflowToDisk:是否保存到磁盘，当系统当机时 timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。 timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。 diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false. diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。 clearOnFlush：内存数量最大时是否清除。 memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。 FIFO，first in first out，这个是大家最熟的，先进先出。 LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。 LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。 --\u003e \u003c/ehcache\u003e Redis数据库来做缓存！ K-V ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:14:6","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"练习：29道练习题实战！ ","date":"2021-04-28","objectID":"/mybatis%E7%AC%94%E8%AE%B0/:15:0","tags":["java","note","MyBatis"],"title":"Mybatis笔记","uri":"/mybatis%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":"记录一下初学MyBatis的踩坑过程。。。。 鬼知道我经历了多少次绝望。。。调试了快三天，终于搞定了第一个MyBatis程序，都是配置惹的祸。。 注意点： 我使用的是jdk1.8+IDEA2020。 Maven 版本3.6.1。 依赖版本： \u003c!--导入依赖--\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.49\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 此处经历过绝望。。。。mysql驱动一定要选5.1.49版本的。46,47版的都不行，运行后打印数据库会出现乱码。49版本的useSSl一定要设置为false，否则会一直跳出警告，如果不填则默认为true。我人直接裂开。。。 关于mybatis-congfig.xml的配置： 在xml文档中;需要转义，只能填写\u0026amp;,等价于;。 一定要写\u003cmappers\u003e，否则会一直报错，提示没有把接口和类绑定。 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"com.mysql.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=false\u0026amp;useUnicode=true\u0026amp;characterEncoding=UTF-8\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"123456\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003cmapper resource=\"com/lone/dao/UserMapper.xml\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e 关于Maven的资源过滤问题： 在测试类中，有些main或java下的配置文件写不进去。需要放行。 在.pom中加入以下代码： \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resources\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003etrue\u003c/filtering\u003e \u003c/resource\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003etrue\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e 哭了，坑都快被我踩塌了。😭 ","date":"2021-04-23","objectID":"/mybatis%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91%E8%AE%B0/:0:0","tags":["MyBatis"],"title":"MyBatis配置踩坑记","uri":"/mybatis%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91%E8%AE%B0/"},{"categories":["Python"],"content":"前言 逛吾爱论坛发现有个文字转语音的软件非常火。题者说爬的是收费的接口，下载下来试了一下，震惊了，，语音效果非常棒，很接近人声。但是软件是用易语言写的，而且作者也没有开源，我也不知道他是咋实现的。导致对接口就更好奇了。 ","date":"2021-04-18","objectID":"/%E6%96%87%E5%AD%97%E8%BD%AC%E8%AF%AD%E9%9F%B3demo/:0:1","tags":["python"],"title":"文字转语音demo","uri":"/%E6%96%87%E5%AD%97%E8%BD%AC%E8%AF%AD%E9%9F%B3demo/"},{"categories":["Python"],"content":"获得接口 这里使用HTTPDebugger来抓取此软件对外发送的数据请求。我们发现接口的url在电脑端是打不开的，F12模拟手机也一样。于是我们观察请求头，发现有很多的参数，比如referer，host，cookie，UA等等，经过测试，这些参数都必须使用才能正确访问此接口。访问会发现提示参数不正确，我们继续观察这个软件的post请求发送的内容req=····后面的内容是使用url编码的。 我们把他复制下来，随便找个解码网站试一下，解码就是一段json数据。具体参数内容还有待研究，先放一放。观察json有个字段是text，对应的就是我们输入的文字，那就好办了，传入text，编码，发送请求，解析响应。在响应中有url字段，就是我们需要的下载链接。后台响应处理的速度还是很快的。拿到链接，下载就大功告成了。 ","date":"2021-04-18","objectID":"/%E6%96%87%E5%AD%97%E8%BD%AC%E8%AF%AD%E9%9F%B3demo/:0:2","tags":["python"],"title":"文字转语音demo","uri":"/%E6%96%87%E5%AD%97%E8%BD%AC%E8%AF%AD%E9%9F%B3demo/"},{"categories":["Python"],"content":"代码实现 import requests import urllib import re import time def get_data(text): json = { \"qd\": \"110774\", \"ver\": \"010178\", \"zbid\": \"4b1ab4d1db435532\", \"text\": text, \"speed\": 0, \"pitch\": 0, \"volume\": 95, \"isurl\": 2, \"viptype\": \"0\", \"bgdelaytime\": 0, \"textdelaytime\": 0, \"bgvolume\": 20, \"emotion\": \"\", \"emotiondegree\": 50, \"opertype\": \"1001\" } str_json=str(json).replace('\\'','\\\"') info = urllib.parse.quote(str_json) data = \"req=\" + info return data def get_json(data): url = \"\" ##接口就不放了。。。 headers = { \"Referer\": \"https://servicewechat.com/wx976547f8ab927081/6/page-frame.html\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 \" \"Safari/537.36 MicroMessenger/7.0.9.501 NetType/WIFI MiniProgramEnv/Windows WindowsWechat\", \"Host\": \"pysq.shipook.com\", \"Cookie\": \"SESSION=YTcyNmU3NmYtZmNkYy00N2IwLTg3YzEtMGRlZWQxMTZlMjUy\", \"Content-Type\": \"application/x-www-form-urlencoded\", \"Accept\": \"text/html, application/xhtml+xml, */*\", \"Accept-Encoding\": \"gzip, deflate\", \"Accept-Language\": \"zh-cn\", \"Cache-Control\": \"no-cache\", \"Connection\": \"Keep-Alive\", \"Content-Length\": \"401\", } res = requests.post(url, headers=headers, data=data, verify=False).text url = re.findall('\"audiourl\":\"(.*?)\"',res)[0] # print(url) return url def down_url(url): headers ={\"User-Agent\":\"Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, \" \"like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1\"} res = requests.get(url,headers=headers).content with open(\".mp3\",'ab') as f: f.write(res) print(\"在当前目录下已经下载成功！\") if __name__ == '__main__': text = input(\"请输入你想转成语音的文字，按回车结束:\\n\") print(\"==================\") print(text) print(\"==================\") print(\"马上就好，请等待下载。。。。\") time.sleep(3) data = get_data(text) url = get_json(data) down_url(url) ","date":"2021-04-18","objectID":"/%E6%96%87%E5%AD%97%E8%BD%AC%E8%AF%AD%E9%9F%B3demo/:0:3","tags":["python"],"title":"文字转语音demo","uri":"/%E6%96%87%E5%AD%97%E8%BD%AC%E8%AF%AD%E9%9F%B3demo/"},{"categories":["Python"],"content":"总结 由于是从别人开发的软件上抓的接口，所以功能比较局限，很多的参数意义不明。 url转码的问题：导入urllib库，使用urllib.parse.quote()方法把字符串进行url编码。 下午做了一个签到的云函数，里面有个unicode编码转str的。res.encode().decode('unicode_escape') 下载的时候使用ab方法写入，如果下载的文件名相同，不会进行覆盖写入，而是接着原来的继续写入。 代码写的很简陋，马马虎虎，不忍直视。 ","date":"2021-04-18","objectID":"/%E6%96%87%E5%AD%97%E8%BD%AC%E8%AF%AD%E9%9F%B3demo/:0:4","tags":["python"],"title":"文字转语音demo","uri":"/%E6%96%87%E5%AD%97%E8%BD%AC%E8%AF%AD%E9%9F%B3demo/"},{"categories":["爬虫"],"content":"前言 一切因为昨天晚上无意间打开了易班APP。 里面有个轻应用可以直接提交补助申请，点进去看了一眼，发现页面有交互功能（因为以前在易班工作，知道这玩意光凭易班自带的轻应用模块肯定做不了），很好奇是哪位大神做的。于是很快啊，我啪的一下就点进去了，发现登陆之后随便点一个表格，会自动补全很多个人信息。我靠！！！这么强的吗，不会是直接对接学校数据库的吧。赶紧看看。 ","date":"2021-04-05","objectID":"/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/:0:1","tags":["mysql","python"],"title":"记录一次本地数据库的制作","uri":"/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/"},{"categories":["爬虫"],"content":"拿到接口地址 刚刚登陆的时候，发现只需要填写姓名跟学号就可以了。但是随便选一个表格却可以补全很多信息，包括，班级，学院，身份证号，出生日期等等。按照这个思路，它应该是提交了你填写的登录表单信息，在服务器进行比对，正确会跳转页面，给你拿到其余信息。 妙就妙在易班的页面有分享功能，这样我们可以直接拿到这个东西的网址。 好家伙，果然是学校的服务器。在浏览器中打开，无法访问，F12手机端模拟一下可以打开了。 很轻易的，可以拿到接口地址，模拟请求一下，发现返回了一段json数据，仔细观察，全部都是我们想要的信息。 ","date":"2021-04-05","objectID":"/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/:0:2","tags":["mysql","python"],"title":"记录一次本地数据库的制作","uri":"/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/"},{"categories":["爬虫"],"content":"遍历数据库 我们发现，这样拿到的json数据是自己的。因为我们登陆的是自己的账号。 那么我们只要有其他人的姓名跟学号，那么不就可以把数据从服务器里面遍历出来了吗。 巧的是，我确实有一部分学号+姓名的Excel数据。于是活来了，考虑使用pandas库，解析Excel，拼接参数。发送请求，下载json。 import requests import re import pandas as pd def get_ns(): df = pd.read_excel(\"......xlsx\") # print(df) info = df.values print(f\"++++++++++++本次下载一共用{len(info)}条数据+++++++++++\") # print(info) return info def get_json(name, studentNo,count): url = \"https://eclass.wendaedu.com.cn:6006/XXXXX\" headers = { \"User-Agent\": \"Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1\"} data = {\"studentName\": name, \"studentNo\": studentNo} res = requests.post(url, headers=headers, data=data).text if len(res)\u003c50: print(f'学号 {studentNo}的信息有误，无法查询！！！') else: title_no = re.findall('\"loginname\":\"(.*?)\",',res)[0] title_class = re.findall('\"classes\":\"(.*?)\",',res)[0] # with open(f'school/{title_class}--{title_no}.json','w',encoding=\"utf-8\") as f: # f.write(res) print(f\"======\u003e{studentNo}信息保存成功！\") if __name__ == '__main__': count = 0 for i in get_ns(): studentNo = str(i[2]) name = str(i[0]) print(f\"{name}-{studentNo}开始下载======\u003e\") get_json(name,studentNo,count) 这样，其实我们的信息都拿到了，最后解析每一个json，就可以拿到数据。 ","date":"2021-04-05","objectID":"/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/:0:3","tags":["mysql","python"],"title":"记录一次本地数据库的制作","uri":"/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/"},{"categories":["爬虫"],"content":"尝试构建一个本地数据库 当然，这并没有完，最近学了数据库，肯定要尝试一下能不能自己弄个本地的小数据库。思路很简单，遍历所有json文件，并解析字段作为表头，然后使用SQL语句插入数据就可以了。附上部分代码： classes = temp[\"classes\"] # 班级 stuno = temp[\"loginUser\"][\"loginname\"] # 学号 name = temp[\"loginUser\"][\"name\"] # 姓名 gender = temp[\"loginUser\"][\"gender\"] # 性别 politicalstatus = temp[\"loginUser\"][\"politicalStatus\"] # 政治面貌 nation = temp[\"loginUser\"][\"nation\"] # 民族 education = temp[\"loginUser\"][\"education\"] # 学历 phone = temp[\"loginUser\"][\"phone\"] # 联系方式 biogenicland = temp[\"loginUser\"][\"biogenicland\"] # 生源地 idno = temp[\"loginUser\"][\"idno\"] # 身份证号码 instructor = temp[\"loginUser\"][\"instructor\"] # 辅导员姓名 major = temp[\"major\"] # 专业 grade = temp[\"grade\"] # 年级 department = temp[\"department\"] # 学院 no = temp[\"loginUser\"][\"no\"] # 考生号 admissionDate = temp[\"loginUser\"][\"admissionDate\"] # 入学日期 email = temp[\"loginUser\"][\"email\"] # 电子邮件 address = temp[\"loginUser\"][\"address\"] # 家庭住址 homephone = temp[\"loginUser\"][\"homephone\"] # 联系人电话 bankcardnumber = temp[\"loginUser\"][\"bankcardnumber\"] # 银行卡号 id = temp[\"loginUser\"][\"id\"] # 用户唯一ID collegeid = temp[\"loginUser\"][\"collegeId\"] # 学校ID periodId = temp[\"loginUser\"][\"periodId\"] # 时期ID majorId = temp[\"loginUser\"][\"majorId\"] # 专业ID classId = temp[\"loginUser\"][\"classId\"] # 班级ID 竟然有这么多字段，手都要敲断了，有些字段的值为空。 db = pymysql.connect(\"localhost\",\"root\",\"123456\",\"wenda\",charset=\"utf8\") cursor = db.cursor() # cursor.execute(\"use wenda\") # 使用 wenda 这个数据库 try: sql = f\"insert into wenda.student (id,classes,stuno,name,gender,politicalstatus,nation,education,phone,idno,biogenicland,instructor,major,grade,department,no,admissionDate,email,address,homephone,bankcardnumber,collegeid,periodId,majorId,classId)values\\ ('{id}','{classes}','{stuno}','{name}','{gender}','{politicalstatus}','{nation}','{education}','{phone}','{idno}','{biogenicland}','{instructor}','{major}','{grade}','{department}','{no}','{admissionDate}','{email}','{address}','{homephone}','{bankcardnumber}','{collegeid}','{periodId}','{majorId}','{classId}')\" cursor.execute(sql) db.commit() except Exception as e: print('Insert Failed') db.commit() cursor.close() db.close() 套个循环，最终得到了10525条数据。 ","date":"2021-04-05","objectID":"/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/:0:4","tags":["mysql","python"],"title":"记录一次本地数据库的制作","uri":"/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/"},{"categories":["爬虫"],"content":"成果 到最后一刻，还是很激动人心的。完结撒花。 最后的最后。。。。（几个小时之后） 发现这个域名是给易班用的。我曾经还用过这个后台，上传过数据。。。如今，我再通过接口爬下来，再做成数据库。。。。？？？这是什么鬼操作？？ ","date":"2021-04-05","objectID":"/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/:0:5","tags":["mysql","python"],"title":"记录一次本地数据库的制作","uri":"/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/"},{"categories":["软考笔记"],"content":"软考笔记 ","date":"2021-03-28","objectID":"/%E8%BD%AF%E8%80%83%E7%AC%94%E8%AE%B0/:0:0","tags":["笔记","网络工程"],"title":"软考笔记","uri":"/%E8%BD%AF%E8%80%83%E7%AC%94%E8%AE%B0/"},{"categories":["软考笔记"],"content":"计算机基础理论与安全 ","date":"2021-03-28","objectID":"/%E8%BD%AF%E8%80%83%E7%AC%94%E8%AE%B0/:1:0","tags":["笔记","网络工程"],"title":"软考笔记","uri":"/%E8%BD%AF%E8%80%83%E7%AC%94%E8%AE%B0/"},{"categories":["软考笔记"],"content":"网络安全 MAcro.xxx，表明是宏病毒，主要感染目标是Word或Excel文件。 Worm. xxx，蠕虫病毒，通过网络或漏洞进行自主传播，向外发送带毒的邮件或通过及时通讯工具（QQ，MSN）发送带病毒的文件。 Trojan.xxx，木马，木马通常伪装成有用的程序诱骗用户主动激活，或利用系统漏洞入侵用户计算机。计算机感染特洛伊木马之后的典型表现就是有未知的程序试图建立网路连接。 Win32、PE、 文件型病毒。感染可执行文件（如exe, .com, .dll等。 Win95,w32,w95 或系统病毒。若与其他前缀连用，则表示病毒的运行平台。（如Backdoor.Win32.PcClient.al，表示运行在32为Windows平台上的后门。） 在 公钥体系中，私钥用于解密和签名，公钥用于加密和验证。 数字签名的基本过程如下: (1) A使用\"摘要\"算法(如SHA-1、MD5等)对发送信息进行摘要。 (2) 使用A的私钥对消息摘要进行加密运算，将加密摘要和原文一并发给B验证签名的基本过程: B接收到加密摘要和原文后，使用和A同样的\"摘要\"算法对原文再次摘要，生成新摘要。 使用A公钥对加密摘要解密,还原成原摘要。 (3) 两个摘要对比，一致则说明由A发出且没有经过任何复改。由此可见，数字签名功能有信息身份认证、信息完整性检查、信息发送不可否认性，但不提供原文信息加密，不能保证对方能收到消息，也不对接收方身份进行验证。 Kerberos 是一种网络认证协议。它采用的加密算法是DES。 **物理安全：**机房安全；**网络安全：**入侵检测；**应用安全：**数据库安全；**系统安全：**漏洞补丁。 SMTP协议和POP协议是邮件服务器的两个重要协议。SMTP协议用于邮件的发送，端口是25。POP/POP3协议用于邮件的接收，端口是110。Foxmail是一种常用的桌面邮件客户端，使用该软件时，需设置相应的发送邮件服务器和接收邮件服务器地址。 主动攻击包含攻击者访问他所需信息的故意行为。 重放攻击(Replay Attacks)又称重播攻击、回放攻击或新鲜性攻击(Freshness Attacks)，是指攻击者发送一个目的主机已接收过的包， 特别是在认证的过程 中，用于认证用户身份所接收的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的安全性。 IP地址欺骗是指行动产生的IP数据包为伪造的源IP地址，以便冒充其他系统或发件人的身份。 拒绝服务攻击只要能够对目标造成麻烦，使某些服务被暂停甚至主机死机，都属于拒绝服务攻击。 CSMA/CD (Carrier Sense Multiple Access with Collision Detection)即带冲突检测的载波监听多路访问技术(载波监听多点接入/碰撞检测)。 它的工作原理是: 在发送数据前，先监听总线是否空闲。若总线忙，则不发送。若总线空闲，则把准备好的数据发送到总线上。在发送数据的过程中，工作站边发送边检测总线，是否自己发送的数据有冲突。若无冲突则继续发送直到发完全部数据;若有冲突，则立即停止发送数据，但是要发送个加强冲突的JAM信号， 以便使网络上所有工作站都知道网 上发生了冲突，然后，等待一个预定的随机时间，且在总线为空闲时，再重新发送未发完的数据。 CSMA/CD的基本原理为一边发送，一边监听，一旦冲突立即后退停止，因此冲突越多，后退的时间越长，当通信负载越大，冲突更容易发生，因此后退的次数与时延平均值与负载相关，当重传16次不成功，就丢弃该帧，传输失败。 以太网中出现冲突后，发送方什么时候可以再次尝试发送? 在JAM信号停止并等待一段随机时间后。 IPSec 用于增强 IP 网络的安全性。在传输模式下，IPsec报头增加在原IP包头和数据之间，在整个传输层报文段的后面和签名添加一些控制字段，构成IPsec数据报。隧道模式是对整个IP数据包提供安全传输机制。是在一个IP数据报的后面和前面都添加一些控制字段，构成IPsec数据报。 在建立TCP连接的过程中， SYN：对顺序号进行同步，用于连接的建立。 RST：连接复位为初始状态，用于连接故障后的恢复。 FIN：数据发送完，连接可以释放。 ACK：应答顺序号有效。 当发现主机受到ARP攻击时需清除ARP缓存，使用的命令是 arp-d 。arp-s 网关ip地址/网关MAC地址 命令来静态绑定。 直通交换，存在坏帧传播的风险。 采用CSMA/CD协议的基带总线，段长为1000M，数据速率为10Mb/s，信号传播速度为200m/us， 则该网络上的最小帧长应为多少比特。 解：简单计算即可，确保发送时间=两倍端到端的传播时间。 设帧长为Xbit。数据速率为10Mb/s=10bit/us 则 发送时间为t = xbit/(10bit/us)=x/10us。 两倍端到端的传播时间为T = 2*(1000m/200m/us)=10us t = T 解得，X= 100bit 入侵检测的常用的检测方法有: **模式匹配法：**是常常被用于入侵检测技术中。它是通过把收集到的信息与网络入侵和系统误用模式数据库中的已知信息进行比较，从而对违背安全策的行为进行发现。模式匹配法可以显著地减少系统负担，有较高的检测率和准确率。 **专家系统法：**这个方法的思想是把安全专家的知识表示成规则知识库，再用推理算法检测入侵。主要是针对有特征的入侵行为。 **基于状态转移分析的检测法：**该方法的基本思想是将攻击看成一一个连续的、分步骤的并且各个步骤之间有一-定的关联的过程。 而漏洞扫描不是。 3.28日 做到第20题。 按总线争用协议来分类，CSMA有3 种类型的监听算法: 非坚持CSMA。 一个站点在发送数据帧之前，先要对媒体进行检测。如果没有其它站点在发送数据，则该站点开始发送数据。如果媒体被占用，则该站点不会持续监听媒体，而等待一个随机的延迟时间之后再监听。采用随机的监听延迟时间可以减少冲突的可能性，但其缺点也是很明显的:即使有多个站点有数据要发送，因为此时所有站点可能都在等待各自的随机延迟时间，而媒体仍然可能处于空闲状态，这样就使得媒体的利用率较为低下。 1-坚持CSMA。 当一个站点要发送数据帧时，它就监听媒体，判断当前时刻是否有其他站点正在传输数据。如果媒体忙的话，该站点等待直至媒体空闲。一旦该站点检测到媒体空闲，它就立即发送数据帧。如果产生冲突，则等待一个随机时间再监听。 之所以叫“1-坚持”，是因为当一个站点发现媒体空闲的时候， 它传输数据帧的概率是1。1-坚持CSMA的优点是:只要媒体空闲，站点就立即发送;它的缺点在于:假如有两个或两个以上的站点有数据要发送，冲突就不可避免。 P-坚持CSMA。 P-坚持CSMA是非坚持CSMA和1-坚持CSMA的折中。P-坚持CSMA应用于划分时槽的媒体，其工作过程如下:当一个站点要发送数据帧的时候，它先检测媒体。若媒体空闲，则该站点按照概率P的可能性发送数据，而有1-P的概率会把要发送数据帧的任务延迟到下一个时槽。按照这样的规则，若下一个时槽也是空闲的，则站点同样有P的概率发送数据帧。 网络加密的方式有四种： 链路加密：是在数据链路层加密，通信设备需要安装特殊的安全单元。 端-端加密：是把加密设备放在网络层和传输层之间，只加密传输层的数据单元，数据在发送端进行加密，到达接收端才解密，中间节点不参与加解密过程。 节点加密：时，节点中的数据是 以密文形式存在，但要求在每个节点加装安全单元，需要公共网络提供配合 混合加密： 数字证书采用公钥体制进行加密和解密。X.509数字证书中的签名字段是指发证机构对用户证书的签名。来自不同CA的用户如果需要进行验证，安全通信的话，需要通过CA之间的证书链进行。 RMON MIB组织成很多功能组，其中: 警报组(Alarm) :设置一定的时间间隔和报警阈值，定期从探测器的采样并与所设置的阈值相比较。 事件组(Event) :提供关于RMON代理所产生的所有事件。 主机组(Host) :包括网络上发现的与每个主机相关的统计值。 过滤组(Filter) :允许监视器观测符合一定过滤条件的数据包。由于捕获数据包需要识别数据包，那么就必须有过滤器(Filter)的支持。 IDEA在密码学中属于数据块加密算法，IDEA的明文和密文均为64位，密钥长度为128位。还要注意典型的Des的相关参数，还有md5, sha-1的输出位数等，都是一个知识点的概念。 典型的公钥密码体制有RSA、DSA、ECC。 常见的对称加密算法有DES、3DES、RC5、IDEA。 MD5：消息摘要算法。把信息分为512bit的分组， 并且创建一个128bit的摘要。注意==\u003eMD5是摘要算法，用于验证数据的完整性，并没有数据加密功能。 SHA-1：安全Hash算法。 也是基于MD5的，使用一个标准把信息分为512bit的分组，并且创建一个160bit的摘要。 RSA： (Rivest Shamir Adleman)是典型的非对称加密(公开)算法，该算法基于大素数分解。RSA适合进行数字签名和密钥交换运算。在非对称加密算法中，私钥用于解密和签名，公钥用于加密和认证。 DES：对称加密算法。DES明文分为64位一组， 密钥64位(实际位是56位的密钥和8位奇偶校验) .注意:考试中填实际密钥位即56位。 3DES: 3DES是DES的扩展，是执行了三次的DES。其中，第一、三次加密使用同一密钥的方式下，密钥长度扩展到128位(112位有效) ;第三次加密使用不同密钥，密钥长度扩展到192位(168位有效) 软考中对3DE","date":"2021-03-28","objectID":"/%E8%BD%AF%E8%80%83%E7%AC%94%E8%AE%B0/:1:1","tags":["笔记","网络工程"],"title":"软考笔记","uri":"/%E8%BD%AF%E8%80%83%E7%AC%94%E8%AE%B0/"},{"categories":["软考笔记"],"content":"网络基础理论与安全 ","date":"2021-03-28","objectID":"/%E8%BD%AF%E8%80%83%E7%AC%94%E8%AE%B0/:2:0","tags":["笔记","网络工程"],"title":"软考笔记","uri":"/%E8%BD%AF%E8%80%83%E7%AC%94%E8%AE%B0/"},{"categories":["软考笔记"],"content":"网络体系结构 循环冗余校验用于检错，不能自动纠正错误和重新生成数据。通常的做法可以丢弃自动请求重发和报告上层协议，关键在于使用CRC的这个协议是什么性质。如果是无连接的则丢弃，面向连接可靠的则请求重发。 OSI模型与TCP/IP模型 与其它网络安全技术相比，IDS（入侵检测系统）的最大特点是不能发现内部误操作。 关于ip地址中单播地址的计算： 所谓单播地址就是能分配给主机使用的ip地址，一个网段中，除了网络地址和广播地址之外的地址都是单播地址。 关于IP地址的一些知识： IP地址的构成： IP地址 = 网络号段 + 主机号段 ​ = 网络号段 +（子网号段 + 子网主机号段） xx.xx.xx.xx ==\u003e IPV4 由四个字节组成，每个字节8位二进制数，故IP地址由32位二进制数组成。 网络号： 网络号就是常说的A类地址，B类地址，C类地址，D类地址，E类地址，由IP地址中的前数位构成。 A类地址：8位网络号(0开头）+24位主机号，范围：1.0.0.0 - 126.255.255.255 B类地址：16位网络号（10开头）+16位主机号，范围：128.0.0.0 - 191.255.255.255 C类地址：24位网络号（110开头）+8位主机/号，范围：192.0.0.0 - 223.255.255.255 D类：组播地址，范围：224.0.0.0 - 239.255.255.255 E类：保留以后再用，范围：240.0.0.0 - 255.255.255.255 注意： 1. 网络号不能全部为0或者全部为1。\r2. ip地址也不能全部为0或全部为1。\r3. 其中的D、E类地址被分别被用作**组播地址、实验地址**\r4. 在以上点分十进制的IP地址段中没有**127.0.0.0**/8这个网段，因为该网段被用作**环回地址**。\r 主域名服务器。辅助域名服务器。转发域名服务器。 在进行域名解析的时候，当主域名服务器找不到地址时，由转发域名服务器负责域名解析。当主域名服务器停止时，辅助域名服务器来提供服务。 进度安排的常用图形： PERT图是一个有向图。 GANTT图是一个水平条状图。 PERT图（工程网络图）案例： TCP的三次握手和四次挥手 在建立TCP连接过程中，出现错误连接时，RST标志字段置“1”。 2021.4.7 距离考试还有52天。:happy:加油！ 星型拓扑存在中心节点。 网状拓扑是无规则的拓扑。 环形拓扑传输时延时确定的。 广域网大多采用网状拓扑。 设信道带宽为5000Hz,采用PCM编码，采样周期为125μs,每个样本量化为256个等级，则信道的数据速率为: $R=\\frac{1}{T}log_2N=(\\frac{1}{12510^{-6}})log_2256=80008=64000bps$ 求信道的传输速率与带宽无关 使用ADSL接入Internet，用户端需要安装PPPoE协议。 关于OSPF： OSPF是一个内部网关协议。开放式最短路径优先（Open Shortest Path First）,采用最短优先算法（Shortest Path Firs,SPF）计算最小生成树来确定最短路径。 OSPF基于IP，协议号是89，采用组播的方式交换OSPF包，组播地址是224.0.0.5（全部OSPF路由器）和224.0.0.6（指定路由器） OSPF使用链路状态广播（Link State Advertisement，LSA）传送给某区域内的所有路由器。 查看OSPF在接收报文时出错的命令是display ospf error 关于RIP： RIP：路由信息协议，属于最早的动态路由协议。 RIP是一种分布式的基于距离矢量的路由选择协议。 优点：实现简单，开销较小。 SNMPC支持各种设备访问方式，在SNMPC支持的设备访问方式中，只是用于对TCP服务轮询的方式是无访问模式。 关于IPV6： ipv6的地址长度是128位。每16位划分一个段，将每个段转换成16进制数字，并用冒号隔开 ipv6中新增加了一种任意播地址。这种地址代表一组接口的标识符。任意播的限制：1、任意播地址不能制动给ipv6主机，只能指定给ipv6路由器。2、任意播不能用于源地址，只能做目的地址。 SNMP协议属于应用层协议。 SNMP位于两种网络模型的顶层即应用层，属于应用层协议。在传输层依靠UDP协议进行传输。SNMP的数据包在传输层，因此叫做PDU (协议数据单元) 18.常见的三种防火墙技术：包过滤防火墙、代理服务器式防火墙、基于状态检测的防火墙。 包过滤防火墙包过滤防火墙主要针对OSI模型中的网络层和传输层的信息进行分析。通常包过滤防火墙用来控制IP、UDP、TCP、 ICMP和其他协议。包过滤防火墙对通过防火墙的数据包进行检查，只有满足条件的数据包才能通过，对数据包的检查内容一般包括源地址、 目的地址和协议。包过滤防火墙**通过规则(如ACL)**来确定数据包是否能通过。配置了ACL的防火墙可以看成包过滤防火墙。 代理服务器式防火墙代理服务器式防火墙对第四层到七层的数据进行检查，与包过滤防火墙相比，需要更高的开销。用户经过建立会话状态并通过认证及授权后，才能访问到受保护的网络。压力较大的情况下，代理服务器式防火墙工作很慢。ISA可以看成是代理服务器式防火墙。 基于状态检测的防火墙基于状态检测的防火墙检测每一个TCP、UDP之类的会话连接。基于状态的会话包含特定会话的源、目的地址、端口号、TCP序列号信息以及与此会话相关的其他标志信息。基于状态检测的防火墙工作基于数据包、连接会话和一个基于状态的会话流表。基于状态检测的防火墙的性能比包过滤防火墙和代理服务器式防火墙要高。思科PIX和ASA属于基于状态检测的防火墙 关于协议端口号： 端口类型 取值范围 备注 系统端口 [0,1023] 供系统使用 登记端口 [1024,49151] 为没有熟知端口号的应用使用的 客户端使用端口 [49152,65535] 仅在客户进程运行的时候动态使用，使用完毕之后，进程会释放该端口 IMAP4协议工作在143端口。 工作区子系统是由终端设备连接到信息插座的连线组成的。 包括连接线和适配器工作区子系统中信息插座的安装位置距离地面的高度为30~ 50cm。 如果信息插座到网卡之间使用无屏蔽双绞线，布线距离最大为10m. 关于反码： 正整数的反码就是其本身。 负整数的反码是通过其绝对值按位求反来取得。 规律：除符号为外的其余各位逐位取反就得到反码，反码表示的数和原码一一对应。例：X1 = +1001，则X1的反码就是01001。 SNMP代理收到一个GET请求时，如果不能提供该对象的值，代理以该实例的下个值相应。 用于生成VLAN标记的协议的是IEEE 802.1Q。 4.7日目前完成第65题 采样定理：规定采样速率必须至少是模拟信号带宽最大值的两倍 属于工作区子系统区域范围的是终端设备到信息插座的整个区间 ","date":"2021-03-28","objectID":"/%E8%BD%AF%E8%80%83%E7%AC%94%E8%AE%B0/:2:1","tags":["笔记","网络工程"],"title":"软考笔记","uri":"/%E8%BD%AF%E8%80%83%E7%AC%94%E8%AE%B0/"},{"categories":["Java"],"content":" 本文转载自https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html 反射之中包含了一个「反」字，所以想要解释反射就必须先从「正」开始解释。 一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。 Apple apple = new Apple(); //直接初始化，「正射」 apple.setPrice(4); 上面这样子进行类对象的初始化，我们可以理解为「正」。 而反射则是一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。 这时候，我们使用 JDK 提供的反射 API 进行反射调用： Class clz = Class.forName(\"com.chenshuyi.reflect.Apple\"); Method method = clz.getMethod(\"setPrice\", int.class); Constructor constructor = clz.getConstructor(); Object object = constructor.newInstance(); method.invoke(object, 4); 上面两段代码的执行结果，其实是完全一样的。但是其思路完全不一样，第一段代码在未运行时就已经确定了要运行的类（Apple），而第二段代码则是在运行时通过字符串值才得知要运行的类（com.chenshuyi.reflect.Apple）。 所以说什么是反射？ 反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。 ","date":"2021-03-24","objectID":"/java%E4%B9%8B%E5%8F%8D%E5%B0%84/:0:0","tags":["Java"],"title":"Java之反射","uri":"/java%E4%B9%8B%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"一个简单的例子 上面提到的示例程序，其完整的程序代码如下： public class Apple { private int price; public int getPrice() { return price; } public void setPrice(int price) { this.price = price; } public static void main(String[] args) throws Exception{ //正常的调用 Apple apple = new Apple(); apple.setPrice(5); System.out.println(\"Apple Price:\" + apple.getPrice()); //使用反射调用 Class clz = Class.forName(\"com.chenshuyi.api.Apple\"); Method setPriceMethod = clz.getMethod(\"setPrice\", int.class); Constructor appleConstructor = clz.getConstructor(); Object appleObj = appleConstructor.newInstance(); setPriceMethod.invoke(appleObj, 14); Method getPriceMethod = clz.getMethod(\"getPrice\"); System.out.println(\"Apple Price:\" + getPriceMethod.invoke(appleObj)); } } 从代码中可以看到我们使用反射调用了 setPrice 方法，并传递了 14 的值。之后使用反射调用了 getPrice 方法，输出其价格。上面的代码整个的输出结果是： Apple Price:5 Apple Price:14 从这个简单的例子可以看出，一般情况下我们使用反射获取一个对象的步骤： 获取类的 Class 对象实例 Class clz = Class.forName(\"com.zhenai.api.Apple\"); 根据 Class 对象实例获取 Constructor 对象 Constructor appleConstructor = clz.getConstructor(); 使用 Constructor 对象的 newInstance 方法获取反射类对象 Object appleObj = appleConstructor.newInstance(); 而如果要调用某一个方法，则需要经过下面的步骤： 获取方法的 Method 对象 Method setPriceMethod = clz.getMethod(\"setPrice\", int.class); 利用 invoke 方法调用方法 setPriceMethod.invoke(appleObj, 14); 到这里，我们已经能够掌握反射的基本使用。但如果要进一步掌握反射，还需要对反射的常用 API 有更深入的理解。 在 JDK 中，反射相关的 API 可以分为下面几个方面：获取反射的 Class 对象、通过反射创建类对象、通过反射获取类属性方法及构造器。 ","date":"2021-03-24","objectID":"/java%E4%B9%8B%E5%8F%8D%E5%B0%84/:1:0","tags":["Java"],"title":"Java之反射","uri":"/java%E4%B9%8B%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"反射常用API ","date":"2021-03-24","objectID":"/java%E4%B9%8B%E5%8F%8D%E5%B0%84/:2:0","tags":["Java"],"title":"Java之反射","uri":"/java%E4%B9%8B%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"获取反射中的Class对象 在反射中，要获取一个类或调用一个类的方法，我们首先需要获取到该类的 Class 对象。 在 Java API 中，获取 Class 类对象有三种方法： **第一种，使用 Class.forName 静态方法。**当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。 Class clz = Class.forName(\"java.lang.String\"); 第二种，使用 .class 方法。 这种方法只适合在编译前就知道操作的 Class。 Class clz = String.class; 第三种，使用类对象的 getClass() 方法。 String str = new String(\"Hello\"); Class clz = str.getClass(); ","date":"2021-03-24","objectID":"/java%E4%B9%8B%E5%8F%8D%E5%B0%84/:2:1","tags":["Java"],"title":"Java之反射","uri":"/java%E4%B9%8B%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"通过反射创建类对象 通过反射创建类对象主要有两种方式：通过 Class 对象的 newInstance() 方法、通过 Constructor 对象的 newInstance() 方法。 第一种：通过 Class 对象的 newInstance() 方法。 Class clz = Apple.class; Apple apple = (Apple)clz.newInstance(); 第二种：通过 Constructor 对象的 newInstance() 方法 Class clz = Apple.class; Constructor constructor = clz.getConstructor(); Apple apple = (Apple)constructor.newInstance(); 通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。下面的代码就调用了一个有参数的构造方法进行了类对象的初始化。 Class clz = Apple.class; Constructor constructor = clz.getConstructor(String.class, int.class); Apple apple = (Apple)constructor.newInstance(\"红富士\", 15); ","date":"2021-03-24","objectID":"/java%E4%B9%8B%E5%8F%8D%E5%B0%84/:2:2","tags":["Java"],"title":"Java之反射","uri":"/java%E4%B9%8B%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"通过反射获取类属性、方法、构造器 我们通过 Class 对象的 getFields() 方法可以获取 Class 类的属性，但无法获取私有属性。 Class clz = Apple.class; Field[] fields = clz.getFields(); for (Field field : fields) { System.out.println(field.getName()); } 输出结果是： price 而如果使用 Class 对象的 getDeclaredFields() 方法则可以获取包括私有属性在内的所有属性： Class clz = Apple.class; Field[] fields = clz.getDeclaredFields(); for (Field field : fields) { System.out.println(field.getName()); } 输出结果是： name price 与获取类属性一样，当我们去获取类方法、类构造器时，如果要获取私有方法或私有构造器，则必须使用有 declared 关键字的方法。 ","date":"2021-03-24","objectID":"/java%E4%B9%8B%E5%8F%8D%E5%B0%84/:2:3","tags":["Java"],"title":"Java之反射","uri":"/java%E4%B9%8B%E5%8F%8D%E5%B0%84/"},{"categories":["Java"],"content":"反射源码解析 当我们懂得了如何使用反射后，今天我们就来看看 JDK 源码中是如何实现反射的。或许大家平时没有使用过反射，但是在开发 Web 项目的时候会遇到过下面的异常： java.lang.NullPointerException ... sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:497) 可以看到异常堆栈指出了异常在 Method 的第 497 的 invoke 方法中，其实这里指的 invoke 方法就是我们反射调用方法中的 invoke。 Method method = clz.getMethod(\"setPrice\", int.class); method.invoke(object, 4); //就是这里的invoke方法 例如我们经常使用的 Spring 配置中，经常会有相关 Bean 的配置： \u003cbean class=\"com.chenshuyi.Apple\"\u003e \u003c/bean\u003e 当我们在 XML 文件中配置了上面这段配置之后，Spring 便会在启动的时候利用反射去加载对应的 Apple 类。而当 Apple 类不存在或发生启发异常时，异常堆栈便会将异常指向调用的 invoke 方法。 从这里可以看出，我们平常很多框架都使用了反射，而反射中最最终的就是 Method 类的 invoke 方法了。 下面我们来看看 JDK 的 invoke 方法到底做了些什么。 进入 Method 的 invoke 方法我们可以看到，一开始是进行了一些权限的检查，最后是调用了 MethodAccessor 类的 invoke 方法进行进一步处理，如下图红色方框所示。 那么 MethodAccessor 又是什么呢？ 其实 MethodAccessor 是一个接口，定义了方法调用的具体操作，而它有三个具体的实现类： sun.reflect.DelegatingMethodAccessorImpl sun.reflect.MethodAccessorImpl sun.reflect.NativeMethodAccessorImpl 而要看 ma.invoke() 到底调用的是哪个类的 invoke 方法，则需要看看 MethodAccessor 对象返回的到底是哪个类对象，所以我们需要进入 acquireMethodAccessor() 方法中看看。 从 acquireMethodAccessor() 方法我们可以看到，代码先判断是否存在对应的 MethodAccessor 对象，如果存在那么就复用之前的 MethodAccessor 对象，否则调用 ReflectionFactory 对象的 newMethodAccessor 方法生成一个 MethodAccessor 对象。 在 ReflectionFactory 类的 newMethodAccessor 方法里，我们可以看到首先是生成了一个 NativeMethodAccessorImpl 对象，再这个对象作为参数调用 DelegatingMethodAccessorImpl 类的构造方法。 这里的实现是使用了代理模式，将 NativeMethodAccessorImpl 对象交给 DelegatingMethodAccessorImpl 对象代理。我们查看 DelegatingMethodAccessorImpl 类的构造方法可以知道，其实是将 NativeMethodAccessorImpl 对象赋值给 DelegatingMethodAccessorImpl 类的 delegate 属性。 所以说ReflectionFactory 类的 newMethodAccessor 方法最终返回 DelegatingMethodAccessorImpl 类对象。所以我们在前面的 ma.invoke() 里，其将会进入 DelegatingMethodAccessorImpl 类的 invoke 方法中。 进入 DelegatingMethodAccessorImpl 类的 invoke 方法后，这里调用了 delegate 属性的 invoke 方法，它又有两个实现类，分别是：DelegatingMethodAccessorImpl 和 NativeMethodAccessorImpl。按照我们前面说到的，这里的 delegate 其实是一个 NativeMethodAccessorImpl 对象，所以这里会进入 NativeMethodAccessorImpl 的 invoke 方法。 而在 NativeMethodAccessorImpl 的 invoke 方法里，其会判断调用次数是否超过阀值（numInvocations）。如果超过该阀值，那么就会生成另一个MethodAccessor 对象，并将原来 DelegatingMethodAccessorImpl 对象中的 delegate 属性指向最新的 MethodAccessor 对象。 到这里，其实我们可以知道 MethodAccessor 对象其实就是具体去生成反射类的入口。通过查看源码上的注释，我们可以了解到 MethodAccessor 对象的一些设计信息。 “Inflation” mechanism. Loading bytecodes to implement Method.invoke() and Constructor.newInstance() currently costs 3-4x more than an invocation via native code for the first invocation (though subsequent invocations have been benchmarked to be over 20x faster).Unfortunately this cost increases startup time for certain applications that use reflection intensively (but only once per class) to bootstrap themselves. Inflation 机制。初次加载字节码实现反射，使用 Method.invoke() 和 Constructor.newInstance() 加载花费的时间是使用原生代码加载花费时间的 3 - 4 倍。这使得那些频繁使用反射的应用需要花费更长的启动时间。 To avoid this penalty we reuse the existing JVM entry points for the first few invocations of Methods and Constructors and then switch to the bytecode-based implementations. Package-private to be accessible to NativeMethodAccessorImpl and NativeConstructorAccessorImpl. 为了避免这种痛苦的加载时间，我们在第一次加载的时候重用了 JVM 的入口，之后切换到字节码实现的实现。 就像注释里说的，实际的 MethodAccessor 实现有两个版本，一个是 Native 版本，一个是 Java 版本。 Native 版本一开始启动快，但是随着运行时间边长，速度变慢。Java 版本一开始加载慢，但是随着运行时间边长，速度变快。正是因为两种存在这些问题，所以第一次加载的时候我们会发现使用的是 NativeMethodAccessorImpl 的实现，而当反射调用次数超过 15 次之后，则使用 MethodAccessorGenerator 生成的 MethodAccessorImpl 对象去实现反射。 Method 类的 invoke 方法整个流程可以表示成如下的时序图： 讲到这里，我们了解了 Method 类的 invoke 方法的具体实现方式。知道了原来 invoke 方法内部有两种实现方式，一种是 native 原生的实现方式，一种是 Java 实现方式，这两种各有千秋。而为了最大化性能优势，JDK 源码使用了代理的设计模式去实现最大化性能。 ","date":"2021-03-24","objectID":"/java%E4%B9%8B%E5%8F%8D%E5%B0%84/:3:0","tags":["Java"],"title":"Java之反射","uri":"/java%E4%B9%8B%E5%8F%8D%E5%B0%84/"},{"categories":["录·序章"],"content":"有哪些让你醍醐灌顶的话？  你学习一般，考上了现在的这所学校，成绩不算好，拿不到奖学金，上课不听讲，上自习不规律，考试靠突击，同学帮一把的话也能每科考到七八十分，但是与优秀总有很大距离。  你家境一般，父母都是普通员工，你在这个城市的生活费是每月一千二，没事下下馆子，一个月添件衣服，想买台相机，咬咬牙才能买双自己喜欢的鞋。  你几乎没有特长，不会弹吉他，不会弹钢琴，不会跳舞，不会画画，想学摄影却不会使用图片处理软件，想上台演出却没信心，学校晚会比赛的时候，你经常是站在台下围观的人群里的一员，你与聚光灯环绕的舞台几乎绝缘。  你长相一般，不算英俊或者不算美丽，身材不算臃肿但也没什么肌肉或者没什么曲线，平时只是稍稍打扮一下，看上去并不出众，只能算整洁，与人擦肩而过是对方不会多留意你一眼。  你的感情也是一般，有时候会遇见自己心仪的那个人，但是总抓不住机会，眨眼间那个人就被其他人俘获，你就开始伤心、抱怨，但是几天之后又开始寻找新的心上人，就这样看着一个个心上人走过，直到你毕业，与其中任何一个都没有发展。  总之，你没有什么特别的地方 ，就和周围的千万个普通人一样。  你不甘心拿不到奖学金，看见别人得奖学金的时候你会说那完全是突击的结果，于是你开始上自习，不过你只坚持了一星期。 你不甘心自己的父辈平平，于是你批评讽刺自己周围的“官二代”、“富二代”，立志要努力学习争取成功，也好让自己的孩子成为“富二代”，你的热情持续了一个星期。  你不甘心自己什么特长都没有，于是你开始学弹吉他、买轮滑鞋、借来摄影方面的书籍，你对着镜子微笑着说：“你是最棒的。” 这份虚假的信心维持了一个星期。  你不甘心自己没有伴侣，你决心洗心革面重新做人，你删掉电脑里的偶像剧肥皂剧，你收拾起床上的懒人桌，把零食袋子统统扔掉，然后洗了个澡并且修饰了一下自己，你往发型上喷了啫喱水，好让自己看起来很精神，你怀揣着一本成功学的书决定出去走走，开始新的生活。  这样的状态，你稀稀拉拉地坚持了一个星期。 一个星期之后，你还是和周围千万个人一样，你还是和一星期前的自己一样。  你逛网络论坛，看到了这样一句话：“二十岁是人生最美好的时光，不应该局限在学校里教室里，应该享受生活。” 于是你相信了，你觉得二十岁的你就应该“随心所欲”，享受“人生中最后的自由时光”；就应该“快乐地去恋爱”“风华正茂”“挥斥方遒”······ 现在的你，用着父母的血汗钱，用着名牌包、穿着名牌跑鞋、骑着捷安特山地车、用着佳能牌的相机和苹果牌的手机，还经常去星巴克喝喝咖啡体验一下小资情调······ 那么，请允许我猜测一下你的未来—— 在大四将要结束时，你考研落榜。  你风风火火的参加校园招聘会，很多公司你都看不上，嫌他们不是体制内单位、平台窄、规模小，直到毕业，你还没有找到心仪的工作。  你收拾好行李回到老家，父母让你试着参加各种招聘考试或者参加当地的应聘会，你不去，因为你觉得那些工作太简单了，不适合你，你应该去寻找更好的就业机会。  可是，当你去那些你看得上的公司应聘时，你的竞争对手太多了，而且都不差，你表现平平，理所当然地被拒之门外······ 现在的你，也许还在上大学，也许和恋人恩恩爱爱，每天黏在一起，午饭晚饭一起去吃，晚自习后还会一起在操场散步。你们讨论起未来，最后的结论总是：不要想得太多，认真过好现在就好。 不幸运的话，几个月后，你们就分手了，你凄凄惨惨戚戚，反复问自己究竟哪里做错了；幸运的话，你们会一直恋爱到毕业，最终，你绝得自己不够优秀没能力去对方所在的城市读研或者工作，所以你们带着不舍和悔恨分手了。  现实很残酷，至此，你信了。  现在的你喜欢刷微博，你会全力支持那些你赞同的观点，你会激励否定那些你反对的观点。你爱憎分明，看起来很有正义感。  你觉得血气方刚的年轻人就应该敢于说出自己的心声。你可能从来不会去想一个问题：你的观点，来自哪里？其实，它们绝大部分来自网络，它们已经蚕食了你的判断力。  现在，我只想问你一个问题：二十岁的你，有什么资本。 你只是千千万万人中微不足道的一个人，少了你，地球还是一样会转。  我敢打赌，一定很久没人和你说过“吃得苦中苦，方为人上人”这句话了吧？ 你知道“责任”两个字是怎么写的吗? 当你谈论飞翔的时候，你是不是忘记了地心引力的存在？ 现在的你，如果还是放纵着自己的懒惰与幼稚，虚度着光阴，那么，你就虚度去吧。  反正我已经过了二十岁的年纪，我还有未来，我得直奔向前了，不陪你了。 再见 。 ——华文《20岁无资本无未来》 本文是某天的午后，无意中在知乎看到的…… ","date":"2021-02-20","objectID":"/%E6%96%87%E7%AB%A0%E8%BD%AC%E8%BD%BD/:0:1","tags":["转载"],"title":"有哪些让你醍醐灌顶的话？(转载)","uri":"/%E6%96%87%E7%AB%A0%E8%BD%AC%E8%BD%BD/"},{"categories":["python写的小工具"],"content":"前言 在吾爱论坛上逛逛，看到有个悬赏贴下载CSDN去水印。好像不难，就去试试看。于是今天又可以水一篇博客了， ","date":"2021-02-07","objectID":"/csdn%E5%9B%BE%E7%89%87%E4%B8%80%E9%94%AE%E4%B8%8B%E8%BD%BD%E5%8E%BB%E6%B0%B4%E5%8D%B0/:0:1","tags":["python"],"title":"CSDN图片一键下载去水印","uri":"/csdn%E5%9B%BE%E7%89%87%E4%B8%80%E9%94%AE%E4%B8%8B%E8%BD%BD%E5%8E%BB%E6%B0%B4%E5%8D%B0/"},{"categories":["python写的小工具"],"content":"代码实现 代码实现很简单。贴主说了，水印和原图的区别就是url后面多了一串东西，那我们只要获取所有的图片地址，然后利用正则过滤一下多的东西，套个循环，下载就行了。 import requests from lxml import etree import re import os headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.116 Safari/537.36\", \"Referer\": \"https://blog.csdn.net\"} path = os.path.dirname(__file__) PATH = os.path.join(path,'img').replace('\\\\','/') if not os.path.exists(PATH): PATH = os.mkdir(PATH) print(\"下载路径：\"+str(PATH)) def get_img_data(url): img_url = [] res = requests.get(url, headers=headers).text data = etree.HTML(res).xpath('//*[@id=\"content_views\"]/p/img/@src') print(f\"一共有{len(data)}张图片\") for i in data: info= re.compile('(.*?)\\?').findall(i)[0] img_url.append(info) return img_url def download_img(data): count = 0 for i in data: res = requests.get(i,headers=headers).content count += 1 path = os.path.join(PATH, f'{count}.jpg').replace('\\\\', '/') with open(path, 'ab')as f: f.write(res) print(f\"第{count}张图片下载成功！\") if __name__ == '__main__': url = \"https://blog.csdn.net/yht6005/article/details/107568596?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161265977516780261989880%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D\u0026request_id=161265977516780261989880\u0026biz_id=0\u0026utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-107568596.first_rank_v2_pc_rank_v29\u0026utm_term=VRay4.2%25E5%25AE%2589%25E8%25A3%2585%25E6%2595%2599%25E7%25A8%258B\" download_img(get_img_data(url)) 以上代码应该是通用所有CSDN文章通用的，因为网站的结构是相同的，但我没做测试，也说不好。 ","date":"2021-02-07","objectID":"/csdn%E5%9B%BE%E7%89%87%E4%B8%80%E9%94%AE%E4%B8%8B%E8%BD%BD%E5%8E%BB%E6%B0%B4%E5%8D%B0/:0:2","tags":["python"],"title":"CSDN图片一键下载去水印","uri":"/csdn%E5%9B%BE%E7%89%87%E4%B8%80%E9%94%AE%E4%B8%8B%E8%BD%BD%E5%8E%BB%E6%B0%B4%E5%8D%B0/"},{"categories":["python写的小工具"],"content":"水印参数分析 我们看一下区别 我们对比一下url，这是原来的 https://img-blog.csdnimg.cn/20200724201139172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lodDYwMDU=,size_16,color_FFFFFF,t_70 https://img-blog.csdnimg.cn/20200724201139172.png 加了水印之后的网址多了几个参数。分别是process,type,shadow,text,size,color 有些参数看着好像被加密了。看到text的值有一个=号，嗯？？？怎么这么像base64加密，拿到解密网站，果然，解码之后是字符串https://blog.csdn.net/yht6005，这个就是水印内容了呀。那我们是不是可以随便改了，试试改成我真帅看看。。。 嘿嘿，有意思 经过一系列测试，得到这些参数的作用如下 参数 作用 type 显示的字体，具体怎么加密的不太清楚 text 水印的内容，必须是base64编码之后的 color 水印的颜色 t 水印的透明度，越高越不透明 size 水印的比例大小，调高即放大水印 shadow 阴影填充，数值越高，填充越明显 process 告诉你这是一个添加水印的图片 ","date":"2021-02-07","objectID":"/csdn%E5%9B%BE%E7%89%87%E4%B8%80%E9%94%AE%E4%B8%8B%E8%BD%BD%E5%8E%BB%E6%B0%B4%E5%8D%B0/:0:3","tags":["python"],"title":"CSDN图片一键下载去水印","uri":"/csdn%E5%9B%BE%E7%89%87%E4%B8%80%E9%94%AE%E4%B8%8B%E8%BD%BD%E5%8E%BB%E6%B0%B4%E5%8D%B0/"},{"categories":["爬虫"],"content":"题目 本次题目涉及到了一些前端的知识，包括HTML，CSS，JQuery，Ajax。 采集这5页的全部数字，计算加和并提交结果 题目链接：http://match.yuanrenxue.com/match/4 ","date":"2021-01-29","objectID":"/css%E5%8A%A0%E5%AF%86-%E6%A0%B7%E5%BC%8F%E5%B9%B2%E6%89%B0/:1:0","tags":["js","python"],"title":"css加密-样式干扰","uri":"/css%E5%8A%A0%E5%AF%86-%E6%A0%B7%E5%BC%8F%E5%B9%B2%E6%89%B0/"},{"categories":["爬虫"],"content":"接口数据分析 页面上的数字感觉跟正常的不一样的，我们随意在页面上点击一个数字，发现每个数字都是由图片组成的。 果然在all里面有0-9的数字图片，每张图片都是base64格式。我们打开xhr看看，这里的数据有点奇怪，好像没有跟上面几道题一样有value值，info字段里面是一段很长的东西。 我们来仔细看看info部分，发现是一段html代码。复制粘贴下来格式化一下， 我们有如下思考： src对应的是base64编码的图片 class属性的值很像是MD5加密之后的东西 style中的left，我们猜测可能是偏移什么的 根据网页中的数据，每页有只有10个四位数。每个四位数似乎对应着td标签的图片，即四个src的值，那么每一部分的代码行数应该是一样的，为什么会出现有多余四张图片的情况？ 我们带着这些问题来看看网页代码 ","date":"2021-01-29","objectID":"/css%E5%8A%A0%E5%AF%86-%E6%A0%B7%E5%BC%8F%E5%B9%B2%E6%89%B0/:2:0","tags":["js","python"],"title":"css加密-样式干扰","uri":"/css%E5%8A%A0%E5%AF%86-%E6%A0%B7%E5%BC%8F%E5%B9%B2%E6%89%B0/"},{"categories":["爬虫"],"content":"分析网页 查看一下网页源代码 分析一下，我们可以得到如下信息： 每一个\u003ctd\u003e标签代表一个四位数 \u003ctd\u003e标签中包含\u003cimg\u003e标签，但是每个\u003ctd\u003e中的\u003cimg\u003e数量可能还不一样的。这是因为标签中,有些是有display:none样式的,这个样式设置了不显示此标签,也就是不显示这个图片。我们观察发现，排除这些不显示的图片,其实\u003ctd\u003e标签中都有且只有四张图片正常显示,只不过数字不一样罢了。如图，网页中只有四位数6081，按理说源码中也是四张图片，但是我们在源码中却可以看到有六张图片，每张图片合起来却是是360158。 每个标签都设置了left这个样式，而left的作用可以改变图片在页面中显示的位置（把图像的左边缘设置在其包含元素左边缘向右 xx 像素的位置）。这是什么意思呢?如图，我们排除隐藏的图片，也不管图片的偏移，按照正常加载顺序四位数应该是6018，但是第三个数字css属性是left:11.5px，向右移动了11.5px,第四位数字css属性是left:-11.5px，向左移动了11.5px，即互换了位置。于是加载以后网页上显示的是6081。 这样，似乎只解答了一部分问题。我们知道接口里的数据个数大于四位是有问题的，但是没关系，网页中会把某些数据不显示，我们看到的还是四位数。那么新的问题来了，它是怎么做到的，按照什么规则把某些图片不显示的。 ","date":"2021-01-29","objectID":"/css%E5%8A%A0%E5%AF%86-%E6%A0%B7%E5%BC%8F%E5%B9%B2%E6%89%B0/:3:0","tags":["js","python"],"title":"css加密-样式干扰","uri":"/css%E5%8A%A0%E5%AF%86-%E6%A0%B7%E5%BC%8F%E5%B9%B2%E6%89%B0/"},{"categories":["爬虫"],"content":"寻找算法(js) 我们可以猜测，网页里肯定是通过了某些算法，进行了删选。于是现在的目标就是如何定位，寻找到这部分的js。 这里我们有一个突破口，display:none，因为在\u003ctd\u003e标签内存在含义display:none样式的\u003cimg\u003e标签,而设置display:none这个样式大概率就会出现我们寻找的js里面。 我们全局搜索一下'display','none' 。 为什么是搜索'display','none'而不是display:none呢? 因为【display:none】是结果,【 ‘display’,‘none’ 】是过程，执行某种算法就是一个过程。 在JQuery中有一个可以设置标签样式的函数—\u003ecss() 第一个参数就是需要设置的样式,第二个参数就是设置样式的值,也就是这样css(‘display’,‘none’) 可以看到我们要找的内容,出现在一段\u003cscript\u003e标签中,我们将其中的JS代码扣下来继续分析 ","date":"2021-01-29","objectID":"/css%E5%8A%A0%E5%AF%86-%E6%A0%B7%E5%BC%8F%E5%B9%B2%E6%89%B0/:4:0","tags":["js","python"],"title":"css加密-样式干扰","uri":"/css%E5%8A%A0%E5%AF%86-%E6%A0%B7%E5%BC%8F%E5%B9%B2%E6%89%B0/"},{"categories":["爬虫"],"content":"分析JS代码 因为有些代码片段是有报错才执行,所以我们可以将扣下来的代码精简一下 window.url = '/api/match/4'; // 设置一个url链接 request = function () { var list = { \"page\": window.page,// 设置页码 }; $.ajax({ // ajax请求 url: window.url, // 请求的网址,也就是上面设置的url链接 dataType: \"json\", // 预计返回信息类型:json async: false, // 是否开启异步请求:否 data: list, // 发送给服务器的信息,也就是上面设置的页面 type: \"GET\", // 请求方式,GET beforeSend: function (request) {},　// 可以不管 // 请求网址成功执行下列代码 success: function (data) { datas = data.info; $('.number').text('').append(datas); var j_key = '.' + hex_md5(btoa(data.key + data.value).replace(/=/g, '')); $(j_key).css('display', 'none'); $('.img_number').removeClass().addClass('img_number') } }) }; request() 通过上面的代码,我们可以知道网页通过ajax的方式请求了[http://match.yuanrenxue.com/api/match/4] 跟第一步的猜测一样 再回到ajax的代码中,看看请求网址成功执行的代码 // 首先我们需要搞清楚的是,函数里面传入的参数**data**,跟上面的data含义是不一样的 // 这里的data值的是请求成功后返回的内容 success: function (data) { // data.info就是获取返回内容中info的部分,也就是\u003ctd\u003e标签里面的内容 datas = data.info; // 通过JQuery的选择器,选择标签中有number的元素,并将\u003ctd\u003e标签的内容添加进去 $('.number').text('').append(datas); // 通过获取data中key和value中的值,并替换一些字符,最后经过md5算法加密,得到一串密文 // 在密文前面加上一个【.】,并赋值给变量j_key var j_key = '.' + hex_md5(btoa(data.key + data.value).replace(/=/g, '')); // 因为密文前面加了一个【.】,所以可以通过选择器,选择有密文这个属性的标签,并将其样式设置成【display:none】 $(j_key).css('display', 'none'); // 选择含有img_number属性的元素,先删除所以元素,最后添加img_number元素 // 为什么要这么做,是为了删除属性中带着的密文 $('.img_number').removeClass().addClass('img_number') } 我们再拿一下第一步的图 可以看到\u003cimg\u003e标签中的属性部分,是有密文部分的,所以就解释了为什么会有这段代码， // 选择含有img_number属性的元素,先删除所以元素,最后添加img_number元素 // 为什么要这么做,是为了删除属性中带着的密文 $('.img_number').removeClass().addClass('img_number') 还有就是,style里面的内容,也就是【left】中的值,决定了图片所在的位置。 到此，已经解决了当时的所有问题。 我们整理一下css加密的思路 通过ajax请求的方式请求带有数据的链接/api/match/4 请求成功后,将info中的\u003ctd\u003e标签添加到HTML代码中 通过md5算法的一系列操作,得到一串密文 匹配有密文属性的\u003cimg\u003e标签,将其设置为display:none不显示 接着,将属性中的密文删除(因为已经不需要带加密的了) 最后,通过附加的left样式,页面中就呈现出了需要我们求和的数字 ","date":"2021-01-29","objectID":"/css%E5%8A%A0%E5%AF%86-%E6%A0%B7%E5%BC%8F%E5%B9%B2%E6%89%B0/:5:0","tags":["js","python"],"title":"css加密-样式干扰","uri":"/css%E5%8A%A0%E5%AF%86-%E6%A0%B7%E5%BC%8F%E5%B9%B2%E6%89%B0/"},{"categories":["爬虫"],"content":"python爬虫 理清之后发现思路并不复杂。但是如何把上述的过程使用python代码来一步步的还原，让我有点犯难了。我们来思考一下如何用代码复现： 在接口里，我们可以拿到一段标签。里面包括base64编码之后的图片值、class属性里面有md5加密后的密文、以及css的偏移量。 想要爬取数字，首先要做一张映射表。把base64值和代表的数字进行关联，做到一一对应。 我们知道，接口里面的可能会出现大于四张base64的图片的情况。因为接口里的数据是没有display属性的。那么我们就需要对所有的base64值进行筛选。如何筛选？模拟网页中的js，比对密文，把不显示的去掉。这时，我们每个四位数正好有四个base64的值对应。 为了方便表示，我们通过数字与base64的映射关系，拿到每页的每个四位数表示的数字。 但是此时的四位数是按照默认顺序排列的，我们要做的就是根据style里面的偏移量进行计算，还原得到正确的排序方式。 拿到所有的数字，进行加和 当然上述过程中肯定要通过正则表达式把需要的内容从接口数据里拿到，并进行匹配 import re import base64 import hashlib import requests image_dict = { 'iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCAYAAACqhkzFAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAMTSURBVEhLrZY/TBNRHMe/bY82LeGA0Dp4NTGYqO1gdKEMwmQcGh38M5CQlGDSwWiMAwwYg2iCJsZJQ9CJ0ETsQMJgwuagLIUFXIAFXNoYcqDloLRXrq3v7v3aXktbSPCTXO77fZRvf/feu9+r5dz5iwX8R+oESigMPka6/wb2vSJUBx+1QoVD3kTz7DScb+f4YBVHA6U+ZKLPsON1IE9DtbDLP9AxEIawRgOEle4cKYSD+ZeQq8IcKquMXTbyOllPL7aiEWgSDRCmQAnahyHsiGQZruUvkIKXcObyFeM62zcOd1ylvwJ5MYDkuxA5Tjlw8A2S12iyGM7YODrujsFqfqTFCJw9L+CWyTPS3QPIBMgwKFBC9n4AaW4AdQVtQxEy1czBObkIJznAi9TDO6SLgVIYqt9QBq5YFEKCTC2momg2VXngD5bmnAc+uIqUIXQUOL/X3hJl5mHfUEgzPJ04pMUxAnN+CYeG1UlAmCLZANtqAk2kARG5m1zxQI9paWUZAsmGsArLnxOh0ZSxwCBypjwo2zQPxzCTgJ2kTtbbZ9zZ/7pRKO8WOOWqrX9iePyJiqnNGgTTuhRhgT5o5kc+JaeosDYssHbpx+OtXEziSIWqx0fqOFpg7ns2Zd24s8B1WE0V5h2mJW/ELTc0kjo2Zcm4s8ClikCIlR+si59tZpL66yosc2U8clM8bhgDkfVFUzuqR569rqXOqG7CPsOlEWiJJSraUaa/i3Q9upC94CHNCtr4WXoN+aJMzcFlakd73eGG5wnuhZHykmZ1tnx9TboYqDfNWLxoWDvqhfK+h0w1Pcg87cUBOavMmu1HMoxShuXJNNpNi7N3ewLJTyEUzIdQIIT0wgQ7EcmzxWifZMcEOZ3KY3Qwgp3RQOnbOfqJx5XGtlSOS4aK1tlHEIcXyHNsrW0dY6SBFX0ufShc70S21OwE5AR+lb+ZVfb5OVpGviGTTkHeSmBfScJqtdX55SAFoY0OsMXxISM6SvvNrshwrS7A9WoENupyv+O/oGm831sslno/RU6OsvsHu3+3yQH/AOyW6SvqnweCAAAAAElFTkSuQmCC': 0, 'iVBORw0KGgoAAAANSUhEUgAAABUAAAAcCAYAAACOGPReAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAD0SURBVEhLY5RVUPvPQGXABKUJAA2GvzP3Mry6f5PhzfI4qBhuQNjQqD6Gzxc3Mjxzk2H4CRUiBHAYKs3wP7Gd4evhSwzPWr0ZPvBBhYkEqIaaBzL8nrmS4f3FfQzP6oIY3smwM/yFSpECkAyNY/g2q4PhhZsBwxegy/5BRZlfP2HgIdbfUIAnTD8xCGyuZ5AyW8jATqmhzD9fMwjumsUgbWPKwJu3AipKGkAydC8DZ24sg5SGDQNPei8D01OoMBkAydCnDIyHTkHZlAE8YUo+GDWU+mAEGfq46RCUhQAUGypbZwdlIcBoRFEfjBpKfUADQxkYAKYHOb9g+7HMAAAAAElFTkSuQmCC': 1, 'iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCAYAAACqhkzFAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAKCSURBVEhLrZZLaBNRFIb/PDp5SFMxjqVOAjYLNUGUbhI3cdEGwaAgbmopWFIQBEUwFhQVldIqCuqilLoymEVVlCqWuNdVXRk31Y1uTKAQMRI0ycQk453JaWaSJjYPPxjmnJPwcefOuSfROXftlvAfaSAUIIXOITfuR9bBQzQBZfqEEzPgVuPY8uIeuMXPVK2lVnjoCrKzJ5F2mKqSZpi/xGCfCEOfpAKhCkPz+HEpgN9sRVpMoqjcJZMJBSVS0Wfeoz94CkaNVE93wOOqygyZr9i+cBnOwT3YsXe/cvUPDsMxHcPWTOU7MmWbD+m5i5RVUIUKGfQt38DOA0dgufuSauskoYuE0RuchV0jzQ8FIAqUMFShmIB9+jhs559SoQnJKKwLcZgpBVwoTFLIUIXXTsMaqdvhZjz8qBECRYeXog2P3CoJts8UMko2F0UdC90o2ihkcAl1mzoTnnGh0kwyGRhXKWR0IBRQOOZGnjL57RsjFDLaF87MI+1Ru9+ysgSOYpn2hKEovo+71RMjfoJtKkpJhRaFAsozr5C67kOOKvLe2e+cBVfXaZsLhSD+LD3DGluZum8p5RA06tt/C4/exK83D7A2xKNEJT07UfzV0aaHoImQHnFuDGlNv8kja2BkBObF5ieqgdDf8BG3PboAPrBx/tVTN7H9KMTuI+WxVQesIRUHPzWKnndU2ATNCgUUn9TKrB8eY8DbukxGFYZu4+dBVWZZYXPvxC3oKG8VEnqRn1R7rCfBfi/Gahu2VSpC3wRyDiViiOhdDre9snUqwsOCZnqkYHhLYSfIb9n5+psESerq6nvOPMylrLDEa7q3C7L7hrVt0z1Fu9Dor0g3AH8BJlTqZkAngxQAAAAASUVORK5CYII=': 2, 'iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCAYAAACqhkzFAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAALaSURBVEhLrZVPSBRRHMe/O+rOuuaUyRoyBlGQfw5lh9xTekg8qIdMKSsQFKRAD0WUROhBCIlSBD1YQsJKQSB1iRa8VRf1Up4UQiNcRVw1nXVdx3V3euP+ZnZmR9EVP/CY3/vx5sPMe+/3nu3suYsKjhGrUCxB5GErNssKERIEyDzlIYOX/MgY+4r0zm5w85ROwCRU2j1Yu+fGhi7ZG072Iau3Bc6BacrE4ejJ6EKgySyzy+yrdptpIKJ8HlbahrHZKFImjnEcIeHU6FuIlfk4U3AJObstH2L9C7hmJKTQKEBg0h7sUE/DJLT5x5FbeRWZ99kcTVFSY9wDR/kN5Pxkn6vBFyPUTjFhEPYjs6YBqYkiE/NIfTeODOqpyEUNFMUwCNmy7bNyJr5M787pfuwxhwfhh+1YhWIxtgWKGXafh6IYSQuVjssIUgxMwdFLIZGc8IEHKxV5iFL3xGg37AnzfnAtu68jUlYFueIa1i4IiFDaOfYa2XcGqRfHKnzlxVzdeepYSZVmkfXyERwfrGWnktQvc7If6T62yrxhVRKwCvX6jTet3KK8C4EiN5Y6hrEw6YV811rLhzwPRSi19dhqqmFCFzvINPzI7rwN51B8ZQ4pNNA4iNW2UgTpVOL835Fb0qz/atL7EEPNyPrm01+MutwIPa","date":"2021-01-29","objectID":"/css%E5%8A%A0%E5%AF%86-%E6%A0%B7%E5%BC%8F%E5%B9%B2%E6%89%B0/:6:0","tags":["js","python"],"title":"css加密-样式干扰","uri":"/css%E5%8A%A0%E5%AF%86-%E6%A0%B7%E5%BC%8F%E5%B9%B2%E6%89%B0/"},{"categories":["爬虫"],"content":"总结 本题感觉代码有一定难度，通过迭代器enumerate来分别遍历索引和对应的值，而且在数据中，实际上共用同一个index，关联了好几个列表。最后的还原算法，就是本身的索引加上本身的值得到的就是真实的列表索引，值为原始列表对应的索引。每个功能函数的结果以返回值的形式，通过形参与实参的传递，案例很好，值得研究。 ","date":"2021-01-29","objectID":"/css%E5%8A%A0%E5%AF%86-%E6%A0%B7%E5%BC%8F%E5%B9%B2%E6%89%B0/:7:0","tags":["js","python"],"title":"css加密-样式干扰","uri":"/css%E5%8A%A0%E5%AF%86-%E6%A0%B7%E5%BC%8F%E5%B9%B2%E6%89%B0/"},{"categories":["爬虫"],"content":"题目 抓取下列5页商标的数据，并将出现频率最高的申请号填入答案中 ","date":"2021-01-28","objectID":"/%E8%AE%BF%E9%97%AE%E9%80%BB%E8%BE%91-%E6%8E%A8%E5%BF%83%E7%BD%AE%E8%85%B9/:1:0","tags":["js","python"],"title":"访问逻辑-推心置腹","uri":"/%E8%AE%BF%E9%97%AE%E9%80%BB%E8%BE%91-%E6%8E%A8%E5%BF%83%E7%BD%AE%E8%85%B9/"},{"categories":["爬虫"],"content":"分析网页 查看XHR里面的内容 可以很清晰的看到数据来源于第三个请求。 查看Preview发现里面没有内容，尝试访问一下链接，什么都没有。根据经验，肯定没有那么容易拿到数据。这时我们注意到，请求头里面设置了一个set-cookie， 我们使用接口测试工具带着cookie，发送一次get请求，发现返回了一段\u003cscript\u003e标签，而不是正常的json数据，格式化之后发现好像跟cookie没有什么关系，我们先放着不用管。 继续看前面的几个请求，发现第二个logo也带有cookie属性。 我们访问其他几页试试看。 发现了一个有意思的现象，logo跟3这两个请求似乎是绑定到一起的，每次访问下一页，都是先请求logo，在请求3，而且cookie值相同。 那么我们可以大胆的猜测一下，是否每次访问一个页面，都是先访问一次logo，然后设置了一个cookie值，于是后面的3请求就有了cookie。 ","date":"2021-01-28","objectID":"/%E8%AE%BF%E9%97%AE%E9%80%BB%E8%BE%91-%E6%8E%A8%E5%BF%83%E7%BD%AE%E8%85%B9/:2:0","tags":["js","python"],"title":"访问逻辑-推心置腹","uri":"/%E8%AE%BF%E9%97%AE%E9%80%BB%E8%BE%91-%E6%8E%A8%E5%BF%83%E7%BD%AE%E8%85%B9/"},{"categories":["爬虫"],"content":"验证猜想 我们用python代码测试了一下，发现 单独访问http://match.yuanrenxue.com/api/match/3是得不到数据的，而是一段上面说的代码，并没有什么用处。 设置了一个session来保持会话，首先访问logo，再次访问3，可以得到数据。 通过.cookies方法打印出来看看，果然设置了在第一个请求就设置了cookie。 那么代码就好写了。 import requests # 实例化session session = requests.session() # 设置请求头,必须这么写,不然会请求失败, headers = { 'Connection': 'keep-alive', 'User-Agent': 'yuanrenxue.project', 'Accept': '*/*', 'Origin': 'http://match.yuanrenxue.com', 'Referer': 'http://match.yuanrenxue.com/match/3', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9,en-GB;q=0.8,en;q=0.7', } # 名为【logo】请求的url url = 'http://match.yuanrenxue.com/logo' # 设置请求头数据 session.headers = headers # 使用session发起请求 response = session.post(url=url) url_api = f'http://match.yuanrenxue.com/api/match/3' res = session.get(url=url_api).json() # 成功获取到数据,猜想成功 print(res) #{'status': '1', 'state': 'success', # 'data': [{'value': 2838}, {'value': 7609}, {'value': 8717}, # {'value': 6923}, {'value': 5325}, {'value': 4118}, {'value': 8884}, # {'value': 8717}, {'value': 2680}, {'value': 3721}]} ","date":"2021-01-28","objectID":"/%E8%AE%BF%E9%97%AE%E9%80%BB%E8%BE%91-%E6%8E%A8%E5%BF%83%E7%BD%AE%E8%85%B9/:3:0","tags":["js","python"],"title":"访问逻辑-推心置腹","uri":"/%E8%AE%BF%E9%97%AE%E9%80%BB%E8%BE%91-%E6%8E%A8%E5%BF%83%E7%BD%AE%E8%85%B9/"},{"categories":["爬虫"],"content":"python爬取 使用pandas里面的函数value_counts()求取众数 。 import requests import pandas as pd def get_data(page_num): session = requests.session() headers = { 'Connection': 'keep-alive', 'User-Agent': 'yuanrenxue.project', 'Accept': '*/*', 'Origin': 'http://match.yuanrenxue.com', 'Referer': 'http://match.yuanrenxue.com/match/3', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9,en-GB;q=0.8,en;q=0.7', } url = 'http://match.yuanrenxue.com/logo' session.headers = headers response = session.post(url=url) url_api = f'http://match.yuanrenxue.com/api/match/3?page={page_num}' res = session.get(url=url_api).json() data = [i['value']for i in res['data']] return data if __name__ == '__main__': data = [] for i in range(1,6): data_list = get_data(i) data.extend(data_list) count = pd.value_counts(data) print(count) ","date":"2021-01-28","objectID":"/%E8%AE%BF%E9%97%AE%E9%80%BB%E8%BE%91-%E6%8E%A8%E5%BF%83%E7%BD%AE%E8%85%B9/:4:0","tags":["js","python"],"title":"访问逻辑-推心置腹","uri":"/%E8%AE%BF%E9%97%AE%E9%80%BB%E8%BE%91-%E6%8E%A8%E5%BF%83%E7%BD%AE%E8%85%B9/"},{"categories":["爬虫"],"content":"总结 本题不难，多用python测试几次就知道了。题目名字叫访问逻辑，顾名思义，应该就是请求访问的先后顺序不能错，否则就算cookie正确也拿不到正确的值。 ","date":"2021-01-28","objectID":"/%E8%AE%BF%E9%97%AE%E9%80%BB%E8%BE%91-%E6%8E%A8%E5%BF%83%E7%BD%AE%E8%85%B9/:5:0","tags":["js","python"],"title":"访问逻辑-推心置腹","uri":"/%E8%AE%BF%E9%97%AE%E9%80%BB%E8%BE%91-%E6%8E%A8%E5%BF%83%E7%BD%AE%E8%85%B9/"},{"categories":["爬虫"],"content":"题目 题目链接：http://match.yuanrenxue.com/match/2 提取全部5页发布日热度的值，计算所有值的加和,并提交答案 ","date":"2021-01-27","objectID":"/js%E6%B7%B7%E6%B7%86-%E5%8A%A8%E6%80%81cookie/:1:0","tags":["python","js"],"title":"Js混淆-动态cookie","uri":"/js%E6%B7%B7%E6%B7%86-%E5%8A%A8%E6%80%81cookie/"},{"categories":["爬虫"],"content":"分析网页 本题题目已经写说明了是动态cookie，所以为了避免其余cookie的影响，直接在无痕模式下进行调试。 老样子，试着看看XHR里面的内容。 发现跟上一道题一样，数据都是在json里面，看下后面几页的网址。 第一页：http://match.yuanrenxue.com/api/match/2 点击访问一下看看。 不出所料，返回的不是正常的内容，而是{\"error\": \"出错啦~嘤嘤嘤\"}。我们观察一下请求的cookie，貌似跟第一题的加密方法很像，|后面应该是个时间戳。 那么这个cookie是怎么生成的呢? ","date":"2021-01-27","objectID":"/js%E6%B7%B7%E6%B7%86-%E5%8A%A8%E6%80%81cookie/:2:0","tags":["python","js"],"title":"Js混淆-动态cookie","uri":"/js%E6%B7%B7%E6%B7%86-%E5%8A%A8%E6%80%81cookie/"},{"categories":["爬虫"],"content":"寻找cookie来源 查看所有的请求信息，看看有没有别的东西。发现有两个请求都是2，有点可疑，点进去看看 可以发现,第一个请求是不带cookie的,而第二个请求带cookie，那么我们是不是可以猜测第一个请求完成后，执行了某些我们没有看到的操作，从而生成了cookie，给了第二个请求。 ","date":"2021-01-27","objectID":"/js%E6%B7%B7%E6%B7%86-%E5%8A%A8%E6%80%81cookie/:3:0","tags":["python","js"],"title":"Js混淆-动态cookie","uri":"/js%E6%B7%B7%E6%B7%86-%E5%8A%A8%E6%80%81cookie/"},{"categories":["爬虫"],"content":"使用Fiddler抓包 我们可以看到，第一次请求确实是返回了一些东西。是一段JS代码，但是这些看着全是乱七八糟的字符。这说明这段代码经过了一定的混淆，先不管其他，我们把它复制粘贴下来，格式化一下， 代码太长了，就截取一部分。查阅资料， 混淆后的样子，变量跟方法名已经完全替换，然后第一行可以看到明显的一个数组，这就是ob混淆的常见特性. 而官网正好就有 解混淆工具 我们把代码解混淆之后的代码继续格式化 整段代码差不多200多行代码,而且这些函数名和变量名都非常奇怪。后来查阅资料才知道，这是由于经过一些工具压缩了JS之后导致的，简化了变量名和方法名便于传输。那么我们下一步就很明确了，要分析这段js代码到底干了什么。 ","date":"2021-01-27","objectID":"/js%E6%B7%B7%E6%B7%86-%E5%8A%A8%E6%80%81cookie/:4:0","tags":["python","js"],"title":"Js混淆-动态cookie","uri":"/js%E6%B7%B7%E6%B7%86-%E5%8A%A8%E6%80%81cookie/"},{"categories":["爬虫"],"content":"分析JS代码 大致的浏览一下,全部代码,可以发现,大多数都是定义的函数,但是真正执行的只有最后的W(X()); 我们首先看看X()函数是什么 function X(Y, Z) { return Date[\"parse\"](new Date()); } 在试工具里面执行X()函数就可以看到,返回的是一个时间戳,那么这个函数也会返回一个时间戳 再来看W()函数是什么 function W(Y, Z) { document[\"cookie\"] = \"m\" + M() + \"=\" + V(Y) + \"|\" + Y + \"; path=/\"; location[\"reload\"](); } w()函数定义了两个形参,而执行的函数W(X());,是传入一个参数的，发现W()里面包含cookie等信息，那么肯定要研究一下W()干了什么 ","date":"2021-01-27","objectID":"/js%E6%B7%B7%E6%B7%86-%E5%8A%A8%E6%80%81cookie/:5:0","tags":["python","js"],"title":"Js混淆-动态cookie","uri":"/js%E6%B7%B7%E6%B7%86-%E5%8A%A8%E6%80%81cookie/"},{"categories":["爬虫"],"content":"分析W()函数 我们来看一下W()函数的作用 document[\"cookie\"] 就是设置cookie信息 location[\"reload\"](); 非常关键！！这行代码的意思就是:刷新当前文档，也就是按了一下浏览器上的刷新页面按钮。 这段代码解释了前面为何会出现两个相同的请求。我们整理一下。 网页向服务器发送请求,返回了两个名为【2】的结果 第一个没有Cookie,而第二个有Cookie 第一个虽然没有Cookie,但是却执行了一段JS代码 而这段JS代码给网页中的Cookie赋了值,接着刷新了整个页面 最后,呈现在我们眼前的网页,也就是第二个名为【2】的结果,有了Cookie 那么现在就是关键的document[\"cookie\"]部分， m=36674c3718305e203ee914bf011045c5|1609132022000 document[\"cookie\"] = \"m\" + M() + \"=\" + V(Y) + \"|\" + Y + \"; path=/\"; 最后面的\"; path=/\"字符串,是页面信息(第几页),在其他地方肯定是会处理的,这里我们可以省略。 通过对比,赋值过程和赋值结果,我们可以发现赋值过程中的 M()函数返回的一个应该是个空值。但是我们可以去稍微分析一下M()函数。 function M(Y, Z) { var a4 = B(this, function () { var a5 = function () { var a6 = a5[\"constructor\"](\"return /\\\" + this + \\\"/\")()[\"compile\"](\"^([^ ]+( +[^ ]+)+)+[^ ]}\"); return !a6[\"test\"](a4); }; return a5(); }); a4(); K(); qz = [10, 99, 111, 110, 115, 111, 108, 101, 32, 61, 32, 110, 101, 119, 32, 79, 98, 106, 101, 99, 116, 40, 41, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 32, 61, 32, 102, 117, 110, 99, 116, 105, 111, 110, 32, 40, 115, 41, 32, 123, 10, 32, 32, 32, 32, 119, 104, 105, 108, 101, 32, 40, 49, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 102, 111, 114, 40, 105, 61, 48, 59, 105, 60, 49, 49, 48, 48, 48, 48, 48, 59, 105, 43, 43, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 104, 105, 115, 116, 111, 114, 121, 46, 112, 117, 115, 104, 83, 116, 97, 116, 101, 40, 48, 44, 48, 44, 105, 41, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 125, 10, 32, 32, 32, 32, 125, 10, 10, 125, 10, 99, 111, 110, 115, 111, 108, 101, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 91, 111, 98, 106, 101, 99, 116, 32, 79, 98, 106, 101, 99, 116, 93, 39, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 402, 32, 116, 111, 83, 116, 114, 105, 110, 103, 40, 41, 32, 123, 32, 91, 110, 97, 116, 105, 118, 101, 32, 99, 111, 100, 101, 93, 32, 125, 39, 10]; eval(L(qz)); try { if (global) { console[\"log\"](\"\\u4EBA\\u751F\\u82E6\\u77ED\\uFF0C\\u4F55\\u5FC5python\\uFF1F\"); } else { while (1) { console[\"log\"](\"\\u4EBA\\u751F\\u82E6\\u77ED\\uFF0C\\u4F55\\u5FC5python\\uFF1F\"); debugger; } } } catch (a5) { return navigator[\"vendorSub\"]; } } 首先,我们可以看到函数里面还包含着两个函数分别是【 a4() 】和【 K() 】 而这个【 a4() 】函数,也定义在M()内,但是执行【 a4() 】函数的时候,并没有传入参数,所以说,这段代码是没用的 接着,我们看一下K()函数 function K(Y, Z) { if (Z) { return J(Y); } return H(Y); } 需要传入参数,而执行的时候,又没有传入,所有这段代码也是是没用的 我们简化一下M()函数 function M(Y, Z) { qz = [10, 99, 111, 110, 115, 111, 108, 101, 32, 61, 32, 110, 101, 119, 32, 79, 98, 106, 101, 99, 116, 40, 41, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 32, 61, 32, 102, 117, 110, 99, 116, 105, 111, 110, 32, 40, 115, 41, 32, 123, 10, 32, 32, 32, 32, 119, 104, 105, 108, 101, 32, 40, 49, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 102, 111, 114, 40, 105, 61, 48, 59, 105, 60, 49, 49, 48, 48, 48, 48, 48, 59, 105, 43, 43, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 104, 105, 115, 116, 111, 114, 121, 46, 112, 117, 115, 104, 83, 116, 97, 116, 101, 40, 48, 44, 48, 44, 105, 41, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 125, 10, 32, 32, 32, 32, 125, 10, 10, 125, 10, 99, 111, 110, 115, 111, 108, 101, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 91, 111, 98, 106, 101, 99, 116, 32, 79, 98, 106, 101, 99, 116, 93, 39, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 402, 32, 116, 111, 83, 116, 114, 105, 110, 103, 40, 41, 32, 123, 32, 91, 110, 97, 116, 105, 118, 101, 32, 99, 111, 100, 101, 93, 32, 125, 39, 10]; eval(L(qz)); try { if (global) { console[\"log\"](\"\\u4EBA\\u751F\\u82E6\\u77ED\\uFF0C\\u4F55\\u5FC5python\\uFF1F\"); } else { while (1) { console[\"log\"](\"\\u4EBA\\u751F\\u82E6\\u77ED\\uFF0C\\u4F55\\u5FC5python\\uFF1F\"); debugger; } } } catch (a5) { return navigator[\"vendorSub\"]; } } eval()函数又出现了,做过第一道题的时候,我们知道eval()可以间接的改变一些变量的值,那么这里的eval()是否对cookie有所改变呢? 我们来看看eval()中的L()函数 function L(Y, Z) { let a0 = \"\"; for (let a1 = 0; a1 \u003c Y[\"length\"]; a1++) { a0 += String[\"fromCharCode\"](Y[a1]); } r","date":"2021-01-27","objectID":"/js%E6%B7%B7%E6%B7%86-%E5%8A%A8%E6%80%81cookie/:6:0","tags":["python","js"],"title":"Js混淆-动态cookie","uri":"/js%E6%B7%B7%E6%B7%86-%E5%8A%A8%E6%80%81cookie/"},{"categories":["爬虫"],"content":"验证猜测 我们要改写JS，做出以下调整。 删除第一行代码和最后一行代码，去掉最外面一层，方便调试 发现定义时变量报错，把循环内部局部变量改成全局的，即代码中的let改为var 尝试运行时是会某明奇妙的卡住，退出。删除104行左右的setInterval(M(), 500);这行代码,而这行代码的主要作用就是:每500毫秒,执行M(),而这个函数,我们在上面的推断是返回空所有没什么用,可以直接删掉,否则会一直卡住。 显示未定义navigator，那么在代码的开头定义 var navigator = {}; （这个navigator包含有关浏览器的信息） M()函数中,qz上面的多余代码直接删除,并没有什么卵用 改写W()函数中的内容,添加新的函数get_chipher执行结果 我们可以看到，运行之后拿到了值m=ac27a113166d13b2d6964bd9657f9020|1611801060000 再看看原本的cookie是什么 比对成功，我们把js文件那个时间戳改成正常的调用方法 function X(Y, Z) { return Date[\"parse\"](new Date()); } 这样，我们对JS部分解决完毕。此处，附上JS部分的代码： var navigator = {}; var B = function () { var Y = true; return function (Z, a0) { var a1 = Y ? function () { if (a0) { var a2 = a0[\"apply\"](Z, arguments); a0 = null; return a2; } } : function () { }; Y = false; return a1; }; }(); function C(Y, Z) { var a0 = (65535 \u0026 Y) + (65535 \u0026 Z); return (Y \u003e\u003e 16) + (Z \u003e\u003e 16) + (a0 \u003e\u003e 16) \u003c\u003c 16 | 65535 \u0026 a0; } function D(Y, Z) { return Y \u003c\u003c Z | Y \u003e\u003e\u003e 32 - Z; } function E(Y, Z, a0, a1, a2, a3) { return C(D(C(C(Z, Y), C(a1, a3)), a2), a0); } function F(Y, Z, a0, a1, a2, a3, a4) { return E(Z \u0026 a0 | ~Z \u0026 a1, Y, Z, a2, a3, a4); } function G(Y, Z, a0, a1, a2, a3, a4) { return E(Z \u0026 a1 | a0 \u0026 ~a1, Y, Z, a2, a3, a4); } function H(Y, Z) { var a0 = [99, 111, 110, 115, 111, 108, 101]; var a1 = \"\"; for (var a2 = 0; a2 \u003c a0[\"length\"]; a2++) { a1 += String[\"fromCharCode\"](a0[a2]); } return a1; } function I(Y, Z, a0, a1, a2, a3, a4) { return E(Z ^ a0 ^ a1, Y, Z, a2, a3, a4); } function J(Y, Z, a0, a1, a2, a3, a4) { return E(a0 ^ (Z | ~a1), Y, Z, a2, a3, a4); } function K(Y, Z) { if (Z) { return J(Y); } return H(Y); } function L(Y, Z) { var a0 = \"\"; for (var a1 = 0; a1 \u003c Y[\"length\"]; a1++) { a0 += String[\"fromCharCode\"](Y[a1]); } return a0; } function M(Y, Z) { qz = [10, 99, 111, 110, 115, 111, 108, 101, 32, 61, 32, 110, 101, 119, 32, 79, 98, 106, 101, 99, 116, 40, 41, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 32, 61, 32, 102, 117, 110, 99, 116, 105, 111, 110, 32, 40, 115, 41, 32, 123, 10, 32, 32, 32, 32, 119, 104, 105, 108, 101, 32, 40, 49, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 102, 111, 114, 40, 105, 61, 48, 59, 105, 60, 49, 49, 48, 48, 48, 48, 48, 59, 105, 43, 43, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 104, 105, 115, 116, 111, 114, 121, 46, 112, 117, 115, 104, 83, 116, 97, 116, 101, 40, 48, 44, 48, 44, 105, 41, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 125, 10, 32, 32, 32, 32, 125, 10, 10, 125, 10, 99, 111, 110, 115, 111, 108, 101, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 91, 111, 98, 106, 101, 99, 116, 32, 79, 98, 106, 101, 99, 116, 93, 39, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 402, 32, 116, 111, 83, 116, 114, 105, 110, 103, 40, 41, 32, 123, 32, 91, 110, 97, 116, 105, 118, 101, 32, 99, 111, 100, 101, 93, 32, 125, 39, 10]; eval(L(qz)); try { if (global) { console[\"log\"](\"\\u4EBA\\u751F\\u82E6\\u77ED\\uFF0C\\u4F55\\u5FC5python\\uFF1F\"); } else { while (1) { console[\"log\"](\"\\u4EBA\\u751F\\u82E6\\u77ED\\uFF0C\\u4F55\\u5FC5python\\uFF1F\"); debugger; } } } catch (a5) { return navigator[\"vendorSub\"]; } } function N(Y, Z) { Y[Z \u003e\u003e 5] |= 128 \u003c\u003c Z % 32, Y[14 + (Z + 64 \u003e\u003e\u003e 9 \u003c\u003c 4)] = Z; if (qz) { var a0, a1, a2, a3, a4, a5 = 1732584193, a6 = -271733879, a7 = -1732584194, a8 = 271733878; } else { var a0, a1, a2, a3, a4, a5 = 0, a6 = -0, a7 = -0, a8 = 0; } for (a0 = 0; a0 \u003c Y[\"length\"]; a0 += 16) a1 = a5, a2 = a6, a3 = a7, a4 = a8, a5 = F(a5, a6, a7, a8, Y[a0], 7, -680876936), a8 = F(a8, a5, a6, a7, Y[a0 + 1], 12, -389564586), a7 = F(a7, a8, a5, a6, Y[a0 + 2], 17, 606105819), a6 = F(a6, a7, a8, a5, Y[a0 + 3], 22, -1044525330), a5 = F(a5, a6, a7, a8, Y[a0 + 4], 7, -176418897), a8 = F(a8, a5, a6, a7, Y[a0 + 5], 12, 1200080426), a7 = F(a7, a8, a5, a6, Y[a0 + 6], 17, -1473231341), a6 = F(a6, a7, a8, a5, Y[a0 + 7], 22, -45705983), a5 = F(a5, a6, a7, a8, Y[a0 + 8], 7, 1770010416), a8 = F(a8, a5, a6, a7, Y[a0 + 9], 12, -1958414417), a7 = F(a7, a8, a5, a6, Y[a0 + 10], 17, -42063), a6","date":"2021-01-27","objectID":"/js%E6%B7%B7%E6%B7%86-%E5%8A%A8%E6%80%81cookie/:7:0","tags":["python","js"],"title":"Js混淆-动态cookie","uri":"/js%E6%B7%B7%E6%B7%86-%E5%8A%A8%E6%80%81cookie/"},{"categories":["爬虫"],"content":"Python爬取 加密部分解决，爬取部分就简单了。代码如下： import requests import execjs def get_cookies(): with open(r'1.1.js',encoding='utf-8',mode='r') as f: JsData = f.read() ck= execjs.compile(JsData).call('get_chipher') print(f'cookie是{ck}') return ck def get_data(url,cookie): headers={ 'user-agent':'yuanrenxue.project', 'cookie':cookie } r = requests.get(url,headers=headers) return r.json() if __name__ == '__main__': sum_all = 0 for i in range(1,6): url = f'http://match.yuanrenxue.com/api/match/2?page={i}' info = get_data(url,get_cookies()) hot_list =[i[\"value\"] for i in info[\"data\"]] print(f'第{i}页的数据为{hot_list}') sum_all += sum(hot_list) print(f'所有页数的热度加和为{sum_all}') ","date":"2021-01-27","objectID":"/js%E6%B7%B7%E6%B7%86-%E5%8A%A8%E6%80%81cookie/:8:0","tags":["python","js"],"title":"Js混淆-动态cookie","uri":"/js%E6%B7%B7%E6%B7%86-%E5%8A%A8%E6%80%81cookie/"},{"categories":["爬虫"],"content":"总结 本题的思路跟上一题稍有不同，上一题加密的部分是可以直接在js里面找到的，而本题却是在发送第一个请求的时候返回了一段ob混淆过的js代码。 在谷歌浏览器自带的调试工具里，某些操作是看不到的，比如说刚刚的那段JS。使用fiddler可以抓到包，以前安装过fiddler，但是不怎么会用，现在发现还挺香的，嘿嘿。 思路不难，跟第一题非常类似，分析JS。比较头疼的是JS的调试部分，开发者绕了很多圈子，写了不少类似死循环的东西误导你，拿到调试工具里面，一会就卡住了，所以对那些没有用的代码，精简删除很关键。 ","date":"2021-01-27","objectID":"/js%E6%B7%B7%E6%B7%86-%E5%8A%A8%E6%80%81cookie/:9:0","tags":["python","js"],"title":"Js混淆-动态cookie","uri":"/js%E6%B7%B7%E6%B7%86-%E5%8A%A8%E6%80%81cookie/"},{"categories":["爬虫"],"content":"题目 抓取所有（5页）机票的价格，并计算所有机票价格的平均值，填入答案。 题目链接：http://match.yuanrenxue.com/match/1 ","date":"2021-01-23","objectID":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/:1:0","tags":["js","python"],"title":"Js混淆-源码乱码","uri":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/"},{"categories":["爬虫"],"content":"思路分析 ","date":"2021-01-23","objectID":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/:2:0","tags":["js","python"],"title":"Js混淆-源码乱码","uri":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/"},{"categories":["爬虫"],"content":"关闭断点 看着好像不难，但是打开F12的时候，会出现这个页面，发现无法查看数据。 这是debug断点，直接关闭，继续运行。 ","date":"2021-01-23","objectID":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/:2:1","tags":["js","python"],"title":"Js混淆-源码乱码","uri":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/"},{"categories":["爬虫"],"content":"查看数据 发现数据以json格式存放，那么我们只要拿到这个url地址，就能拿到所有数据 ","date":"2021-01-23","objectID":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/:2:2","tags":["js","python"],"title":"Js混淆-源码乱码","uri":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/"},{"categories":["爬虫"],"content":"分析url 把这几页的url都拿出来看看 http://match.yuanrenxue.com/api/match/1?m=5b6658c234a4d3b9a334bb7a652c6483%E4%B8%A81611585722 http://match.yuanrenxue.com/api/match/1?page=2\u0026m=6ab86178933c0ff456e01ebb40a9e9e1%E4%B8%A81611585928 http://match.yuanrenxue.com/api/match/1?page=3\u0026m=c531e3e5f28835032f9da3fc4e88718d%E4%B8%A81611585938 参数很明显了，一共有两个参数。page是页码，m是一个未知参数。 %E4%B8%A8是url转码后的东西，解码出来是丨（一个中文符号）。后面的东西会随着时间推移改变，根据经验也知道这一定是个时间戳。于是现在就是要分析前面的一堆字符是什么，看样子是经过加密后的东西。 但是！！！经过测试发现在不同的时间段，同一个数据的url都不一样，时间戳改变可以理解，那为什么加密的部分也会改变呢？我们是否可以猜测，前面加密部分的动态改变，有时间戳的参与的可能？ ","date":"2021-01-23","objectID":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/:2:3","tags":["js","python"],"title":"Js混淆-源码乱码","uri":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/"},{"categories":["爬虫"],"content":"如何寻找m的加密过程—\u003e| 当时我就卡在这里了，如何去找到m参数的加密过程。尝试直接搜索m是行不通的，因为这个文件里m太多了。后来猜测m可能是由三部分拼接的，加密字符串+|+时间戳。那么在这个过程中，|就至关重要了。试着搜索看看，果然有惊喜，找到了一段js。我们把这段js复制下来，格式化以后，删除后面的ajax部分，最终得到如下代码： window.url = '/api/match/1'; request = function() { var timestamp = Date.parse(new Date()) + 100000000; var m = oo0O0(timestamp.toString()) + window.f; var list = { \"page \": window.page, \"m \": m + '丨' + timestamp / 1000 }; request() 到这里似乎说不通了，我当时也有点懵，实际上 \"m \": m + '丨' + timestamp / 1000只是list里面的一个参数的值，而我们这里需要的是变量m，即list里面的值与我们想要的无关，而m = oo0O0(timestamp.toString()) + window.f正好印证了我们刚刚的猜测，前面加密部分的字符串有时间戳的参与，于是继续精简 var timestamp = Date.parse(new Date()) + 100000000; var m = oo0O0(timestamp.toString()) + window.f; 可得所需要的m参数是由以上两行代码完成的，此时可以大胆的猜想一下，timestamp应该是一个时间戳，timestamp.toString()应该是一个转换为字符串的函数，传入oo0O0()中，一完成了某些操作，再与window.f的值相加。 于是我们的突破口来了，分别是oo0O0()函数和window.f 。 ","date":"2021-01-23","objectID":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/:2:4","tags":["js","python"],"title":"Js混淆-源码乱码","uri":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/"},{"categories":["爬虫"],"content":"进一步跟踪 window.f 窗口这个对象调用了f,至于f是什么东西,我们先不管。先来看oo0O0()函数。发现还是在上面搜索时的地方，我们把定义这个函数的部分截取下来。 function oo0O0(mw) { window.b = ''; for (var i = 0, len = window.a.length; i \u003c len; i++) { console.log(window.a[i]); window.b += String[document.e + document.g](window.a[i][document.f + document.h]() - i - window.c) } var U = ['W5r5W6VdIHZcT8kU', 'WQ8CWRaxWQirAW==']; var J = function (o, E) { o = o - 0x0; var N = U[o]; if (J['bSSGte'] === undefined) { var Y = function (w) { var m = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=', T = String(w)['replace'](/=+$/, ''); var A = ''; for (var C = 0x0, b, W, l = 0x0; W = T['charAt'](l++); ~W \u0026\u0026 (b = C % 0x4 ? b * 0x40 + W : W, C++ % 0x4) ? A += String['fromCharCode'](0xff \u0026 b \u003e\u003e (-0x2 * C \u0026 0x6)) : 0x0) { W = m['indexOf'](W) } return A }; var t = function (w, m) { var T = [], A = 0x0, C, b = '', W = ''; w = Y(w); for (var R = 0x0, v = w['length']; R \u003c v; R++) { W += '%' + ('00' + w['charCodeAt'](R)['toString'](0x10))['slice'](-0x2) } w = decodeURIComponent(W); var l; for (l = 0x0; l \u003c 0x100; l++) { T[l] = l } for (l = 0x0; l \u003c 0x100; l++) { A = (A + T[l] + m['charCodeAt'](l % m['length'])) % 0x100, C = T[l], T[l] = T[A], T[A] = C } l = 0x0, A = 0x0; for (var L = 0x0; L \u003c w['length']; L++) { l = (l + 0x1) % 0x100, A = (A + T[l]) % 0x100, C = T[l], T[l] = T[A], T[A] = C, b += String['fromCharCode'](w['charCodeAt'](L) ^ T[(T[l] + T[A]) % 0x100]) } return b }; J['luAabU'] = t, J['qlVPZg'] = {}, J['bSSGte'] = !![] } var H = J['qlVPZg'][o]; return H === undefined ? (J['TUDBIJ'] === undefined \u0026\u0026 (J['TUDBIJ'] = !![]), N = J['luAabU'](N, E), J['qlVPZg'][o] = N) : N = H, N }; eval(atob(window['b'])[J('0x0', ']dQW')](J('0x1', 'GTu!'), '\\x27' + mw + '\\x27')); return '' } 代码有点长，压缩一部分， 很amazing啊，清晰的看到返回值居然是空字符串。这意味着 [ var m = window.f ]，那我们只能很不幸的得到以下这个结论： var m = oo0O0(timestamp.toString()) + window.f; //之前 var m = window.f //之后 可是window.f是什么东西啊 ","date":"2021-01-23","objectID":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/:2:5","tags":["js","python"],"title":"Js混淆-源码乱码","uri":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/"},{"categories":["爬虫"],"content":"寻找window.f –\u003eeval() 怎么找到window.f，首先我能想到的,就是去源码中搜索,但是结果并没有那么理想,只出现了一处代码,也就是刚刚那一处代码 在源码中找不到,但是又使用了window.f，肯定是通过间接的方式定义赋值的,那么它又在在那里定义的呢? 我们再来看一下这行代码 var m = oo0O0(timestamp.toString()) + window.f; oo0O0函数执行了,但是却返回的空值;而且oo0O0()里面却有很多代码,开发者肯定不会这么闲吧。也不排除,开发者写这些没有用的代码误导我们,但是这里面肯定是有内容的。 这就涉及到我的盲区了。。。 JS中的 eval() 函数可计算某个字符串，并执行其中的的 JS 代码。而这个函数也出现在了oo0O0()里面， eval(atob(window['b'])[J('0x0', ']dQW')](J('0x1', 'GTu!'), '\\x27' + mw + '\\x27')); eval()里面还调用了一个函数atob()，atob() 方法用于解码使用 base-64 编码的字符串。我们一步步来，先看atob(window['b']是什么，复制到控制台运行后 将代码复制格式化之后得到的是MD5加密算法，非常长，这里截取一部分 通过最后一行代码，我们发现 window.f 出现了，并且通过调用hex_md5()来实现赋值。 但是又出现了一个新的问题，mwqqppz是什么？ ","date":"2021-01-23","objectID":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/:2:6","tags":["js","python"],"title":"Js混淆-源码乱码","uri":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/"},{"categories":["爬虫"],"content":"寻找mwqqppz 再来看一下刚刚的eval代码片段 eval(atob(window['b'])[J('0x0', ']dQW')](J('0x1', 'GTu!'), '\\x27' + mw + '\\x27')); 可以看到eval函数里面除了atob(window[‘b’],还有 J('0x0', ']dQW') J('0x1', 'GTu!') '\\x27' + mw + '\\x27' 我们再到调试工具的Console运行一下上面列出来的代码 这是因为oo0O0()函数里面还有一些代码段没有执行 我们先把oo0O0()函数里面eval函数上面的所有代码复制,然后去Console中运行一下 var U = ['W5r5W6VdIHZcT8kU', 'WQ8CWRaxWQirAW==']; var J = function (o, E) { o = o - 0x0; var N = U[o]; if (J['bSSGte'] === undefined) { var Y = function (w) { var m = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=', T = String(w)['replace'](/=+$/, ''); var A = ''; for (var C = 0x0, b, W, l = 0x0; W = T['charAt'](l++); ~W \u0026\u0026 (b = C % 0x4 ? b * 0x40 + W : W, C++ % 0x4) ? A += String['fromCharCode'](0xff \u0026 b \u003e\u003e (-0x2 * C \u0026 0x6)) : 0x0) { W = m['indexOf'](W) } return A }; var t = function (w, m) { var T = [], A = 0x0, C, b = '', W = ''; w = Y(w); for (var R = 0x0, v = w['length']; R \u003c v; R++) { W += '%' + ('00' + w['charCodeAt'](R)['toString'](0x10))['slice'](-0x2) } w = decodeURIComponent(W); var l; for (l = 0x0; l \u003c 0x100; l++) { T[l] = l } for (l = 0x0; l \u003c 0x100; l++) { A = (A + T[l] + m['charCodeAt'](l % m['length'])) % 0x100, C = T[l], T[l] = T[A], T[A] = C } l = 0x0, A = 0x0; for (var L = 0x0; L \u003c w['length']; L++) { l = (l + 0x1) % 0x100, A = (A + T[l]) % 0x100, C = T[l], T[l] = T[A], T[A] = C, b += String['fromCharCode'](w['charCodeAt'](L) ^ T[(T[l] + T[A]) % 0x100]) } return b }; J['luAabU'] = t, J['qlVPZg'] = {}, J['bSSGte'] = !![] } var H = J['qlVPZg'][o]; return H === undefined ? (J['TUDBIJ'] === undefined \u0026\u0026 (J['TUDBIJ'] = !![]), N = J['luAabU'](N, E), J['qlVPZg'][o] = N) : N = H, N }; 然后依次运行 此时 mwqqppz 出现了 ","date":"2021-01-23","objectID":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/:2:7","tags":["js","python"],"title":"Js混淆-源码乱码","uri":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/"},{"categories":["爬虫"],"content":"翻译eval()函数 知道eval()函数里面的奇怪符号的意义后,我们就可以翻译一下eval()代码片段 eval(atob(window['b'])[J('0x0', ']dQW')](J('0x1', 'GTu!'), '\\x27' + mw + '\\x27'));\\\\原来的 eval(atob(window['b'])[\"replace\"](\"mwqqppz\",'mw'));\\\\翻译后的 使用Python重写： eval(atob(window['b']).replace(\"mwqqppz\",'mw')); 而mw是什么？是oo0O0()函数的一个形参，回顾前面的代码 var timestamp = Date.parse(new Date()) + 100000000; var m = oo0O0(timestamp.toString()) + window.f; function oo0O0(mw) { ... } 可见，其传入的就是一个字符串时间戳 ","date":"2021-01-23","objectID":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/:2:8","tags":["js","python"],"title":"Js混淆-源码乱码","uri":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/"},{"categories":["爬虫"],"content":"思路整理+验证 很清晰的我们可以得出 var timestamp = Date.parse(new Date()) + 100000000; var m = oo0O0(timestamp.toString()) + window.f; var m = window.f; var m = hex_md5(mwqqppz); var m = hex_md5(timestamp); 改写一下js文件，直接把时间戳带入，加载代码，对比相同，成功 ","date":"2021-01-23","objectID":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/:2:9","tags":["js","python"],"title":"Js混淆-源码乱码","uri":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/"},{"categories":["爬虫"],"content":"JS加密部分代码 var hexcase = 0; var b64pad = \"\"; var chrsz = 16; function hex_md5(a) { return binl2hex(core_md5(str2binl(a), a.length * chrsz)) } function b64_md5(a) { return binl2b64(core_md5(str2binl(a), a.length * chrsz)) } function str_md5(a) { return binl2str(core_md5(str2binl(a), a.length * chrsz)) } function hex_hmac_md5(a, b) { return binl2hex(core_hmac_md5(a, b)) } function b64_hmac_md5(a, b) { return binl2b64(core_hmac_md5(a, b)) } function str_hmac_md5(a, b) { return binl2str(core_hmac_md5(a, b)) } function md5_vm_test() { return hex_md5(\"abc\") == \"900150983cd24fb0d6963f7d28e17f72\" } function core_md5(p, k) { p[k \u003e\u003e 5] |= 128 \u003c\u003c ((k) % 32); p[(((k + 64) \u003e\u003e\u003e 9) \u003c\u003c 4) + 14] = k; var o = 1732584193; var n = -271733879; var m = -1732584194; var l = 271733878; for (var g = 0; g \u003c p.length; g += 16) { var j = o; var h = n; var f = m; var e = l; o = md5_ff(o, n, m, l, p[g + 0], 7, -680976936); l = md5_ff(l, o, n, m, p[g + 1], 12, -389564586); m = md5_ff(m, l, o, n, p[g + 2], 17, 606105819); n = md5_ff(n, m, l, o, p[g + 3], 22, -1044525330); o = md5_ff(o, n, m, l, p[g + 4], 7, -176418897); l = md5_ff(l, o, n, m, p[g + 5], 12, 1200080426); m = md5_ff(m, l, o, n, p[g + 6], 17, -1473231341); n = md5_ff(n, m, l, o, p[g + 7], 22, -45705983); o = md5_ff(o, n, m, l, p[g + 8], 7, 1770035416); l = md5_ff(l, o, n, m, p[g + 9], 12, -1958414417); m = md5_ff(m, l, o, n, p[g + 10], 17, -42063); n = md5_ff(n, m, l, o, p[g + 11], 22, -1990404162); o = md5_ff(o, n, m, l, p[g + 12], 7, 1804660682); l = md5_ff(l, o, n, m, p[g + 13], 12, -40341101); m = md5_ff(m, l, o, n, p[g + 14], 17, -1502002290); n = md5_ff(n, m, l, o, p[g + 15], 22, 1236535329); o = md5_gg(o, n, m, l, p[g + 1], 5, -165796510); l = md5_gg(l, o, n, m, p[g + 6], 9, -1069501632); m = md5_gg(m, l, o, n, p[g + 11], 14, 643717713); n = md5_gg(n, m, l, o, p[g + 0], 20, -373897302); o = md5_gg(o, n, m, l, p[g + 5], 5, -701558691); l = md5_gg(l, o, n, m, p[g + 10], 9, 38016083); m = md5_gg(m, l, o, n, p[g + 15], 14, -660478335); n = md5_gg(n, m, l, o, p[g + 4], 20, -405537848); o = md5_gg(o, n, m, l, p[g + 9], 5, 568446438); l = md5_gg(l, o, n, m, p[g + 14], 9, -1019803690); m = md5_gg(m, l, o, n, p[g + 3], 14, -187363961); n = md5_gg(n, m, l, o, p[g + 8], 20, 1163531501); o = md5_gg(o, n, m, l, p[g + 13], 5, -1444681467); l = md5_gg(l, o, n, m, p[g + 2], 9, -51403784); m = md5_gg(m, l, o, n, p[g + 7], 14, 1735328473); n = md5_gg(n, m, l, o, p[g + 12], 20, -1921207734); o = md5_hh(o, n, m, l, p[g + 5], 4, -378558); l = md5_hh(l, o, n, m, p[g + 8], 11, -2022574463); m = md5_hh(m, l, o, n, p[g + 11], 16, 1839030562); n = md5_hh(n, m, l, o, p[g + 14], 23, -35309556); o = md5_hh(o, n, m, l, p[g + 1], 4, -1530992060); l = md5_hh(l, o, n, m, p[g + 4], 11, 1272893353); m = md5_hh(m, l, o, n, p[g + 7], 16, -155497632); n = md5_hh(n, m, l, o, p[g + 10], 23, -1094730640); o = md5_hh(o, n, m, l, p[g + 13], 4, 681279174); l = md5_hh(l, o, n, m, p[g + 0], 11, -358537222); m = md5_hh(m, l, o, n, p[g + 3], 16, -722881979); n = md5_hh(n, m, l, o, p[g + 6], 23, 76029189); o = md5_hh(o, n, m, l, p[g + 9], 4, -640364487); l = md5_hh(l, o, n, m, p[g + 12], 11, -421815835); m = md5_hh(m, l, o, n, p[g + 15], 16, 530742520); n = md5_hh(n, m, l, o, p[g + 2], 23, -995338651); o = md5_ii(o, n, m, l, p[g + 0], 6, -198630844); l = md5_ii(l, o, n, m, p[g + 7], 10, 11261161415); m = md5_ii(m, l, o, n, p[g + 14], 15, -1416354905); n = md5_ii(n, m, l, o, p[g + 5], 21, -57434055); o = md5_ii(o, n, m, l, p[g + 12], 6, 1700485571); l = md5_ii(l, o, n, m, p[g + 3], 10, -1894446606); m = md5_ii(m, l, o, n, p[g + 10], 15, -1051523); n = md5_ii(n, m, l, o, p[g + 1], 21, -2054922799); o = md5_ii(o, n, m, l, p[g + 8], 6, 1873313359); l = md5_ii(l, o, n, m, p[g + 15], 10, -30611744); m = md5_ii(m, l, o, n, p[g + 6], 15, -1560198380); n = md5_ii(n, m, l, o, p[g + 13], 21, 1309151649); o = md5_ii(o, n, m, l, p[g + 4], 6, -145523070); l = md5_ii(l, o, n, m, p[g + 11], 10, -1120210379); m = md5_ii(m, l, o, n, p[g + 2], 15, 718787259","date":"2021-01-23","objectID":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/:3:0","tags":["js","python"],"title":"Js混淆-源码乱码","uri":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/"},{"categories":["爬虫"],"content":"爬虫代码 import requests import execjs import time def get_psd_m(): #导入js文件 with open(r'get_m.js', encoding='utf-8', mode='r') as f: JsData = f.read() # 加载js文件,使用call()函数执行,传入需要执行函数即可获取返回值 psd = execjs.compile(JsData).call('yanzheng') psd = psd.replace('丨', '%E4%B8%A8') return psd def get_data(page,psd): url = \"http://match.yuanrenxue.com/api/match/1?page={}\u0026m={}\".format(page, psd) headers = { 'User-Agent':'yuanrenxue.project', 'Referer': 'http://match.yuanrenxue.com/match/1' } r = requests.get(url,headers = headers) return r.json() if __name__ == '__main__': # 初始化每页数据的总和，数据的个数 sum_list = 0 index = 0 for page in range(1,6): info = get_data(page,get_psd_m()) price_list = [i[\"value\"] for i in info[\"data\"]] print(\"这是第{}页的价格列表\\n{}\".format(page,price_list)) # 自加操作 sum_list += sum(price_list) index += len(price_list) # 防止爬取太快 time.sleep(1) avg = sum_list / index print(\"平均价格为{}\".format(avg)) 运行结果： ","date":"2021-01-23","objectID":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/:4:0","tags":["js","python"],"title":"Js混淆-源码乱码","uri":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/"},{"categories":["爬虫"],"content":"题目总结 这是整个比赛题中的第一题，题目难度标注为简单。但是对我这个菜鸟来说，一上来就被卡在了前几步。阅读几位大佬的博客之后，对这道题有了一个大致的把握。在JS的逆向方面，一步一步的去分析代码，思考通过什么关键词去定位函数，注意是否在调用时发生了变化。 本题名字叫JS混淆，我也不知道具体混淆的意思。但是在对JS的分析当中，似乎在eval()部分用到了很简单的混淆，把某些函数名和参数使用它自己的js加密，成为一个个看似毫无里头的字符串，我们要做的就是把它翻译回去。 最后，非常感谢 Java_S 大佬的博客，参考了很多内容。他的分析思路非常清晰，步骤详细，代码干净简洁，看着太舒了，，，，向大佬学习。 ","date":"2021-01-23","objectID":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/:5:0","tags":["js","python"],"title":"Js混淆-源码乱码","uri":"/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81/"},{"categories":["python笔记"],"content":"函数返回值 return是函数结束的标志，即函数代码一旦运行到return会立即终止，并将return后的值当做本次运行的结果返回。 1、返回None: 函数体内没有return 2、返回一个值：return 值 3、返回多个值：用逗号分隔开多个值，会被return返回成元组。 ","date":"2021-01-13","objectID":"/%E8%A3%85%E9%A5%B0%E5%99%A8-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E7%94%9F%E6%88%90%E5%99%A8/:0:1","tags":["python"],"title":"装饰器 迭代器 生成器","uri":"/%E8%A3%85%E9%A5%B0%E5%99%A8-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["python笔记"],"content":"可变长度的参数 可变长度指的是在调用函数时，传入的值（实参）的个数不固定。 实参是用来为形参赋值的，所以针对溢出的实参必须有对应的形参来接收。 可变长度的位置参数 *形参名：用来接收溢出的关键字参数，溢出的位置实参会被*保存成元组的格式然后赋值给紧跟其后的形参名。 约定俗成使用*args def foo(x,y,z=1,*args): #在最后一个形参名args前加*号 print(x) print(y) print(z) print(args) \u003e\u003e\u003e foo(1,2,3,4,5,6,7) #实参1、2、3按位置为形参x、y、z赋值，多余的位置实参4、5、6、7都被*接收，以元组的形式保存下来，赋值给args，即args=(4, 5, 6,7) 1 2 3 (4, 5, 6, 7) *可以用在实参中，实参中带*，打散成位置实参,再传值。类似于js中的解构赋值。 # *可以用在实参中，实参中带*，先*后的值打散成位置实参 def func(x,y,z): print(x,y,z) func(*[11,22,33]) # func(11，22，33) func(*[11,22]) # func(11，22) # 形参与实参中都带* def func(x,y,*args): # args=(3,4,5,6) print(x,y,args) func(1,2,[3,4,5,6]) func(1,2,*[3,4,5,6]) # func(1,2,3,4,5,6) func(*'hello') # func('h','e','l','l','o') 可变长度的关键字参数 **形参名：用来接收溢出的关键字参数，溢出的位置实参会被*保存成字典的格式然后赋值给紧跟其后的形参名。 约定俗成使用**kwargs def foo(x,**kwargs): #在最后一个参数kwargs前加** print(x) print(kwargs) foo(y=2,x=1,z=3) #溢出的关键字实参y=2，z=3都被**接收，以字典的形式保存下来，赋值给kwargs 1 {'z': 3, 'y': 2} **可以用于实参中（**后只能跟字典），实参中带有**，先**后的值打散成关键字实参。 # I：**形参名：用来接收溢出的关键字实参，**会将溢出的关键字实参保存成字典格式，然后赋值给紧跟其后的形参名 # **后跟的可以是任意名字，但是约定俗成应该是kwargs def func(x,y,**kwargs): print(x,y,kwargs) func(1,y=2,a=1,b=2,c=3) # II: **可以用在实参中(**后跟的只能是字典)，实参中带**，先**后的值打散成关键字实参 def func(x,y,z): print(x,y,z) func(*{'x':1,'y':2,'z':3}) # func('x','y','z') func(**{'x':1,'y':2,'z':3}) # func(x=1,y=2,z=3) # 错误 func(**{'x':1,'y':2,}) # func(x=1,y=2) func(**{'x':1,'a':2,'z':3}) # func(x=1,a=2,z=3) # III: 形参与实参中都带** def func(x,y,**kwargs): print(x,y,kwargs) func(y=222,x=111,a=333,b=444) func(**{'y':222,'x':111,'a':333,'b':4444}) 混用*与** *args必须在**kwargs之前。 所有参数可任意组合使用，但定义顺序必须是：位置参数、默认参数、args、命名关键字参数、*kwargs 可变参数*args与关键字参数kwargs通常是组合在一起使用的，如果一个函数的形参为*args与kwargs，那么代表该函数可以接收任何形式、任意长度的参数 def wrapper(*args,**kwargs): pass 该函数内部还可以把接收到的参数传给另外一个函数。 def func(x,y,z): print(x,y,z) def wrapper(*args,**kwargs): func(*args,**kwargs) wrapper(1,z=3,y=2) 1 2 3 即在为函数wrapper传参时，其实遵循的是函数func的参数规则，调用函数wrapper的过程分析如下： 位置实参1被接收，以元组的形式保存下来，赋值给args，即args=(1,),关键字实参z=3，y=2被*接收，以字典的形式保存下来，赋值给kwargs，即kwargs={'y': 2, 'z': 3} 执行func(args,kwargs),即func((1,),* {'y': 2, 'z': 3}),等同于func(1,z=3,y=2)。 此方法后面装饰器会用到。 来源： https://zhuanlan.zhihu.com/p/108907210 2021.1.10 ","date":"2021-01-13","objectID":"/%E8%A3%85%E9%A5%B0%E5%99%A8-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E7%94%9F%E6%88%90%E5%99%A8/:0:2","tags":["python"],"title":"装饰器 迭代器 生成器","uri":"/%E8%A3%85%E9%A5%B0%E5%99%A8-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["python笔记"],"content":"闭包函数 前提条件： 闭包函数 = 名称空间与作用域+函数嵌套+函数对象。 核心点：名字的查找关系是以函数定义阶段为准。 什么是闭包函数： 闭：指该函数是内嵌函数。 包：指的是该函数对外层函数作用域名字的引用（不是对全局作用域）。 作用： 目前为止，我们得到了两种为函数体传值的方式，一种是直接将值以参数的形式传入，另外一种就是将值包给函数 import requests #方式一： def get(url): return requests.get(url).text #方式二： def page(url): def get(): return requests.get(url).text return get 对比两种方式，方式一在下载同一页面时需要重复传入url，而方式二只需要传一次值，就会得到一个包含指定url的闭包函数，以后调用该闭包函数无需再传url。 # 方式一下载同一页面 get('https://www.python.org') get('https://www.python.org') get('https://www.python.org') …… # 方式二下载同一页面 python=page('https://www.python.org') python() python() python() …… 闭包函数的这种特性有时又称为惰性计算。使用将值包给函数的方式，在接下来的装饰器中也将大有用处。 个人总结： 通过以上案例可以看到，我们想要为一个函数体传参，有两种方式。 一种为直接传参，定义的函数作用于全局变量，直接传入参数即可。 而第二种很巧妙，把值包给函数。在全局变量下的函数get()上，再包一层函数page()，那么原函数get()就变成了一个内嵌函数。本来get()函数是无法与外界沟通的，但是通过return这个函数名，即返回此函数的内存地址，这样，通过外层函数的调用page('https://www.python.org')赋值给变量python。此变量的值就是内层函数的内存地址，加上()，即可调用内层函数，实现传参的目的。 资料来源： 1、https://www.bilibili.com/video/BV1QE41147hU?p=232 2、https://zhuanlan.zhihu.com/p/109056932 ","date":"2021-01-13","objectID":"/%E8%A3%85%E9%A5%B0%E5%99%A8-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E7%94%9F%E6%88%90%E5%99%A8/:0:3","tags":["python"],"title":"装饰器 迭代器 生成器","uri":"/%E8%A3%85%E9%A5%B0%E5%99%A8-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["python笔记"],"content":"装饰器 什么是装饰器：装饰器指的定义一个函数，该函数是用来为其他函数添加额外的功能。 为什么要用装饰器：开放封闭原则 开放：指的是对拓展功能是开放的 封闭：指的是对修改源代码是封闭的 装饰器就是在不修改被装饰器对象源代码以及调用方式的情况下新的功能。 无参装饰器 偷梁换柱之瞒天过海: 原理：将原函数名指向的内存地址偷梁换柱成wrapper函数，再将wrapper函数的内存地址赋值给一个与原函数名相同的变量，加上()，就跟原函数调用一模一样的了。 实现方法： 1、首先是参数的传入，使用*args,**kwargs可以实现对任何个数的参数原封不动的通过新函数传入给原函数。 2、但是，想实现对任意函数都能被装饰，那么就需要传入函数名，使用闭包函数的方法来实现，这样实现了原函数需要什么参数，通过传递就能给什么参数。 3、若函数有返回值，就需要对返回值进行模拟。直接把原函数赋值给一个变量res,此变量接收原函数返回值，再到新函数里重新返回一次。至此，偷梁换柱完成。 def outter(func): def wrapper(*args,**kwargs) res = func(*args,**kwargs) return res return wrapper 语法糖：@名字后面def home()==\u003ehome=名字(home) ==\u003e即把原先的home()内存地址替换为新的添加装饰器之后的内存地址。不用再写home = outer(home)了。 资料来源： 1、https://www.bilibili.com/video/BV1QE41147hU?p=242 2、https://zhuanlan.zhihu.com/p/109078881 有参装饰器 由于语法糖@的限制，outter函数只能有一个参数，并且该参数只能用来接收被装饰对象的内存地址。 @名字(参数1，···) def 有参装饰器(x,y,z) def outter(func): def wrapper(*args,**kwargs) res = func(*args,**kwargs) return res return wrapper @有参装饰器(1,y=2,z=3) def 被装饰对象(): pass 至此，最多三层，就可以实现其余任意参数的传递。 多个装饰器叠加分析 加载顺序：自下而上 执行顺序：自上而下，即wrapper1==\u003ewrapper2==\u003ewrapper3 资料来源： 1、https://www.bilibili.com/video/BV1QE41147hU?p=249 2、https://zhuanlan.zhihu.com/p/109078881 3、https://www.bilibili.com/video/BV1QE41147hU?p=257 ","date":"2021-01-13","objectID":"/%E8%A3%85%E9%A5%B0%E5%99%A8-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E7%94%9F%E6%88%90%E5%99%A8/:0:4","tags":["python"],"title":"装饰器 迭代器 生成器","uri":"/%E8%A3%85%E9%A5%B0%E5%99%A8-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["python笔记"],"content":"迭代器 什么是迭代器：迭代器指的是迭代取值的工具，迭代是一个重复的过程，且每次重复都是基于上一次的结果而继续的，单纯的复制并不是迭代。 为什么要有迭代器：通过索引的方式进行迭代取值，但仅适用于序列类型：字符串，列表，元组。对于没有索引的字典、集合等非序列类型，必须找到一种不依赖索引来进行迭代取值的方式，这就用到了迭代器。 如何用迭代器：只要内置有__iter__方法的都可称之为可迭代对象。 for循环原理 有了迭代器后，我们便可以不依赖索引迭代取值了，使用while循环的实现方式如下 goods=['mac','lenovo','acer','dell','sony'] i=iter(goods) #每次都需要重新获取一个迭代器对象 while True: try: print(next(i)) except StopIteration: #捕捉异常终止循环 break for循环又称为迭代循环，in后可以跟任意可迭代对象，上述while循环可以简写为 goods=['mac','lenovo','acer','dell','sony'] for item in goods: print(item) for 循环在工作时，首先会调用可迭代对象goods内置的iter方法拿到一个迭代器对象，然后再调用该迭代器对象的next方法将取到的值赋给item,执行循环体完成一次循环，周而复始，直到捕捉StopIteration异常，结束迭代。 迭代器的优缺点 优点： 为序列和非序列类型提供了一种统一的迭代取值方式。 惰性计算：迭代器对象表示的是一个数据流，可以只在需要时才去调用next来计算出一个值，就迭代器本身来说，同一时刻在内存中只有一个值，因而可以存放无限大的数据流，而对于其他容器类型，如列表，需要把所有的元素都存放于内存中，受内存大小的限制，可以存放的值的个数是有限的。 缺点： 除非取尽，否则无法获取迭代器的长度 只能取下一个值，不能回到开始，更像是‘一次性的’，迭代器产生后的唯一目标就是重复执行next方法直到值取尽，否则就会停留在某个位置，等待下一次调用next；若是要再次迭代同个对象，你只能重新调用iter方法去创建一个新的迭代器对象，如果有两个或者多个循环使用同一个迭代器，必然只会有一个循环能取到值。 ","date":"2021-01-13","objectID":"/%E8%A3%85%E9%A5%B0%E5%99%A8-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E7%94%9F%E6%88%90%E5%99%A8/:0:5","tags":["python"],"title":"装饰器 迭代器 生成器","uri":"/%E8%A3%85%E9%A5%B0%E5%99%A8-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["python笔记"],"content":"生成器 若函数体包含yield关键字，再调用函数，并不会执行函数体代码，得到的返回值即生成器对象 \u003e\u003e\u003e def my_range(start,stop,step=1): print('start...') while start \u003c stop: yield start start+=step print('end...') \u003e\u003e\u003e g=my_range(0,3) \u003e\u003e\u003e g \u003cgenerator object my_range at 0x104105678\u003e 生成器内置有__iter__和__next__方法，所以生成器本身就是一个迭代器 \u003e\u003e\u003e g.__iter__ \u003cmethod-wrapper '__iter__' of generator object at 0x1037d2af0\u003e \u003e\u003e\u003e g.__next__ \u003cmethod-wrapper '__next__' of generator object at 0x1037d2af0\u003e 因而我们可以用next(生成器)触发生成器所对应函数的执行， \u003e\u003e\u003e next(g) # 触发函数执行直到遇到yield则停止,将yield后的值返回，并在当前位置挂起函数 start... 0 \u003e\u003e\u003e next(g) # 再次调用next(g)，函数从上次暂停的位置继续执行，直到重新遇到yield... 1 \u003e\u003e\u003e next(g) # 周而复始... 2 \u003e\u003e\u003e next(g) # 触发函数执行没有遇到yield则无值返回，即取值完毕抛出异常结束迭代 end... Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e StopIteration 既然生成器对象属于迭代器，那么必然可以使用for循环迭代，如下 \u003e\u003e\u003e for i in countdown(3): print(i) countdown start 3 2 1 Done! 有了yield关键字，我们就有了一种自定义迭代器的实现方式。yield可以用于返回值，但不同于return，函数一旦遇到return就结束了，而yield可以保存函数的运行状态挂起函数，用来返回多次值。next用来触发函数运行。 ","date":"2021-01-13","objectID":"/%E8%A3%85%E9%A5%B0%E5%99%A8-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E7%94%9F%E6%88%90%E5%99%A8/:0:6","tags":["python"],"title":"装饰器 迭代器 生成器","uri":"/%E8%A3%85%E9%A5%B0%E5%99%A8-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["Python"],"content":"背景 室友因工作需要，要导出大创网的互联网+项目后台学校里面的详细数据。在官网只能导出当前页面的所有项目，一页只显示20个项目。学校总共有1842个，93页的数据，如果一页一页点击导出不太现实。所以想到使用Python来实现。（小声bb）那么大的一个网站，竟然没有考虑一键导出全部详细数据的功能，，，绝了。 ","date":"2020-12-27","objectID":"/%E4%BD%BF%E7%94%A8pandas%E5%90%88%E5%B9%B6%E8%A1%A8%E6%A0%BC/:0:1","tags":["迁移"],"title":"使用Pandas合并表格","uri":"/%E4%BD%BF%E7%94%A8pandas%E5%90%88%E5%B9%B6%E8%A1%A8%E6%A0%BC/"},{"categories":["Python"],"content":"分析流程 1、打开大创网后台，发现页面内容是通过js动态加载的。网址不会随着页码的变化而变化。 果断抓包，通过url寻找接口 第一页：https://cy.ncss.cn/contestmanage/contestCount?provinceCode=\u0026schoolCode=\u0026schoolType=\u0026provinceAward=\u0026keyWord=\u0026trackCode=\u0026stage=-9\u0026award=\u0026industryCode=\u0026groupCode=\u0026progress=\u0026isInvest=\u0026pageIndex=0\u0026pageSize=20\u0026diplomaLevelCode=\u0026_=1603205904460 第二页：https://cy.ncss.cn/contestmanage/contestList?provinceCode=\u0026schoolCode=\u0026schoolType=\u0026provinceAward=\u0026keyWord=\u0026trackCode=\u0026stage=-9\u0026award=\u0026industryCode=\u0026groupCode=\u0026progress=\u0026isInvest=\u0026pageIndex=1\u0026pageSize=20\u0026diplomaLevelCode=\u0026_=1603205904463 2、经过对url删减测试，发现pageSize用于控制页面显示项目数量。pageIndex用于显示页数。后面其余参数都可省略。 最终拿到url为https://cy.ncss.cn/contestmanage/contestList?provinceCode=\u0026schoolCode=\u0026schoolType=\u0026provinceAward=\u0026keyWord=\u0026trackCode=\u0026stage=-9\u0026award=\u0026industryCode=\u0026groupCode=\u0026progress=\u0026isInvest=\u0026pageIndex={}\u0026pageSize=20 3、在审查元素中，发现下载页面的url很有意思，下载直接就是.xlsx的文件。https://cy.ncss.cn/contestmanage/exportcontestdetails?contestIds=后面跟了很多串特定规格字符串，contestIds=这个很像是项目的id。果不其然，通过审查元素，xpath定位，每一个tr标签里的值就是id。而这个网址传入多少id，那么下载的文件里面就有id对应的项目。经过测试，60个id为最大上限，不然就直接报错。 4、拿到下载地址，写个循环，结束下载，可是下载完成后由93个表格数据。 5、使用os对文件夹下的93个表格进行循环，拿到每个数据的路径，再通过pandas库合并其余表格到一个新表格,结束。 ","date":"2020-12-27","objectID":"/%E4%BD%BF%E7%94%A8pandas%E5%90%88%E5%B9%B6%E8%A1%A8%E6%A0%BC/:0:2","tags":["迁移"],"title":"使用Pandas合并表格","uri":"/%E4%BD%BF%E7%94%A8pandas%E5%90%88%E5%B9%B6%E8%A1%A8%E6%A0%BC/"},{"categories":["Python"],"content":"代码 1、下载全部数据表格 import requests from lxml import etree import os headers = { \"cookie\":\"\", \"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.116 Safari/537.36\"} path = r\"C:\\Users\\lenovo\\Desktop\" PATH = os.path.join(path,'css').replace('\\\\','/') print(PATH) if not os.path.exists(PATH): os.mkdir(PATH) print(\"下载路径：\"+PATH) for i in range(0,93): idss = \"\" url = \"https://cy.ncss.cn/contestmanage/contestList?provinceCode=\u0026schoolCode=\u0026schoolType=\u0026provinceAward=\u0026keyWord=\u0026trackCode=\u0026stage=-9\u0026award=\u0026industryCode=\u0026groupCode=\u0026progress=\u0026isInvest=\u0026pageIndex={}\u0026pageSize=20\".format(i) r = requests.get(url,headers=headers).text ids = etree.HTML(r).xpath(\"/html/body/table/tbody//tr/@data-value\") for a in ids: idss = idss + a +\",\" try: data_url = \"https://cy.ncss.cn/contestmanage/exportcontestdetails?contestIds=\" + idss # print(data_url) r = requests.get(data_url, headers=headers).content # time.sleep(0.5) except Exception as e: print(e) pass print(\"开始下载第{}页\".format(i+1)) print(\"完成\") try: path = os.path.join(PATH, f'{i+1}.xlsx').replace('\\\\', '/') with open(path, 'wb')as f: f.write(r) f.flush() except Exception as e: print(e) print(\"下载失败\") 2、合并表格 import os import pandas as pd list = os.listdir(r'C:\\Users\\lenovo\\Desktop\\css') # print(list) ov_xlsx = pd.DataFrame() for info in list: domain = os.path.abspath(r'C:\\Users\\lenovo\\Desktop\\css') info = os.path.join(domain,info) # print(info) df = pd.read_excel(info,dtype=object) ov_xlsx = ov_xlsx.append(df, ignore_index=True) writer = pd.ExcelWriter(r'C:\\Users\\lenovo\\Desktop\\处理后数据.xlsx', index=False,dtype=object) ov_xlsx.to_excel(writer, index=False) writer.save() ","date":"2020-12-27","objectID":"/%E4%BD%BF%E7%94%A8pandas%E5%90%88%E5%B9%B6%E8%A1%A8%E6%A0%BC/:0:3","tags":["迁移"],"title":"使用Pandas合并表格","uri":"/%E4%BD%BF%E7%94%A8pandas%E5%90%88%E5%B9%B6%E8%A1%A8%E6%A0%BC/"},{"categories":["Python"],"content":"总结 总体思路不复杂，当时测试接口数据花了一部分时间，主要是查询pandas库的用法。 ","date":"2020-12-27","objectID":"/%E4%BD%BF%E7%94%A8pandas%E5%90%88%E5%B9%B6%E8%A1%A8%E6%A0%BC/:0:4","tags":["迁移"],"title":"使用Pandas合并表格","uri":"/%E4%BD%BF%E7%94%A8pandas%E5%90%88%E5%B9%B6%E8%A1%A8%E6%A0%BC/"},{"categories":["Python"],"content":"资料参考 参考知乎大佬： https://zhuanlan.zhihu.com/p/97869613 （此文章由老博客迁移，原链接：http://www.desky2020.xyz/index.php/2020/10/20/22-50/） ","date":"2020-12-27","objectID":"/%E4%BD%BF%E7%94%A8pandas%E5%90%88%E5%B9%B6%E8%A1%A8%E6%A0%BC/:0:5","tags":["迁移"],"title":"使用Pandas合并表格","uri":"/%E4%BD%BF%E7%94%A8pandas%E5%90%88%E5%B9%B6%E8%A1%A8%E6%A0%BC/"},{"categories":["JavaScript"],"content":"引言 快期末了，JS课要交一次大作业。从几个案例中挑选一个，我选的是一个座位预定程序。要求：单击要预定的座位，座位会以某种颜色标识，右侧显示计算的票款和座位信息等。 使用了html+js+css+jQuery，有1说1，这是我第一次使用jQuery插件。 参考资料来源： 1、jQuery-Seat-Charts 官方使用文档 https://github.com/mateuszmarkowski/jQuery-Seat-Charts 2、jQuery在线选座订座 https://www.cnblogs.com/helloweba/p/4108512.html ","date":"2020-12-23","objectID":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/:1:0","tags":["js","jQuery"],"title":"jQuery实现座位选座","uri":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/"},{"categories":["JavaScript"],"content":"关于jQuery-Seat-Charts 使用文档里面很详细了。但是是英文版的。稍微整理了一下。 ","date":"2020-12-23","objectID":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/:2:0","tags":["js","jQuery"],"title":"jQuery实现座位选座","uri":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/"},{"categories":["JavaScript"],"content":"例子 基本设置： $(document).ready(function() { var sc = $('#seat-map').seatCharts({ map: [ 'aaaaaaaaaaaa', 'aaaaaaaaaaaa', 'bbbbbbbbbb__', 'bbbbbbbbbb__', 'bbbbbbbbbbbb', 'cccccccccccc' ], seats: { a: { price : 99.99, classes : 'front-seat' //your custom CSS class } }, click: function () { if (this.status() == 'available') { //do some stuff, i.e. add to the cart return 'selected'; } else if (this.status() == 'selected') { //seat has been vacated return 'available'; } else if (this.status() == 'unavailable') { //seat has been already booked return 'unavailable'; } else { return this.style(); } } }); //Make all available 'c' seats unavailable sc.find('c.available').status('unavailable'); /* Get seats with ids 2_6, 1_7 (more on ids later on), put them in a jQuery set and change some css */ sc.get(['2_6', '1_7']).node().css({ color: '#ffcfcf' }); console.log('Seat 1_2 costs ' + sc.get('1_2').data().price + ' and is currently ' + sc.status('1_2')); }); ","date":"2020-12-23","objectID":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/:2:1","tags":["js","jQuery"],"title":"jQuery实现座位选座","uri":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/"},{"categories":["JavaScript"],"content":"座位图 map: [ 'ff__ff', 'ff__ff', '______', 'eee_ee', 'eee_ee', 'eee_ee', 'eee_ee', 'eee_ee', 'eee_ee' ] 每个字符代表一个不同类型的座位，除下划线_以外的任何人。下划线用于表示在特定位置不应有任何座位。 ","date":"2020-12-23","objectID":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/:2:2","tags":["js","jQuery"],"title":"jQuery实现座位选座","uri":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/"},{"categories":["JavaScript"],"content":"定义座位属性 seats: { //定义座位属性 f: { price : 100, classes : 'first-class', category: '一等座' }, e: { price : 40, classes : 'economy-class', category: '二等座' } }, 上面的代码定义了一等座和二等座的价格、类别名称以及对应的css样式。他们可以在后面通过data()方法调用 ","date":"2020-12-23","objectID":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/:2:3","tags":["js","jQuery"],"title":"jQuery实现座位选座","uri":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/"},{"categories":["JavaScript"],"content":"定义行列等信息 top:是否显示顶部横坐标 columns: 定义横坐标（行） rows: 定义纵坐标（列）的值 getLabe: 用来返回座位信息。 naming : { //定义行列等信息 top : true, columns: ['A', 'B', 'C', '', 'D','F'], rows: ['01','02','','03','04','05','06','07','08','09'], getLabel : function (character, row, column) { return row+column; } }, ","date":"2020-12-23","objectID":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/:2:4","tags":["js","jQuery"],"title":"jQuery实现座位选座","uri":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/"},{"categories":["JavaScript"],"content":"定义图例 `node`: 使用`legend`来定义图例，对应图例关联的元素是`#legend`,并对座位类型定义对应的样式。 `Items`: 每个数组元素应为三元素数组：[字符，状态，描述]。 状态有三种： available: 可以坐的座位 unavailable: 无法坐下的座位 selected: 当前用户已坐下的座位 legend : { //定义图例 node : $('#legend'), items : [ [ 'f', 'available', '一等座' ], [ 'e', 'available', '二等座'], [ 'f', 'unavailable', '已售出'] ] }, ","date":"2020-12-23","objectID":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/:2:5","tags":["js","jQuery"],"title":"jQuery实现座位选座","uri":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/"},{"categories":["JavaScript"],"content":"click事件 if (this.status() == 'available') 如果可选座 else if (this.status() == 'selected') 已选中 else if (this.status() == 'unavailable') 已出售 click: function () { if (this.status() == 'available') {//可选座 $('\u003cli\u003e'+this.data().category+'\u003cbr/\u003e01车'+this.settings.label+'号\u003cbr/\u003e￥'+this.data().price+'\u003c/li\u003e') .attr('id', 'cart-item-'+this.settings.id) .data('seatId', this.settings.id) .appendTo($cart); //更新票数 $counter.text(sc.find('selected').length+1); //计算总计金额 $total.text(recalculateTotal(sc)+this.data().price); return 'selected'; } else if (this.status() == 'selected') {//已选中 $counter.text(sc.find('selected').length-1); $total.text(recalculateTotal(sc)-this.data().price); //删除已预订座位 $('#cart-item-'+this.settings.id).remove(); return 'available'; } else if (this.status() == 'unavailable') {//已售出 //已售出 return 'unavailable'; } else { return this.style(); } }, ","date":"2020-12-23","objectID":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/:2:6","tags":["js","jQuery"],"title":"jQuery实现座位选座","uri":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/"},{"categories":["JavaScript"],"content":"focus,blur事件 focus : function() { if (this.status() == 'available') { //if seat's available, it can be focused return 'focused'; } else { //otherwise nothing changes return this.style(); } }, blur : function() { //The only place where you should return actual seat status return this.status(); }, blur:模糊处理程序。当座椅由于鼠标移动或箭头击中而失去焦点时触发。 focus:焦点处理程序。当座椅获得焦点时触发。 //default handler blur : function() { return this.status(); }, //default handler focus : function() { if (this.status() == 'available') { return 'focused'; } else { return this.style(); } }, ","date":"2020-12-23","objectID":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/:2:7","tags":["js","jQuery"],"title":"jQuery实现座位选座","uri":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/"},{"categories":["JavaScript"],"content":"设定方法 .status（ids，status） 更新具有给定ID的座位组的状态。ids变量可以包含一个id或一个id数组。 sc.status('2_15', 'unvailable'); //set status for one seat sc.status(['2_15', '2_10'], 'unvailable'); //set status for two seats .status( status ) 更新当前集合中所有席位的状态。 sc.find('unavailable').status('available'); //make all unvailable seats available .node( ) 返回jQuery座位节点引用集。 sc.find('unavailable').node().fadeOut('fast'); //make all unavailable seats disappear .each( callback ) 遍历一个座位集，将在每个元素的上下文中触发回调。回调可以接受座位ID作为参数。 sc.find('a.unavailable').each(function(seatId) { console.log(this.data()); //display seat data }); ","date":"2020-12-23","objectID":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/:2:8","tags":["js","jQuery"],"title":"jQuery实现座位选座","uri":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/"},{"categories":["JavaScript"],"content":"案例代码 （js+html部分） \u003c!doctype html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003e选座系统\u003c/title\u003e \u003cmeta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /\u003e \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"css/jquery.seat-charts.css\"\u003e \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"css/style.css\"\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"wrapper\"\u003e \u003cdiv class=\"container\"\u003e \u003cdiv id=\"seat-map\"\u003e \u003cdiv class=\"front-indicator\"\u003e座位表\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"booking-details\"\u003e \u003ch3\u003e已选中的座位 (\u003cspan id=\"counter\"\u003e0\u003c/span\u003e):\u003c/h3\u003e \u003cul id=\"selected-seats\"\u003e \u003c/ul\u003e \u003cp\u003e总价: \u003cb\u003e$\u003cspan id=\"total\"\u003e0\u003c/span\u003e\u003c/b\u003e\u003c/p\u003e \u003cp\u003e\u003cbutton class=\"checkout-button\"\u003e结算\u003c/button\u003e\u003c/p\u003e \u003cdiv id=\"legend\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cscript src=\"js/jquery-1.11.0.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"js/jquery.seat-charts.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e var firstSeatLabel = 1; //定义第一个座位的序号 $(document).ready(function() { var $cart = $('#selected-seats'), $counter = $('#counter'), $total = $('#total'), sc = $('#seat-map').seatCharts({ //座位图 map: [ 'fffff', 'fffff', 'eeeee', 'eeeee', 'eeeee', 'ee_ee', ], //座位属性 seats: { f: { price : 100, classes : 'first-class', //对应的css样式 }, e: { price : 40, classes : 'economy-class', //对应的css样式 category: '普通座位' } }, //定义行列等信息，每一个数字自加操作 naming : { top : false, getLabel : function (character, row, column) { return firstSeatLabel++; }, }, legend : { node : $('#legend'), items : [ [ 'f', 'available', 'VIP座位' ], [ 'e', 'available', '普通座位'], [ 'f', 'unavailable', '已预定'] ] }, click: function () { if (this.status() == 'available') { $('\u003cli\u003e'+this.data().category+this.settings.label+'号座位'+'：\u003cbr/\u003e价格：\u003cb\u003e$'+this.data().price+'\u003c/b\u003e \u003ca href=\"#\" class=\"cancel-cart-item\"\u003e[删除]\u003c/a\u003e\u003c/li\u003e') .attr('id','cart-item-'+this.settings.id) .data('seatId', this.settings.id) .appendTo($cart); $counter.text(sc.find('selected').length+1); $total.text(recalculateTotal(sc)+this.data().price); return 'selected'; } else if (this.status() == 'selected') { //update the counter $counter.text(sc.find('selected').length-1); //and total $total.text(recalculateTotal(sc)-this.data().price); //remove the item from our cart $('#cart-item-'+this.settings.id).remove(); //seat has been vacated return 'available'; } else if (this.status() == 'unavailable') { //seat has been already booked return 'unavailable'; } else { return this.style(); } } }); //this will handle \"[cancel]\" link clicks $('#selected-seats').on('click', '.cancel-cart-item', function () { //let's just trigger Click event on the appropriate seat, so we don't have to repeat the logic here sc.get($(this).parents('li:first').data('seatId')).click(); }); //let's pretend some seats have already been booked sc.get(['1_2', '4_1', '7_1', '7_2']).status('unavailable'); }); function recalculateTotal(sc) { var total = 0; //basically find every selected seat and sum its price sc.find('selected').each(function () { total += this.data().price; }); return total; } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e (css部分) body { font-family: 'Lato', sans-serif; } a { color: #b71a4c; } .front-indicator { width: 145px; margin: 5px 32px 15px 32px; background-color: #f6f6f6; color: #adadad; text-align: center; padding: 3px; border-radius: 5px; } .wrapper { width: 100%; text-align: center; } .container { margin: 0 auto; width: 500px; text-align: left; } .booking-details { float: left; text-align: left; margin-left: 35px; font-size: 12px; position: relative; height: 401px; } .booking-details h2 { margin: 25px 0 20px 0; font-size: 17px; } .booking-details h3 { margin: 5px 5px 0 0; font-size: 14px; } div.seatCharts-cell { color: #182C4E; height: 25px; width: 25px; line-height: 25px; } div.seatCharts-seat { color: #FFFFFF; cursor: pointer; } div.seatCharts-row { height: 35px; } div.seatCharts-seat.available { background-color: #B9DEA0; } div.seatCharts-seat.available.first-class { /* background: url(vip.png); */ background-color: #3a78c3; } div.seatCharts-seat.focused { background-color: #76B474; } div.seatCharts-seat.selected { background-color: #E6CAC4; } div.seatCharts-seat.unavailable { background-color: #ccc; } div.seatCharts-","date":"2020-12-23","objectID":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/:2:9","tags":["js","jQuery"],"title":"jQuery实现座位选座","uri":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/"},{"categories":["JavaScript"],"content":"目录结构 ","date":"2020-12-23","objectID":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/:3:0","tags":["js","jQuery"],"title":"jQuery实现座位选座","uri":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/"},{"categories":["JavaScript"],"content":"运行结果 ","date":"2020-12-23","objectID":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/:4:0","tags":["js","jQuery"],"title":"jQuery实现座位选座","uri":"/jquery%E5%AE%9E%E7%8E%B0%E5%BA%A7%E4%BD%8D%E9%80%89%E5%BA%A7/"},{"categories":["Python"],"content":"登录模拟 ","date":"2020-12-09","objectID":"/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/:1:0","tags":["js","python "],"title":"学校教务系统模拟登陆","uri":"/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/"},{"categories":["Python"],"content":"关于 想尝试一下学校的官网，试试看。 ","date":"2020-12-09","objectID":"/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/:1:1","tags":["js","python "],"title":"学校教务系统模拟登陆","uri":"/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/"},{"categories":["Python"],"content":"登陆页面 学校的教务系统是青果公司的，很多版块页面都是单独的iframe。但是审查元素单独去访问显示没有权限。 登陆要求：账号，密码，验证码（以前好像是必须要输入验证码的，现在在一定输入次数之内，可以不用输入。） ","date":"2020-12-09","objectID":"/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/:1:2","tags":["js","python "],"title":"学校教务系统模拟登陆","uri":"/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/"},{"categories":["Python"],"content":"密码部分 随便输个错误的账号跟密码 发现一堆乱起八早的参数，经过测试，参数作用如下： 参数 说明 __VIEWSTATE html中的 __EVENTVALIDATION html中的 dsdsdsdsdxcxdfgfg 加密之后的密码 fgfggfdgtyuuyyuuckjg 加密之后的验证码 txt_asmcdefsddsd 输入的账号 txt_pewerwedsdfsdff 输入的密码 txt_psasas 验证码 密码加密肯定是js完成的，于是找js部分 鼠标点到输入框那，发现失去焦距和按键弹起会触发shtitblur()和chkpwd()函数，全局搜索，第一个没啥用，第二个出来了，正好是加密部分。 function chkpwd(obj) { if (obj.value != '') { var s = md5(document.all.txt_asmcdefsddsd.value + md5(obj.value).substring(0, 30).toUpperCase() + '12810').substring(0, 30).toUpperCase(); document.all.dsdsdsdsdxcxdfgfg.value = s; } else { document.all.dsdsdsdsdxcxdfgfg.value = obj.value; } } 这段js的意思是将密码用md5加密，取前30位转大写，然后与密码和学校代码和账号拼接，再进行md5加密取前30位转大写。验证码与密码差不多。 Python实现： #js中的md5加密实现 def md5(str): m = hashlib.md5() m.update(str.encode(\"utf-8\")) return m.hexdigest() #登录密码加密(dsdsdsdsdxcxdfgfg) def login_psd(userid,psd): global dsdsdsdsdsdxcxdfgfg dsdsdsdsdxcxdfgfg = md5(userid+md5(psd)[:30].upper()+'12810')[:30].upper() print(dsdsdsdsdsdxcxdfgfg) #登录验证码加密(fgfggfdgtyuuyyuuckjg) def login_yzm(verty_text): fgfggfdgtyuuyyuuckjg = md5(md5(verty_text.upper())[:30].upper()+\"12810\")[:30].upper() print(fgfggfdgtyuuyyuuckjg) ","date":"2020-12-09","objectID":"/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/:1:3","tags":["js","python "],"title":"学校教务系统模拟登陆","uri":"/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/"},{"categories":["Python"],"content":"cookie部分 做完上述，我以为我又行了，，，结果打脸，无法访问。。。 后来发现cookie部分有个ASP.NET_SessionId字段，这是个啥，每次请求还不一样，好像是随机的。查阅资料发现，ASP.NET用来判断web会话状态的一个参数，只要访问过页面之后就会保存在cookies中。 每次提交账号密码，都会生成一个新的cookie，保持同一个会话，否则无法访问。使用session_res = requests.session()保持会话，并拿到ASP.NET_SessionId的值。 session_res = requests.session() url = \"http://218.22.58.76:2346/_data/login_home.aspx\" headers = {\"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36\"} html = session_res.get(url,headers=headers).text session_id = session_res.cookies[\"ASP.NET_SessionId\"] 拼接header VIEWSTATE = re.findall(r'name=\"__VIEWSTATE\" id=\"__VIEWSTATE\" value=\"(.*?)\"',html)[0] EVENTVALIDATION = re.findall(r'name=\"__EVENTVALIDATION\" id=\"__EVENTVALIDATION\" value=\"(.*?)\"',html)[0] 最后，拼接headers和提交的参数data，使用post发送请求，成功登录。 后续可能会尝试进行课表的爬取，，，，， ","date":"2020-12-09","objectID":"/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/:1:4","tags":["js","python "],"title":"学校教务系统模拟登陆","uri":"/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/"},{"categories":["Python"],"content":"课表爬取 ","date":"2020-12-09","objectID":"/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/:2:0","tags":["js","python "],"title":"学校教务系统模拟登陆","uri":"/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/"},{"categories":["Python"],"content":"目标网页 url:http://218.22.58.76:2346/ZNPK/KBFB_ClassSel.aspx ","date":"2020-12-09","objectID":"/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/:2:1","tags":["js","python "],"title":"学校教务系统模拟登陆","uri":"/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/"},{"categories":["Python"],"content":"抓包分析 发现必须要输入验证码，而验证码里headers里面的cookie有两个字段,其中的sessionid获取方式上文提到了。首先访问一遍课表入口地址，通过session方法获取cookie字段，拿到值。 输入验证码，继续看发送了什么。post请求，发送了专业班级，学期，格式等等，但是这些不是重点。它还把验证码发过去了。返回的请求却不是课表，而是一段html。这就很奇怪，后面的那个get请求才是对的课表图片。 验证码正确： 验证码错误： 这段html是组成课表的头部，显示学校专业班级，好像跟课表没什么关系。但是，当验证码输错时，这个请求会弹出alert(“验证码错误”)，没有后续的课表图片请求了。 由此，http://218.22.58.76:2346/ZNPK/KBFB_ClassSel_rpt.aspx 的请求是为了判断验证码是否正确。正确则可以进行后续的请求，错误则警告，后续停止。 接着get一下目标图片的地址，显示全为乱码，content一下转二进制流即可。 重点在于使用相同cookie保持同一个会话(当时这里参数弄错了，困扰了我好久。。。)，还有就是验证码的作用，必须先提交post之后，get图片才有数据。 ","date":"2020-12-09","objectID":"/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/:2:2","tags":["js","python "],"title":"学校教务系统模拟登陆","uri":"/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/"},{"categories":["Python"],"content":"python实现 import requests url_rk = \"http://218.22.58.76:2346/ZNPK/KBFB_ClassSel.aspx\" #课表入口 url_yzm = \"http://218.22.58.76:2346/sys/ValidateCode.aspx\" #验证码 url_zz = \"http://218.22.58.76:2346/ZNPK/KBFB_ClassSel_rpt.aspx\" #验证码确认后的中转链接，返回html课表头部信息 url_kcb = \"http://218.22.58.76:2346/ZNPK/drawkbimg.aspx?type=1\u0026w=1110\u0026h=4480\u0026xn=2020\u0026xq=0\u0026bjdm=2017090101\" #任意一个课表链接 def get_cookie(): global cookies session_res = requests.session() session_res.get(url_rk) SessionId = session_res.cookies[\"ASP.NET_SessionId\"] # print(SessionId) cookies = { 'myCookie': '', 'ASP.NET_SessionId': SessionId, } def get_yzm(): header_yzm = { 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:83.0) Gecko/20100101 Firefox/83.0', 'Accept': 'image/webp,*/*', 'Accept-Language': 'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2', 'Connection': 'keep-alive', 'Referer': 'http://218.22.58.76:2346/ZNPK/KBFB_ClassSel.aspx', 'Pragma': 'no-cache', 'Cache-Control': 'no-cache', } response = requests.get(url_yzm, headers=header_yzm,cookies=cookies) with open('.png','wb') as f: f.write(response.content) print(\"yzm下载完成，请查看\") def download(): yzm = input(\"请输入验证码\") data = { 'Sel_XNXQ': '20200', 'txtxzbj': '', 'Sel_XZBJ': '2017090101', 'type': '1', 'txt_yzm': yzm } header_kb = { 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:83.0) Gecko/20100101 Firefox/83.0', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Language': 'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2', 'Content-Type': 'application/x-www-form-urlencoded', 'Origin': 'http://218.22.58.76:2346', 'Connection': 'keep-alive', 'Referer': 'http://218.22.58.76:2346/ZNPK/KBFB_ClassSel.aspx', 'Upgrade-Insecure-Requests': '1', 'Pragma': 'no-cache', 'Cache-Control': 'no-cache', } html = requests.post(url_zz, headers=header_kb, data=data,cookies=cookies).text # print(html) kcb = requests.get(url_kcb,headers=header_kb,data=data,cookies=cookies).content # print(kcb) with open('kcb.png','wb')as f: f.write(kcb) print(\"kcb完成\") get_cookie() get_yzm() download() ","date":"2020-12-09","objectID":"/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/:2:3","tags":["js","python "],"title":"学校教务系统模拟登陆","uri":"/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/"},{"categories":["爬虫"],"content":"关于 最近在吾爱破解论坛闲逛，发现有大佬发布了某网站爬虫题分析。很好奇，于是试了一下，发现我是真滴菜，好多类型的反爬措施都没见过，于是写篇博客来记录一些学习的思路过程。 网站链接：http://match.yuanrenxue.com/list ","date":"2020-12-05","objectID":"/%E6%9F%90%E7%BD%91%E7%AB%99%E7%88%AC%E8%99%AB%E7%BB%83%E4%B9%A0/:0:1","tags":["js","python "],"title":"某网站爬虫练习","uri":"/%E6%9F%90%E7%BD%91%E7%AB%99%E7%88%AC%E8%99%AB%E7%BB%83%E4%B9%A0/"},{"categories":["爬虫"],"content":"第十二题（入门级js） 题目链接：http://match.yuanrenxue.com/match/12 F12抓包找到json接口数据： http://match.yuanrenxue.com/api/match/12?page=1\u0026m=eXVhbnJlbnh1ZTE%3D http://match.yuanrenxue.com/api/match/12?page=2\u0026m=eXVhbnJlbnh1ZTI%3D http://match.yuanrenxue.com/api/match/12?page=3\u0026m=eXVhbnJlbnh1ZTM%3D 对url进行解码，发现%3D就是=。 两个参数，page：页数，m：不知道 找参数m，发现太多了。想到以前爬全民k歌的时候在当前html中页找到的js部分，试试看。果然，，，可行。 btoa()方法用于创建一个base-64编码的字符串。 base-64 解码使用方法是 atob() 。 即yuanrenxue+str(page)的base64加密 找个base64加密的网站测试,第一个yuanrenxue1加密后为 eXVhbnJlbnh1ZTE=，比对，成功。 代码： import requests import base64 headers = {\"User-Agent\":\"yuanrenxue.project\"} sum = 0 for i in range(1,6): m= base64.b64encode((\"yuanrenxue\"+str(i)).encode()).decode() url = \"http://match.yuanrenxue.com/api/match/12?page={}\u0026m={}\".format(i,m) response = requests.get(url,headers=headers).json() print(response) for each in response['data']: sum += each['value'] print(sum) ","date":"2020-12-05","objectID":"/%E6%9F%90%E7%BD%91%E7%AB%99%E7%88%AC%E8%99%AB%E7%BB%83%E4%B9%A0/:0:2","tags":["js","python "],"title":"某网站爬虫练习","uri":"/%E6%9F%90%E7%BD%91%E7%AB%99%E7%88%AC%E8%99%AB%E7%BB%83%E4%B9%A0/"},{"categories":["爬虫"],"content":"第十三题（入门级cookie） 题目链接：http://match.yuanrenxue.com/match/13 这题目我百思不得其解，为什么请求的数据都是空的，加了cookie还是无法显示。 后来询问大佬，才知道这是一道典型的cookie反爬类型题目。如果访问页面第一次出现明显的卡顿感，之后浏览器自动刷新了。很有可能就是这种类型。很多的cookie处理思路都是，服务器先返回js,浏览器自动执行，之后刷新页面再访问。 果不其然，观察了一下，刚开始所有数据数值都是500，之后数据自动刷新，数值才发生的改变。F12发现有两个名为13的数据包先后发送。另外还有一个是名为13的数据包是api接口数据。观察数据包发现请求url都是http://match.yuanrenxue.com/match/13，但是cookie处发生了改变，增加了yaunrenxue_cookie字段，所以，很明显，打开url后，返回js代码，运行生成cookie，给接口api使用。 使用接口测试一下，拿到js部分 document.cookie=('y')+('u')+('a')+('n')+('r')+('e')+('n')+('x')+('u')+('e')+('_')+('c')+('o')+('o')+('k')+('i')+('e')+('=')+('1')+('6')+('0')+('7')+('2')+('2')+('9')+('0')+('7')+('3')+('|')+('W')+('o')+('h')+('j')+('1')+('e')+('m')+('J')+('u')+('K')+('k')+('G')+('u')+('Y')+('H')+('X')+('z')+('s')+('4')+('m')+('t')+('A')+('8')+('h')+('u')+('B')+('E')+('b')+('f')+('A')+('X')+('B')+('F')+('t')+('9')+('G')+('A')+('N')+('c')+('d')+('R')+('H')+('r')+('M')+('M')+('F')+('H')+('q')+('L')+('0')+('8')+('G')+('s')+('o')+('f')+('B')+('R')+('V')+('C')+('N')+('u')+('D')+('l')+('f')+('O')+('t')+('l')+('Q')+('K')+('B')+('l')+('H')+('x')+('t')+('c')+('w')+('N')+('1')+('o')+('J')+('9')+('J')+('W')+('N')+('q')+';path=/';location.href=location.pathname+location.search 字段为这些字符串相加，用正则，找到cookie了,使用session来实现,cookie.set()方法用来添加cookie。 代码实现： import re import requests session = requests.Session() headers = {\"User-Agent\": \"yuanrenxue.project\"} url = \"http://match.yuanrenxue.com/match/13\" r = session.get(url).text # print(r) reg = re.compile(\"'([a-zA-Z0-9=|_])'\") results = reg.findall(r) # print(results) cookie =''.join(results) key,value = cookie.split('=') # print(key,value) a = session.cookies.set(key,value) sum = 0 for i in range(1,6): api_url =\"http://match.yuanrenxue.com/api/match/13?page={}\".format(i) r = session.get(api_url,headers = headers) data = r.json() # print(data) values = data[\"data\"] for i in values: sum += int(i[\"value\"]) print(sum) ","date":"2020-12-05","objectID":"/%E6%9F%90%E7%BD%91%E7%AB%99%E7%88%AC%E8%99%AB%E7%BB%83%E4%B9%A0/:0:3","tags":["js","python "],"title":"某网站爬虫练习","uri":"/%E6%9F%90%E7%BD%91%E7%AB%99%E7%88%AC%E8%99%AB%E7%BB%83%E4%B9%A0/"},{"categories":["爬虫"],"content":"第一题（js混淆源码乱码） ","date":"2020-12-05","objectID":"/%E6%9F%90%E7%BD%91%E7%AB%99%E7%88%AC%E8%99%AB%E7%BB%83%E4%B9%A0/:0:4","tags":["js","python "],"title":"某网站爬虫练习","uri":"/%E6%9F%90%E7%BD%91%E7%AB%99%E7%88%AC%E8%99%AB%E7%BB%83%E4%B9%A0/"},{"categories":["Python"],"content":"前言 希望最终的美好都能为你如期而置。 ","date":"2020-12-03","objectID":"/%E5%85%A8%E6%B0%91k%E6%AD%8C%E4%B8%8B%E8%BD%BD%E5%99%A8/:0:1","tags":["迁移"],"title":"全民K歌下载器","uri":"/%E5%85%A8%E6%B0%91k%E6%AD%8C%E4%B8%8B%E8%BD%BD%E5%99%A8/"},{"categories":["Python"],"content":"获取接口 1、目标：下载指定用户主页的全部歌曲。 2、对比url，删除不必要的参数后发现，用户uid为个人凭证。 3、分析网页源代码得到用户所有的json数据接口为https://node.kg.qq.com/cgi/fcgi-bin/kg_ugc_get_homepage?type=get_uinfo\u0026start={}\u0026num=10\u0026share_uid={} 第一个参数是页码，每页的json数据有10条，第二个参数为用户凭证信息。 ","date":"2020-12-03","objectID":"/%E5%85%A8%E6%B0%91k%E6%AD%8C%E4%B8%8B%E8%BD%BD%E5%99%A8/:0:2","tags":["迁移"],"title":"全民K歌下载器","uri":"/%E5%85%A8%E6%B0%91k%E6%AD%8C%E4%B8%8B%E8%BD%BD%E5%99%A8/"},{"categories":["Python"],"content":"代码实现 import requests from lxml import etree import json import time import re import os headers = { \"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.116 Safari/537.36\", } path = os.path.dirname(__file__) PATH = os.path.join(path,'music').replace('\\\\','/') if not os.path.exists(PATH): PATH = os.mkdir(PATH) print(\"下载路径：\"+PATH) def get_data(): c=0 uid = input(\"请输入k歌主页uid：\") header_url = \"https://kg.qq.com/node/personal?uid={}\".format(uid) r = requests.get(header_url,headers=headers).content.decode() user_name = \"\".join(etree.HTML(r).xpath(\"//*[@class = 'my_show__name']/text()\")) music_num = \"\".join(etree.HTML(r).xpath(\"//*[@class = 'my_nav__list']/li[1]/a/text()\"))[3:] num = int(music_num) // 10 if num != int(music_num) / 10: num = num + 2 print(\"昵称：{}——\u003e 一共有{}首音乐,数据共{}页\\n\".format(user_name,music_num,num-1)) for i in range(1,num-1): try: url = \"https://node.kg.qq.com/cgi/fcgi-bin/kg_ugc_get_homepage?type=get_uinfo\u0026start={}\u0026num=10\u0026share_uid={}\".format(i,uid) # print(url) print(\"\\n这是第{}页数据：{}\".format(i,url)) res = requests.get(url,headers=headers).text time.sleep(1) r = json.loads(res[18:-1]) music_name = r[\"data\"][\"ugclist\"] for a in music_name: title = a[\"title\"] if \"|\" or \"?\" or \":\" in title: title = title.replace(\"|\", \" \") title = title.replace(\"?\", \"\") title = title.replace(\":\", \"\") shareid = a[\"shareid\"] try: print(\" \"+title+\"--\u003e \"+\"https://kg.qq.com/node/personal?uid=\"+shareid) print(\" 正在下载……\") music_url = \"http://node.kg.qq.com/play?s={}\".format(shareid) data = requests.get(music_url,headers).text data_url = re.findall(r'playurl\":\"(.*?)\"', data)[0] res = requests.get(data_url, headers=headers,timeout=(1,30)) music = res.content path = os.path.join(PATH, f'{title}.mp3').replace('\\\\', '/') try: with open(path, 'ab')as f: f.write(music) f.flush() c = c+1 print(\" 【第{}首-——\u003e{}---\u003e下载成功】\".format(c,title)) except Exception as e: # news = \"!!!sorry，{}下载失败!!!,稍后重新下载\".format(title) print(e) except: pass except: pass get_data() ","date":"2020-12-03","objectID":"/%E5%85%A8%E6%B0%91k%E6%AD%8C%E4%B8%8B%E8%BD%BD%E5%99%A8/:0:3","tags":["迁移"],"title":"全民K歌下载器","uri":"/%E5%85%A8%E6%B0%91k%E6%AD%8C%E4%B8%8B%E8%BD%BD%E5%99%A8/"},{"categories":["Python"],"content":"运行截图 ","date":"2020-12-03","objectID":"/%E5%85%A8%E6%B0%91k%E6%AD%8C%E4%B8%8B%E8%BD%BD%E5%99%A8/:0:4","tags":["迁移"],"title":"全民K歌下载器","uri":"/%E5%85%A8%E6%B0%91k%E6%AD%8C%E4%B8%8B%E8%BD%BD%E5%99%A8/"},{"categories":["Python"],"content":"问题总结 1、由于把歌名作为MP3的文件名，所以歌名中如果出现\"|\",\"?\",\":\"等特殊符号，会报错，当时还纠结了好长时间，为什么会报错。。。 2、不足之处有一下几点： 1）如果用户把相同名称的歌曲重复发布，则会造成下载覆盖，只保留一首歌曲。 2）经过测试，发现下载成功率还是很高的。但是总有些例外没能下载下来，也没做下载失败的歌曲保存再等全体结束后重新下载。 3）这个程序只能一键下载某个用户的全部音乐，但是如果此用户后续更新了，不能针对更新的内容单独下载，体验性不高。 3、可能会更新，也可能不会，，， (本文由老博客迁移至此….) ============================ 后续 =========================== ","date":"2020-12-03","objectID":"/%E5%85%A8%E6%B0%91k%E6%AD%8C%E4%B8%8B%E8%BD%BD%E5%99%A8/:0:5","tags":["迁移"],"title":"全民K歌下载器","uri":"/%E5%85%A8%E6%B0%91k%E6%AD%8C%E4%B8%8B%E8%BD%BD%E5%99%A8/"},{"categories":["Python"],"content":"考古更新 2021年7月23日因为好基友的原因，特意考古，发现原来的代码有些问题，用不了了。晚上花了一个多小时重构了一下，弄成一个一个的方法，在主函数中调用。写的过程中发现有一些重复性的代码，写进一个方法里显然不是最合适的，更好的实现方式应该是写一个类。。但是太菜了，不会。。。后面有机会，再说吧 import requests import json import math import re import os # 获取请求头 def get_headers(): headers = { \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) \" \"Chrome/91.0.4472.101 Safari/537.36\", \"refer\": \"https://node.kg.qq.com/\" } return headers # 获取API接口链接 def public_url(num, id): url = f\"https://node.kg.qq.com/cgi/fcgi-bin/kg_ugc_get_homepage?type=get_uinfo\u0026start={num}\u0026num=10\u0026share_uid={id}\" headers = { \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) \" \"Chrome/91.0.4472.101 Safari/537.36\", \"refer\": \"https://node.kg.qq.com/\" } return url, headers # 运行时的头部装逼图 def zb_banner(): print(\"|\" + \"=\" * 41 + \" \" + \"=\" * 41 + \"|\") print(\"|\" + \"=\" * 17 + \" \" * 15 + \" 全 民 K 歌 下 载 器 \" + \" \" * 15 + \"=\" * 17 + \"|\") print(\"|\" + \"=\" * 17 + \" \" * 25 + \"By --- Lone\" + \" \" * 13 + \"=\" * 17 + \"|\") print(\"|\" + \"=\" * 41 + \" \" + \"=\" * 41 + \"|\") # 获得歌曲总数，进而得到要循环接口链接几次 def get_basic_data(uid): _, __ = public_url(1, uid) res = requests.get(_, headers=__).text # print(res[18:-2]) user_basic_data = json.loads(res[18:-1]) user_name = user_basic_data[\"data\"][\"nickname\"] # 用户昵称 user_fans_num = user_basic_data[\"data\"][\"follower\"] # 用户的粉丝数目 music_num = user_basic_data[\"data\"][\"ugc_total_count\"] # 歌曲总数目 # print(user_basic_data[\"data\"][\"ugc_total_count\"]) count = math.ceil(int(music_num) // 10) # 取出url要遍历的次数 print(f\"您查询的用户 昵称 =\u003e {user_name}\" + f\" 粉丝数 =\u003e {user_fans_num}位 ！\") print(f\"根据查询，目前此用户公开发布歌曲一共有 {music_num}首 ！\") return count # 通过接口，拿到了歌曲的名字和歌曲展示页面的网页（不是下载链接） def get_music_data(num, uid): music_list = [] # 歌曲列表 for i in range(1, num + 2): _, __ = public_url(i, uid) res = json.loads(requests.get(_, headers=__).text[18:-1]) # print(res) for a in res[\"data\"][\"ugclist\"]: shareId = a[\"shareid\"] music_name = a[\"title\"] # print(music_name) if \"|\" or \"?\" or \":\" in music_name: music_name = music_name.replace(\"|\", \" \") music_name = music_name.replace(\"?\", \"\") music_name = music_name.replace(\":\", \"\") # print(shareId, music_name) music_view_url = \"http://node.kg.qq.com/play?s=\" + shareId music = [music_name, music_view_url] # print(music) music_list.append(music) # [print(i) for i in music_list] return music_list # 使用正则，拿到歌曲展示页面的下载地址和名字 def get_down_url(info): music_down_list = [] for i in info: music_name = i[0] view_url = i[1] headers = get_headers() res = requests.get(view_url, headers=headers).text down_url = re.findall(r'playurl\":\"(.*?)\"', res)[0] music_down = [music_name, down_url] music_down_list.append(music_down) # [print(i) for i in music_down_list] return music_down_list # 通过访问下载链接，进行下载 def down_music(PATH, info): count = 0 for i in info: name = i[0] down_url = i[1] headers = get_headers() res = requests.get(down_url, headers=headers, timeout=(1, 30)).content path = os.path.join(PATH, f'{name}.mp3').replace('\\\\', '/') try: with open(path, 'ab')as f: f.write(res) f.flush() count += 1 print(\" 【第{}首-——\u003e{}---\u003e下载成功】\".format(count, name)) except Exception as e: print(e) # 函数入口，主函数 if __name__ == '__main__': zb_banner() uid = input(\"请输入想要查询用户的UID:\") path = os.path.dirname(__file__) PATH = os.path.join(path, 'music').replace('\\\\', '/') if not os.path.exists(PATH): os.mkdir(PATH) count = get_basic_data(uid) music_list = get_music_data(count, uid) print(\"已为您选择下载路径：\" + PATH) music_down_list = get_down_url(music_list) print(\"请耐心等待\") down_music(PATH, music_down_list) ","date":"2020-12-03","objectID":"/%E5%85%A8%E6%B0%91k%E6%AD%8C%E4%B8%8B%E8%BD%BD%E5%99%A8/:0:6","tags":["迁移"],"title":"全民K歌下载器","uri":"/%E5%85%A8%E6%B0%91k%E6%AD%8C%E4%B8%8B%E8%BD%BD%E5%99%A8/"},{"categories":["Python"],"content":"一些碎碎念 就在笔者写这些话的时候， 恍惚中，仿佛又回到了去年校园里那个燥热的夏天， 蝉鸣依旧，热烈而又执着， 那段时光应该是我大学里最快乐的时光， 这个软件最初的目的就是为了纪念我曾深爱着的那个女孩， 往事回忆，到平淡，那些重复或许仅仅是为了错失的过往…… ","date":"2020-12-03","objectID":"/%E5%85%A8%E6%B0%91k%E6%AD%8C%E4%B8%8B%E8%BD%BD%E5%99%A8/:0:7","tags":["迁移"],"title":"全民K歌下载器","uri":"/%E5%85%A8%E6%B0%91k%E6%AD%8C%E4%B8%8B%E8%BD%BD%E5%99%A8/"},{"categories":["随笔"],"content":"这只是一个测试 使用gitee+PicGo搭建了一个图床，真香。终于不用在网页上傻傻的上传了。 ","date":"2020-12-03","objectID":"/%E4%B8%80%E4%B8%AA%E5%BD%A9%E8%9B%8B/:0:1","tags":["essay"],"title":"关于一个彩蛋","uri":"/%E4%B8%80%E4%B8%AA%E5%BD%A9%E8%9B%8B/"},{"categories":["随笔"],"content":"图片 放几张图，作为测试用，看看效果。 ","date":"2020-12-03","objectID":"/%E4%B8%80%E4%B8%AA%E5%BD%A9%E8%9B%8B/:0:2","tags":["essay"],"title":"关于一个彩蛋","uri":"/%E4%B8%80%E4%B8%AA%E5%BD%A9%E8%9B%8B/"},{"categories":["随笔"],"content":"关于彩蛋 其实什么都没有，骗你们的，哈哈。 ","date":"2020-12-03","objectID":"/%E4%B8%80%E4%B8%AA%E5%BD%A9%E8%9B%8B/:0:3","tags":["essay"],"title":"关于一个彩蛋","uri":"/%E4%B8%80%E4%B8%AA%E5%BD%A9%E8%9B%8B/"},{"categories":["随笔"],"content":"今天是30号，还有一个月就到2020年的年底了。这是个特殊而难忘的一年，疫情，战火，党争，世界各地都焦头烂额。 下半年几乎都在学校，经历了起起落落，烦躁，难过，迷茫，无奈。或许这就是成长，但我还是希望时光能够慢一些，再多一些思考，多一些冷静，多一份回味。 想起去年这个时候还在易班工作，策划了一个晚安短信计划，在2019年的最后的一个月里，每天晚上给参与活动的人发送一条晚安短信。那时是我觉得在当年做的最有意义的一个活动了。 相隔整整一年，恍如昨日。曾经每天互发早晚安的人已经离开了，或许以后也不会有什么交集。如果有人问2020有遗憾吗？我一定会说，嗯。有着遗憾，有过太多。 生活也会逐入正轨，世界也总归会好的，不对吗。 纠结过于不如把握现在的时光，未来总会好的，不对吗。 希望大家都好，家人朋友健健康康，平安喜乐。 ","date":"2020-11-30","objectID":"/last-month/:0:0","tags":["diary"],"title":"Last month","uri":"/last-month/"},{"categories":["随笔"],"content":"Hello World hello,hexo. 第一次见到这个框架的时候，深深被惊艳到了，这也太好看了吧。 于是放弃WordPress，有了这个博客。 hello,World. 记录生活的美好与真实。 ","date":"2020-11-29","objectID":"/hello-world/:0:1","tags":["essay"],"title":"Hello World","uri":"/hello-world/"}]